# coding: utf-8

"""
    NSX API

    VMware NSX REST API  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class LogicalSwitchingApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_logical_port(self, logical_port, **kwargs):  # noqa: E501
        """Create a Logical Port  # noqa: E501

        Creates a new logical switch port. The required parameters are the associated logical_switch_id and admin_state (UP or DOWN). Optional parameters are the attachment and switching_profile_ids. If you don't specify switching_profile_ids, default switching profiles are assigned to the port. If you don't specify an attachment, the switch port remains empty. To configure an attachment, you must specify an id, and optionally you can specify an attachment_type (VIF or LOGICALROUTER). The attachment_type is VIF by default.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_logical_port(logical_port, async=True)
        >>> result = thread.get()

        :param async bool
        :param LogicalPort logical_port: (required)
        :return: LogicalPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_logical_port_with_http_info(logical_port, **kwargs)  # noqa: E501
        else:
            (data) = self.create_logical_port_with_http_info(logical_port, **kwargs)  # noqa: E501
            return data

    def create_logical_port_with_http_info(self, logical_port, **kwargs):  # noqa: E501
        """Create a Logical Port  # noqa: E501

        Creates a new logical switch port. The required parameters are the associated logical_switch_id and admin_state (UP or DOWN). Optional parameters are the attachment and switching_profile_ids. If you don't specify switching_profile_ids, default switching profiles are assigned to the port. If you don't specify an attachment, the switch port remains empty. To configure an attachment, you must specify an id, and optionally you can specify an attachment_type (VIF or LOGICALROUTER). The attachment_type is VIF by default.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_logical_port_with_http_info(logical_port, async=True)
        >>> result = thread.get()

        :param async bool
        :param LogicalPort logical_port: (required)
        :return: LogicalPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_port']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_logical_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_port' is set
        if ('logical_port' not in params or
                params['logical_port'] is None):
            raise ValueError("Missing the required parameter `logical_port` when calling `create_logical_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'logical_port' in params:
            body_params = params['logical_port']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalPort',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_logical_switch(self, logical_switch, **kwargs):  # noqa: E501
        """Create a Logical Switch  # noqa: E501

        Creates a new logical switch. The request must include the transport_zone_id, display_name, and admin_state (UP or DOWN). The replication_mode (MTEP or SOURCE) is required for overlay logical switches, but not for VLAN-based logical switches. A vlan needs to be provided for VLAN-based logical switches   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_logical_switch(logical_switch, async=True)
        >>> result = thread.get()

        :param async bool
        :param LogicalSwitch logical_switch: (required)
        :return: LogicalSwitch
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_logical_switch_with_http_info(logical_switch, **kwargs)  # noqa: E501
        else:
            (data) = self.create_logical_switch_with_http_info(logical_switch, **kwargs)  # noqa: E501
            return data

    def create_logical_switch_with_http_info(self, logical_switch, **kwargs):  # noqa: E501
        """Create a Logical Switch  # noqa: E501

        Creates a new logical switch. The request must include the transport_zone_id, display_name, and admin_state (UP or DOWN). The replication_mode (MTEP or SOURCE) is required for overlay logical switches, but not for VLAN-based logical switches. A vlan needs to be provided for VLAN-based logical switches   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_logical_switch_with_http_info(logical_switch, async=True)
        >>> result = thread.get()

        :param async bool
        :param LogicalSwitch logical_switch: (required)
        :return: LogicalSwitch
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_switch']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_logical_switch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_switch' is set
        if ('logical_switch' not in params or
                params['logical_switch'] is None):
            raise ValueError("Missing the required parameter `logical_switch` when calling `create_logical_switch`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'logical_switch' in params:
            body_params = params['logical_switch']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-switches', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalSwitch',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_switching_profile(self, base_switching_profile, **kwargs):  # noqa: E501
        """Create a Switching Profile  # noqa: E501

        Creates a new, custom qos, port-mirroring, spoof-guard or port-security switching profile. You can override their default switching profile assignments by creating a new switching profile and assigning it to one or more logical switches. You cannot override the default ipfix or ip_discovery switching profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_switching_profile(base_switching_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param BaseSwitchingProfile base_switching_profile: (required)
        :return: BaseSwitchingProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_switching_profile_with_http_info(base_switching_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.create_switching_profile_with_http_info(base_switching_profile, **kwargs)  # noqa: E501
            return data

    def create_switching_profile_with_http_info(self, base_switching_profile, **kwargs):  # noqa: E501
        """Create a Switching Profile  # noqa: E501

        Creates a new, custom qos, port-mirroring, spoof-guard or port-security switching profile. You can override their default switching profile assignments by creating a new switching profile and assigning it to one or more logical switches. You cannot override the default ipfix or ip_discovery switching profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_switching_profile_with_http_info(base_switching_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param BaseSwitchingProfile base_switching_profile: (required)
        :return: BaseSwitchingProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['base_switching_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_switching_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'base_switching_profile' is set
        if ('base_switching_profile' not in params or
                params['base_switching_profile'] is None):
            raise ValueError("Missing the required parameter `base_switching_profile` when calling `create_switching_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'base_switching_profile' in params:
            body_params = params['base_switching_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/switching-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseSwitchingProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_logical_port(self, lport_id, **kwargs):  # noqa: E501
        """Delete a Logical Port  # noqa: E501

        Deletes the specified logical switch port. By default, if logical port has attachments, or it is added to any NSGroup, the deletion will be failed. Option detach could be used for deleting logical port forcibly.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_logical_port(lport_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lport_id: (required)
        :param bool detach: force delete even if attached or referenced by a group
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_logical_port_with_http_info(lport_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_logical_port_with_http_info(lport_id, **kwargs)  # noqa: E501
            return data

    def delete_logical_port_with_http_info(self, lport_id, **kwargs):  # noqa: E501
        """Delete a Logical Port  # noqa: E501

        Deletes the specified logical switch port. By default, if logical port has attachments, or it is added to any NSGroup, the deletion will be failed. Option detach could be used for deleting logical port forcibly.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_logical_port_with_http_info(lport_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lport_id: (required)
        :param bool detach: force delete even if attached or referenced by a group
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lport_id', 'detach']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_logical_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lport_id' is set
        if ('lport_id' not in params or
                params['lport_id'] is None):
            raise ValueError("Missing the required parameter `lport_id` when calling `delete_logical_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lport_id' in params:
            path_params['lport-id'] = params['lport_id']  # noqa: E501

        query_params = []
        if 'detach' in params:
            query_params.append(('detach', params['detach']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports/{lport-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_logical_switch(self, lswitch_id, **kwargs):  # noqa: E501
        """Delete a Logical Switch  # noqa: E501

        Removes a logical switch from the associated overlay or VLAN transport zone. By default, a logical switch cannot be deleted if there are logical ports on the switch, or it is added to a NSGroup. Cascade option can be used to delete all ports and the logical switch. Detach option can be used to delete the logical switch forcibly.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_logical_switch(lswitch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lswitch_id: (required)
        :param bool cascade: Delete a Logical Switch and all the logical ports in it, if none of the logical ports have any attachment. 
        :param bool detach: Force delete a logical switch
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_logical_switch_with_http_info(lswitch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_logical_switch_with_http_info(lswitch_id, **kwargs)  # noqa: E501
            return data

    def delete_logical_switch_with_http_info(self, lswitch_id, **kwargs):  # noqa: E501
        """Delete a Logical Switch  # noqa: E501

        Removes a logical switch from the associated overlay or VLAN transport zone. By default, a logical switch cannot be deleted if there are logical ports on the switch, or it is added to a NSGroup. Cascade option can be used to delete all ports and the logical switch. Detach option can be used to delete the logical switch forcibly.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_logical_switch_with_http_info(lswitch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lswitch_id: (required)
        :param bool cascade: Delete a Logical Switch and all the logical ports in it, if none of the logical ports have any attachment. 
        :param bool detach: Force delete a logical switch
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lswitch_id', 'cascade', 'detach']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_logical_switch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lswitch_id' is set
        if ('lswitch_id' not in params or
                params['lswitch_id'] is None):
            raise ValueError("Missing the required parameter `lswitch_id` when calling `delete_logical_switch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lswitch_id' in params:
            path_params['lswitch-id'] = params['lswitch_id']  # noqa: E501

        query_params = []
        if 'cascade' in params:
            query_params.append(('cascade', params['cascade']))  # noqa: E501
        if 'detach' in params:
            query_params.append(('detach', params['detach']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-switches/{lswitch-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_switching_profile(self, switching_profile_id, **kwargs):  # noqa: E501
        """Delete a Switching Profile  # noqa: E501

        Deletes the specified switching profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_switching_profile(switching_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str switching_profile_id: (required)
        :param bool unbind: force unbinding of logical switches and ports from a switching profile
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_switching_profile_with_http_info(switching_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_switching_profile_with_http_info(switching_profile_id, **kwargs)  # noqa: E501
            return data

    def delete_switching_profile_with_http_info(self, switching_profile_id, **kwargs):  # noqa: E501
        """Delete a Switching Profile  # noqa: E501

        Deletes the specified switching profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_switching_profile_with_http_info(switching_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str switching_profile_id: (required)
        :param bool unbind: force unbinding of logical switches and ports from a switching profile
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['switching_profile_id', 'unbind']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_switching_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'switching_profile_id' is set
        if ('switching_profile_id' not in params or
                params['switching_profile_id'] is None):
            raise ValueError("Missing the required parameter `switching_profile_id` when calling `delete_switching_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'switching_profile_id' in params:
            path_params['switching-profile-id'] = params['switching_profile_id']  # noqa: E501

        query_params = []
        if 'unbind' in params:
            query_params.append(('unbind', params['unbind']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/switching-profiles/{switching-profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_port(self, lport_id, **kwargs):  # noqa: E501
        """Get Information About a Logical Port  # noqa: E501

        Returns information about a specified logical port.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_port(lport_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lport_id: (required)
        :return: LogicalPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_port_with_http_info(lport_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_port_with_http_info(lport_id, **kwargs)  # noqa: E501
            return data

    def get_logical_port_with_http_info(self, lport_id, **kwargs):  # noqa: E501
        """Get Information About a Logical Port  # noqa: E501

        Returns information about a specified logical port.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_port_with_http_info(lport_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lport_id: (required)
        :return: LogicalPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lport_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lport_id' is set
        if ('lport_id' not in params or
                params['lport_id'] is None):
            raise ValueError("Missing the required parameter `lport_id` when calling `get_logical_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lport_id' in params:
            path_params['lport-id'] = params['lport_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports/{lport-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalPort',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_port_mac_table(self, lport_id, **kwargs):  # noqa: E501
        """Get MAC table of a logical port with a given port id (lport-id)  # noqa: E501

        Returns MAC table of a specified logical port. If the target transport node id is not provided, the NSX manager will ask the controller for the transport node where the logical port is located. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_port_mac_table(lport_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lport_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: LogicalPortMacAddressListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_port_mac_table_with_http_info(lport_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_port_mac_table_with_http_info(lport_id, **kwargs)  # noqa: E501
            return data

    def get_logical_port_mac_table_with_http_info(self, lport_id, **kwargs):  # noqa: E501
        """Get MAC table of a logical port with a given port id (lport-id)  # noqa: E501

        Returns MAC table of a specified logical port. If the target transport node id is not provided, the NSX manager will ask the controller for the transport node where the logical port is located. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_port_mac_table_with_http_info(lport_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lport_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: LogicalPortMacAddressListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lport_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'source', 'transport_node_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_port_mac_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lport_id' is set
        if ('lport_id' not in params or
                params['lport_id'] is None):
            raise ValueError("Missing the required parameter `lport_id` when calling `get_logical_port_mac_table`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_logical_port_mac_table`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_logical_port_mac_table`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'lport_id' in params:
            path_params['lport-id'] = params['lport_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports/{lport-id}/mac-table', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalPortMacAddressListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_port_mac_table_in_csv_format_csv(self, lport_id, **kwargs):  # noqa: E501
        """Get MAC table of a logical port with a given port id (lport-id)  # noqa: E501

        Returns MAC table in CSV format of a specified logical port. If the target transport node id is not provided, the NSX manager will ask the controller for the transport node where the logical port is located. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_port_mac_table_in_csv_format_csv(lport_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lport_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: LogicalPortMacAddressCsvListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_port_mac_table_in_csv_format_csv_with_http_info(lport_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_port_mac_table_in_csv_format_csv_with_http_info(lport_id, **kwargs)  # noqa: E501
            return data

    def get_logical_port_mac_table_in_csv_format_csv_with_http_info(self, lport_id, **kwargs):  # noqa: E501
        """Get MAC table of a logical port with a given port id (lport-id)  # noqa: E501

        Returns MAC table in CSV format of a specified logical port. If the target transport node id is not provided, the NSX manager will ask the controller for the transport node where the logical port is located. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_port_mac_table_in_csv_format_csv_with_http_info(lport_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lport_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: LogicalPortMacAddressCsvListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lport_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'source', 'transport_node_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_port_mac_table_in_csv_format_csv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lport_id' is set
        if ('lport_id' not in params or
                params['lport_id'] is None):
            raise ValueError("Missing the required parameter `lport_id` when calling `get_logical_port_mac_table_in_csv_format_csv`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_logical_port_mac_table_in_csv_format_csv`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_logical_port_mac_table_in_csv_format_csv`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'lport_id' in params:
            path_params['lport-id'] = params['lport_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/csv'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports/{lport-id}/mac-table?format=csv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalPortMacAddressCsvListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_port_operational_status(self, lport_id, **kwargs):  # noqa: E501
        """Get Operational Status for Logical Port of a Given Port ID (lport-id)  # noqa: E501

        Returns operational status of a specified logical port.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_port_operational_status(lport_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lport_id: (required)
        :param str source: Data source type.
        :return: LogicalPortOperationalStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_port_operational_status_with_http_info(lport_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_port_operational_status_with_http_info(lport_id, **kwargs)  # noqa: E501
            return data

    def get_logical_port_operational_status_with_http_info(self, lport_id, **kwargs):  # noqa: E501
        """Get Operational Status for Logical Port of a Given Port ID (lport-id)  # noqa: E501

        Returns operational status of a specified logical port.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_port_operational_status_with_http_info(lport_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lport_id: (required)
        :param str source: Data source type.
        :return: LogicalPortOperationalStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lport_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_port_operational_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lport_id' is set
        if ('lport_id' not in params or
                params['lport_id'] is None):
            raise ValueError("Missing the required parameter `lport_id` when calling `get_logical_port_operational_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lport_id' in params:
            path_params['lport-id'] = params['lport_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports/{lport-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalPortOperationalStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_port_state(self, lport_id, **kwargs):  # noqa: E501
        """Get realized state &amp; location of a logical port  # noqa: E501

        Returns transport node id for a specified logical port. Also returns information about all address bindings of the specified logical port. This includes address bindings discovered via various snooping methods like ARP snooping, DHCP snooping etc. and addressing bindings that are realized based on user configuration.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_port_state(lport_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lport_id: (required)
        :return: LogicalPortState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_port_state_with_http_info(lport_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_port_state_with_http_info(lport_id, **kwargs)  # noqa: E501
            return data

    def get_logical_port_state_with_http_info(self, lport_id, **kwargs):  # noqa: E501
        """Get realized state &amp; location of a logical port  # noqa: E501

        Returns transport node id for a specified logical port. Also returns information about all address bindings of the specified logical port. This includes address bindings discovered via various snooping methods like ARP snooping, DHCP snooping etc. and addressing bindings that are realized based on user configuration.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_port_state_with_http_info(lport_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lport_id: (required)
        :return: LogicalPortState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lport_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_port_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lport_id' is set
        if ('lport_id' not in params or
                params['lport_id'] is None):
            raise ValueError("Missing the required parameter `lport_id` when calling `get_logical_port_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lport_id' in params:
            path_params['lport-id'] = params['lport_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports/{lport-id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalPortState',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_port_statistics(self, lport_id, **kwargs):  # noqa: E501
        """Get Statistics for Logical Port of a Given Port ID (lport-id)  # noqa: E501

        Returns statistics of a specified logical port. If the logical port is attached to a logical router port, query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_port_statistics(lport_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lport_id: (required)
        :param str source: Data source type.
        :return: LogicalPortStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_port_statistics_with_http_info(lport_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_port_statistics_with_http_info(lport_id, **kwargs)  # noqa: E501
            return data

    def get_logical_port_statistics_with_http_info(self, lport_id, **kwargs):  # noqa: E501
        """Get Statistics for Logical Port of a Given Port ID (lport-id)  # noqa: E501

        Returns statistics of a specified logical port. If the logical port is attached to a logical router port, query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_port_statistics_with_http_info(lport_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lport_id: (required)
        :param str source: Data source type.
        :return: LogicalPortStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lport_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_port_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lport_id' is set
        if ('lport_id' not in params or
                params['lport_id'] is None):
            raise ValueError("Missing the required parameter `lport_id` when calling `get_logical_port_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lport_id' in params:
            path_params['lport-id'] = params['lport_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports/{lport-id}/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalPortStatistics',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_port_status_summary(self, **kwargs):  # noqa: E501
        """Get Operational Status Summary of All Logical Ports in the System  # noqa: E501

        Returns operational status of all logical ports. The query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_port_status_summary(async=True)
        >>> result = thread.get()

        :param async bool
        :param str attachment_id: Logical Port attachment Id
        :param str attachment_type: Type of attachment for logical port; for query only.
        :param str bridge_cluster_id: Bridge Cluster identifier
        :param bool container_ports_only: Only container VIF logical ports will be returned if true
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool diagnostic: Flag to enable showing of transit logical port.
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str logical_switch_id: Logical Switch identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str parent_vif_id: ID of the VIF of type PARENT
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str switching_profile_id: Network Profile identifier
        :param str transport_node_id: Transport node identifier
        :param str transport_zone_id: Transport zone identifier
        :return: LogicalPortStatusSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_port_status_summary_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_port_status_summary_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_logical_port_status_summary_with_http_info(self, **kwargs):  # noqa: E501
        """Get Operational Status Summary of All Logical Ports in the System  # noqa: E501

        Returns operational status of all logical ports. The query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_port_status_summary_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str attachment_id: Logical Port attachment Id
        :param str attachment_type: Type of attachment for logical port; for query only.
        :param str bridge_cluster_id: Bridge Cluster identifier
        :param bool container_ports_only: Only container VIF logical ports will be returned if true
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool diagnostic: Flag to enable showing of transit logical port.
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str logical_switch_id: Logical Switch identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str parent_vif_id: ID of the VIF of type PARENT
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str switching_profile_id: Network Profile identifier
        :param str transport_node_id: Transport node identifier
        :param str transport_zone_id: Transport zone identifier
        :return: LogicalPortStatusSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['attachment_id', 'attachment_type', 'bridge_cluster_id', 'container_ports_only', 'cursor', 'diagnostic', 'included_fields', 'logical_switch_id', 'page_size', 'parent_vif_id', 'sort_ascending', 'sort_by', 'source', 'switching_profile_id', 'transport_node_id', 'transport_zone_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_port_status_summary" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_logical_port_status_summary`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_logical_port_status_summary`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'attachment_id' in params:
            query_params.append(('attachment_id', params['attachment_id']))  # noqa: E501
        if 'attachment_type' in params:
            query_params.append(('attachment_type', params['attachment_type']))  # noqa: E501
        if 'bridge_cluster_id' in params:
            query_params.append(('bridge_cluster_id', params['bridge_cluster_id']))  # noqa: E501
        if 'container_ports_only' in params:
            query_params.append(('container_ports_only', params['container_ports_only']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'diagnostic' in params:
            query_params.append(('diagnostic', params['diagnostic']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'logical_switch_id' in params:
            query_params.append(('logical_switch_id', params['logical_switch_id']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'parent_vif_id' in params:
            query_params.append(('parent_vif_id', params['parent_vif_id']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'switching_profile_id' in params:
            query_params.append(('switching_profile_id', params['switching_profile_id']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501
        if 'transport_zone_id' in params:
            query_params.append(('transport_zone_id', params['transport_zone_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalPortStatusSummary',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_switch(self, lswitch_id, **kwargs):  # noqa: E501
        """Get Logical Switch associated with the provided id (lswitch-id)  # noqa: E501

        Returns information about the specified logical switch Id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_switch(lswitch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lswitch_id: (required)
        :return: LogicalSwitch
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_switch_with_http_info(lswitch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_switch_with_http_info(lswitch_id, **kwargs)  # noqa: E501
            return data

    def get_logical_switch_with_http_info(self, lswitch_id, **kwargs):  # noqa: E501
        """Get Logical Switch associated with the provided id (lswitch-id)  # noqa: E501

        Returns information about the specified logical switch Id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_switch_with_http_info(lswitch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lswitch_id: (required)
        :return: LogicalSwitch
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lswitch_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_switch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lswitch_id' is set
        if ('lswitch_id' not in params or
                params['lswitch_id'] is None):
            raise ValueError("Missing the required parameter `lswitch_id` when calling `get_logical_switch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lswitch_id' in params:
            path_params['lswitch-id'] = params['lswitch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-switches/{lswitch-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalSwitch',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_switch_mac_table(self, lswitch_id, **kwargs):  # noqa: E501
        """Get MAC Table for Logical Switch of the Given ID (lswitch-id)  # noqa: E501

        Returns MAC table of a specified logical switch from the given transport node if a transport node id is given in the query parameter from the Central Controller Plane. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_switch_mac_table(lswitch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lswitch_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: MacAddressListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_switch_mac_table_with_http_info(lswitch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_switch_mac_table_with_http_info(lswitch_id, **kwargs)  # noqa: E501
            return data

    def get_logical_switch_mac_table_with_http_info(self, lswitch_id, **kwargs):  # noqa: E501
        """Get MAC Table for Logical Switch of the Given ID (lswitch-id)  # noqa: E501

        Returns MAC table of a specified logical switch from the given transport node if a transport node id is given in the query parameter from the Central Controller Plane. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_switch_mac_table_with_http_info(lswitch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lswitch_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: MacAddressListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lswitch_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'source', 'transport_node_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_switch_mac_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lswitch_id' is set
        if ('lswitch_id' not in params or
                params['lswitch_id'] is None):
            raise ValueError("Missing the required parameter `lswitch_id` when calling `get_logical_switch_mac_table`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_logical_switch_mac_table`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_logical_switch_mac_table`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'lswitch_id' in params:
            path_params['lswitch-id'] = params['lswitch_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-switches/{lswitch-id}/mac-table', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MacAddressListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_switch_mac_table_in_csv_format_csv(self, lswitch_id, **kwargs):  # noqa: E501
        """Get MAC Table for Logical Switch of the Given ID (lswitch-id)  # noqa: E501

        Returns MAC table of a specified logical switch in CSV format from the given transport node if a transport node id is given in the query parameter from the Central Controller Plane. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_switch_mac_table_in_csv_format_csv(lswitch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lswitch_id: (required)
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: MacAddressCsvListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_switch_mac_table_in_csv_format_csv_with_http_info(lswitch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_switch_mac_table_in_csv_format_csv_with_http_info(lswitch_id, **kwargs)  # noqa: E501
            return data

    def get_logical_switch_mac_table_in_csv_format_csv_with_http_info(self, lswitch_id, **kwargs):  # noqa: E501
        """Get MAC Table for Logical Switch of the Given ID (lswitch-id)  # noqa: E501

        Returns MAC table of a specified logical switch in CSV format from the given transport node if a transport node id is given in the query parameter from the Central Controller Plane. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_switch_mac_table_in_csv_format_csv_with_http_info(lswitch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lswitch_id: (required)
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: MacAddressCsvListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lswitch_id', 'source', 'transport_node_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_switch_mac_table_in_csv_format_csv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lswitch_id' is set
        if ('lswitch_id' not in params or
                params['lswitch_id'] is None):
            raise ValueError("Missing the required parameter `lswitch_id` when calling `get_logical_switch_mac_table_in_csv_format_csv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lswitch_id' in params:
            path_params['lswitch-id'] = params['lswitch_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/csv'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-switches/{lswitch-id}/mac-table?format=csv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MacAddressCsvListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_switch_state(self, lswitch_id, **kwargs):  # noqa: E501
        """Get the realized state associated with provided logical switch id  # noqa: E501

        Returns current state of the logical switch configuration and details of only out-of-sync transport nodes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_switch_state(lswitch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lswitch_id: (required)
        :return: LogicalSwitchState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_switch_state_with_http_info(lswitch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_switch_state_with_http_info(lswitch_id, **kwargs)  # noqa: E501
            return data

    def get_logical_switch_state_with_http_info(self, lswitch_id, **kwargs):  # noqa: E501
        """Get the realized state associated with provided logical switch id  # noqa: E501

        Returns current state of the logical switch configuration and details of only out-of-sync transport nodes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_switch_state_with_http_info(lswitch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lswitch_id: (required)
        :return: LogicalSwitchState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lswitch_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_switch_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lswitch_id' is set
        if ('lswitch_id' not in params or
                params['lswitch_id'] is None):
            raise ValueError("Missing the required parameter `lswitch_id` when calling `get_logical_switch_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lswitch_id' in params:
            path_params['lswitch-id'] = params['lswitch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-switches/{lswitch-id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalSwitchState',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_switch_statistics(self, lswitch_id, **kwargs):  # noqa: E501
        """Get Statistics for Logical Switch of the Given ID (lswitch-id)  # noqa: E501

        Returns statistics  of a specified logical switch. The query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_switch_statistics(lswitch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lswitch_id: (required)
        :param str source: Data source type.
        :return: LogicalSwitchStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_switch_statistics_with_http_info(lswitch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_switch_statistics_with_http_info(lswitch_id, **kwargs)  # noqa: E501
            return data

    def get_logical_switch_statistics_with_http_info(self, lswitch_id, **kwargs):  # noqa: E501
        """Get Statistics for Logical Switch of the Given ID (lswitch-id)  # noqa: E501

        Returns statistics  of a specified logical switch. The query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_switch_statistics_with_http_info(lswitch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lswitch_id: (required)
        :param str source: Data source type.
        :return: LogicalSwitchStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lswitch_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_switch_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lswitch_id' is set
        if ('lswitch_id' not in params or
                params['lswitch_id'] is None):
            raise ValueError("Missing the required parameter `lswitch_id` when calling `get_logical_switch_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lswitch_id' in params:
            path_params['lswitch-id'] = params['lswitch_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-switches/{lswitch-id}/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalSwitchStatistics',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_switch_status(self, lswitch_id, **kwargs):  # noqa: E501
        """Get Logical Switch runtime status info for a given logical switch  # noqa: E501

        Returns the number of ports assigned to a logical switch.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_switch_status(lswitch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lswitch_id: (required)
        :return: LogicalSwitchStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_switch_status_with_http_info(lswitch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_switch_status_with_http_info(lswitch_id, **kwargs)  # noqa: E501
            return data

    def get_logical_switch_status_with_http_info(self, lswitch_id, **kwargs):  # noqa: E501
        """Get Logical Switch runtime status info for a given logical switch  # noqa: E501

        Returns the number of ports assigned to a logical switch.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_switch_status_with_http_info(lswitch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lswitch_id: (required)
        :return: LogicalSwitchStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lswitch_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_switch_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lswitch_id' is set
        if ('lswitch_id' not in params or
                params['lswitch_id'] is None):
            raise ValueError("Missing the required parameter `lswitch_id` when calling `get_logical_switch_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lswitch_id' in params:
            path_params['lswitch-id'] = params['lswitch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-switches/{lswitch-id}/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalSwitchStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_switch_status_summary(self, **kwargs):  # noqa: E501
        """Get Status Summary of All Logical Switches in the System  # noqa: E501

        Returns Operational status of all logical switches. The query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_switch_status_summary(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool diagnostic: Flag to enable showing of transit logical switch.
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str switching_profile_id: Switching Profile identifier
        :param str transport_type: Mode of transport supported in the transport zone for this logical switch
        :param str transport_zone_id: Transport zone identifier
        :return: LogicalSwitchStatusSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_switch_status_summary_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_switch_status_summary_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_logical_switch_status_summary_with_http_info(self, **kwargs):  # noqa: E501
        """Get Status Summary of All Logical Switches in the System  # noqa: E501

        Returns Operational status of all logical switches. The query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_switch_status_summary_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool diagnostic: Flag to enable showing of transit logical switch.
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str switching_profile_id: Switching Profile identifier
        :param str transport_type: Mode of transport supported in the transport zone for this logical switch
        :param str transport_zone_id: Transport zone identifier
        :return: LogicalSwitchStatusSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'diagnostic', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'source', 'switching_profile_id', 'transport_type', 'transport_zone_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_switch_status_summary" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_logical_switch_status_summary`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_logical_switch_status_summary`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'diagnostic' in params:
            query_params.append(('diagnostic', params['diagnostic']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'switching_profile_id' in params:
            query_params.append(('switching_profile_id', params['switching_profile_id']))  # noqa: E501
        if 'transport_type' in params:
            query_params.append(('transport_type', params['transport_type']))  # noqa: E501
        if 'transport_zone_id' in params:
            query_params.append(('transport_zone_id', params['transport_zone_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-switches/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalSwitchStatusSummary',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_switch_vtep_table(self, lswitch_id, **kwargs):  # noqa: E501
        """Get virtual tunnel endpoint table for logical switch of the given ID (lswitch-id)   # noqa: E501

        Returns the virtual tunnel endpoint table of a specified logical switch from the given transport node if a transport node id is given in the query parameter, from the Central Controller Plane. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_switch_vtep_table(lswitch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lswitch_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: VtepListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_switch_vtep_table_with_http_info(lswitch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_switch_vtep_table_with_http_info(lswitch_id, **kwargs)  # noqa: E501
            return data

    def get_logical_switch_vtep_table_with_http_info(self, lswitch_id, **kwargs):  # noqa: E501
        """Get virtual tunnel endpoint table for logical switch of the given ID (lswitch-id)   # noqa: E501

        Returns the virtual tunnel endpoint table of a specified logical switch from the given transport node if a transport node id is given in the query parameter, from the Central Controller Plane. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_switch_vtep_table_with_http_info(lswitch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lswitch_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: VtepListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lswitch_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'source', 'transport_node_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_switch_vtep_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lswitch_id' is set
        if ('lswitch_id' not in params or
                params['lswitch_id'] is None):
            raise ValueError("Missing the required parameter `lswitch_id` when calling `get_logical_switch_vtep_table`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_logical_switch_vtep_table`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_logical_switch_vtep_table`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'lswitch_id' in params:
            path_params['lswitch-id'] = params['lswitch_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-switches/{lswitch-id}/vtep-table', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VtepListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_switch_vtep_table_in_csv_format_csv(self, lswitch_id, **kwargs):  # noqa: E501
        """Get virtual tunnel endpoint table for logical switch of the given ID (lswitch-id)   # noqa: E501

        Returns virtual tunnel endpoint table of a specified logical switch in CSV format from the given transport node if a transport node id is given in the query parameter from the Central Controller Plane. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_switch_vtep_table_in_csv_format_csv(lswitch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lswitch_id: (required)
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: VtepCsvListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_switch_vtep_table_in_csv_format_csv_with_http_info(lswitch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_switch_vtep_table_in_csv_format_csv_with_http_info(lswitch_id, **kwargs)  # noqa: E501
            return data

    def get_logical_switch_vtep_table_in_csv_format_csv_with_http_info(self, lswitch_id, **kwargs):  # noqa: E501
        """Get virtual tunnel endpoint table for logical switch of the given ID (lswitch-id)   # noqa: E501

        Returns virtual tunnel endpoint table of a specified logical switch in CSV format from the given transport node if a transport node id is given in the query parameter from the Central Controller Plane. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_switch_vtep_table_in_csv_format_csv_with_http_info(lswitch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lswitch_id: (required)
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: VtepCsvListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lswitch_id', 'source', 'transport_node_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_switch_vtep_table_in_csv_format_csv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lswitch_id' is set
        if ('lswitch_id' not in params or
                params['lswitch_id'] is None):
            raise ValueError("Missing the required parameter `lswitch_id` when calling `get_logical_switch_vtep_table_in_csv_format_csv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lswitch_id' in params:
            path_params['lswitch-id'] = params['lswitch_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/csv'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-switches/{lswitch-id}/vtep-table?format=csv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VtepCsvListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_switching_profile(self, switching_profile_id, **kwargs):  # noqa: E501
        """Get Switching Profile by ID  # noqa: E501

        Returns information about a specified switching profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_switching_profile(switching_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str switching_profile_id: (required)
        :return: BaseSwitchingProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_switching_profile_with_http_info(switching_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_switching_profile_with_http_info(switching_profile_id, **kwargs)  # noqa: E501
            return data

    def get_switching_profile_with_http_info(self, switching_profile_id, **kwargs):  # noqa: E501
        """Get Switching Profile by ID  # noqa: E501

        Returns information about a specified switching profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_switching_profile_with_http_info(switching_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str switching_profile_id: (required)
        :return: BaseSwitchingProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['switching_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_switching_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'switching_profile_id' is set
        if ('switching_profile_id' not in params or
                params['switching_profile_id'] is None):
            raise ValueError("Missing the required parameter `switching_profile_id` when calling `get_switching_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'switching_profile_id' in params:
            path_params['switching-profile-id'] = params['switching_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/switching-profiles/{switching-profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseSwitchingProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_switching_profile_status(self, switching_profile_id, **kwargs):  # noqa: E501
        """Get Counts of Ports and Switches Using This Switching Profile  # noqa: E501

        Get Counts of Ports and Switches Using This Switching Profile  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_switching_profile_status(switching_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str switching_profile_id: (required)
        :return: SwitchingProfileStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_switching_profile_status_with_http_info(switching_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_switching_profile_status_with_http_info(switching_profile_id, **kwargs)  # noqa: E501
            return data

    def get_switching_profile_status_with_http_info(self, switching_profile_id, **kwargs):  # noqa: E501
        """Get Counts of Ports and Switches Using This Switching Profile  # noqa: E501

        Get Counts of Ports and Switches Using This Switching Profile  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_switching_profile_status_with_http_info(switching_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str switching_profile_id: (required)
        :return: SwitchingProfileStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['switching_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_switching_profile_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'switching_profile_id' is set
        if ('switching_profile_id' not in params or
                params['switching_profile_id'] is None):
            raise ValueError("Missing the required parameter `switching_profile_id` when calling `get_switching_profile_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'switching_profile_id' in params:
            path_params['switching-profile-id'] = params['switching_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/switching-profiles/{switching-profile-id}/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SwitchingProfileStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_logical_ports(self, **kwargs):  # noqa: E501
        """List All Logical Ports  # noqa: E501

        Returns information about all configured logical switch ports. Logical switch ports connect to VM virtual network interface cards (NICs). Each logical port is associated with one logical switch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_logical_ports(async=True)
        >>> result = thread.get()

        :param async bool
        :param str attachment_id: Logical Port attachment Id
        :param str attachment_type: Type of attachment for logical port; for query only.
        :param str bridge_cluster_id: Bridge Cluster identifier
        :param bool container_ports_only: Only container VIF logical ports will be returned if true
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool diagnostic: Flag to enable showing of transit logical port.
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str logical_switch_id: Logical Switch identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str parent_vif_id: ID of the VIF of type PARENT
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str switching_profile_id: Network Profile identifier
        :param str transport_node_id: Transport node identifier
        :param str transport_zone_id: Transport zone identifier
        :return: LogicalPortListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_logical_ports_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_logical_ports_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_logical_ports_with_http_info(self, **kwargs):  # noqa: E501
        """List All Logical Ports  # noqa: E501

        Returns information about all configured logical switch ports. Logical switch ports connect to VM virtual network interface cards (NICs). Each logical port is associated with one logical switch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_logical_ports_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str attachment_id: Logical Port attachment Id
        :param str attachment_type: Type of attachment for logical port; for query only.
        :param str bridge_cluster_id: Bridge Cluster identifier
        :param bool container_ports_only: Only container VIF logical ports will be returned if true
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool diagnostic: Flag to enable showing of transit logical port.
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str logical_switch_id: Logical Switch identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str parent_vif_id: ID of the VIF of type PARENT
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str switching_profile_id: Network Profile identifier
        :param str transport_node_id: Transport node identifier
        :param str transport_zone_id: Transport zone identifier
        :return: LogicalPortListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['attachment_id', 'attachment_type', 'bridge_cluster_id', 'container_ports_only', 'cursor', 'diagnostic', 'included_fields', 'logical_switch_id', 'page_size', 'parent_vif_id', 'sort_ascending', 'sort_by', 'switching_profile_id', 'transport_node_id', 'transport_zone_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_logical_ports" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_logical_ports`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_logical_ports`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'attachment_id' in params:
            query_params.append(('attachment_id', params['attachment_id']))  # noqa: E501
        if 'attachment_type' in params:
            query_params.append(('attachment_type', params['attachment_type']))  # noqa: E501
        if 'bridge_cluster_id' in params:
            query_params.append(('bridge_cluster_id', params['bridge_cluster_id']))  # noqa: E501
        if 'container_ports_only' in params:
            query_params.append(('container_ports_only', params['container_ports_only']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'diagnostic' in params:
            query_params.append(('diagnostic', params['diagnostic']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'logical_switch_id' in params:
            query_params.append(('logical_switch_id', params['logical_switch_id']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'parent_vif_id' in params:
            query_params.append(('parent_vif_id', params['parent_vif_id']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'switching_profile_id' in params:
            query_params.append(('switching_profile_id', params['switching_profile_id']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501
        if 'transport_zone_id' in params:
            query_params.append(('transport_zone_id', params['transport_zone_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalPortListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_logical_switches(self, **kwargs):  # noqa: E501
        """List all Logical Switches  # noqa: E501

        Returns information about all configured logical switches.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_logical_switches(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool diagnostic: Flag to enable showing of transit logical switch.
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str switching_profile_id: Switching Profile identifier
        :param str transport_type: Mode of transport supported in the transport zone for this logical switch
        :param str transport_zone_id: Transport zone identifier
        :return: LogicalSwitchListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_logical_switches_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_logical_switches_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_logical_switches_with_http_info(self, **kwargs):  # noqa: E501
        """List all Logical Switches  # noqa: E501

        Returns information about all configured logical switches.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_logical_switches_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool diagnostic: Flag to enable showing of transit logical switch.
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str switching_profile_id: Switching Profile identifier
        :param str transport_type: Mode of transport supported in the transport zone for this logical switch
        :param str transport_zone_id: Transport zone identifier
        :return: LogicalSwitchListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'diagnostic', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'switching_profile_id', 'transport_type', 'transport_zone_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_logical_switches" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_logical_switches`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_logical_switches`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'diagnostic' in params:
            query_params.append(('diagnostic', params['diagnostic']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'switching_profile_id' in params:
            query_params.append(('switching_profile_id', params['switching_profile_id']))  # noqa: E501
        if 'transport_type' in params:
            query_params.append(('transport_type', params['transport_type']))  # noqa: E501
        if 'transport_zone_id' in params:
            query_params.append(('transport_zone_id', params['transport_zone_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-switches', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalSwitchListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_logical_switches_by_state(self, **kwargs):  # noqa: E501
        """List logical switches by realized state  # noqa: E501

        Returns a list of logical switches states that have realized state as provided as query parameter.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_logical_switches_by_state(async=True)
        >>> result = thread.get()

        :param async bool
        :param str status: Realized state of logical switches
        :return: LogicalSwitchStateListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_logical_switches_by_state_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_logical_switches_by_state_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_logical_switches_by_state_with_http_info(self, **kwargs):  # noqa: E501
        """List logical switches by realized state  # noqa: E501

        Returns a list of logical switches states that have realized state as provided as query parameter.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_logical_switches_by_state_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str status: Realized state of logical switches
        :return: LogicalSwitchStateListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['status']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_logical_switches_by_state" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-switches/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalSwitchStateListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_switching_profiles(self, **kwargs):  # noqa: E501
        """List Switching Profiles  # noqa: E501

        Returns information about the system-default and user-configured switching profiles. Each switching profile has a unique ID, a display name, and various other read-only and configurable properties. The default switching profiles are assigned automatically to each switch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_switching_profiles(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool include_system_owned: Whether the list result contains system resources
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str switching_profile_type: comma-separated list of switching profile types, e.g. ?switching_profile_type=QosSwitchingProfile,PortMirroringSwitchingProfile
        :return: SwitchingProfilesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_switching_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_switching_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_switching_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """List Switching Profiles  # noqa: E501

        Returns information about the system-default and user-configured switching profiles. Each switching profile has a unique ID, a display name, and various other read-only and configurable properties. The default switching profiles are assigned automatically to each switch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_switching_profiles_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool include_system_owned: Whether the list result contains system resources
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str switching_profile_type: comma-separated list of switching profile types, e.g. ?switching_profile_type=QosSwitchingProfile,PortMirroringSwitchingProfile
        :return: SwitchingProfilesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'include_system_owned', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'switching_profile_type']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_switching_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_switching_profiles`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_switching_profiles`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'include_system_owned' in params:
            query_params.append(('include_system_owned', params['include_system_owned']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'switching_profile_type' in params:
            query_params.append(('switching_profile_type', params['switching_profile_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/switching-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SwitchingProfilesListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_logical_port(self, lport_id, logical_port, **kwargs):  # noqa: E501
        """Update a Logical Port  # noqa: E501

        Modifies an existing logical switch port. Parameters that can be modified include attachment_type (LOGICALROUTER, VIF), admin_state (UP or DOWN), attachment id and switching_profile_ids. You cannot modify the logical_switch_id. In other words, you cannot move an existing port from one switch to another switch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_logical_port(lport_id, logical_port, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lport_id: (required)
        :param LogicalPort logical_port: (required)
        :return: LogicalPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_logical_port_with_http_info(lport_id, logical_port, **kwargs)  # noqa: E501
        else:
            (data) = self.update_logical_port_with_http_info(lport_id, logical_port, **kwargs)  # noqa: E501
            return data

    def update_logical_port_with_http_info(self, lport_id, logical_port, **kwargs):  # noqa: E501
        """Update a Logical Port  # noqa: E501

        Modifies an existing logical switch port. Parameters that can be modified include attachment_type (LOGICALROUTER, VIF), admin_state (UP or DOWN), attachment id and switching_profile_ids. You cannot modify the logical_switch_id. In other words, you cannot move an existing port from one switch to another switch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_logical_port_with_http_info(lport_id, logical_port, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lport_id: (required)
        :param LogicalPort logical_port: (required)
        :return: LogicalPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lport_id', 'logical_port']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_logical_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lport_id' is set
        if ('lport_id' not in params or
                params['lport_id'] is None):
            raise ValueError("Missing the required parameter `lport_id` when calling `update_logical_port`")  # noqa: E501
        # verify the required parameter 'logical_port' is set
        if ('logical_port' not in params or
                params['logical_port'] is None):
            raise ValueError("Missing the required parameter `logical_port` when calling `update_logical_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lport_id' in params:
            path_params['lport-id'] = params['lport_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'logical_port' in params:
            body_params = params['logical_port']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports/{lport-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalPort',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_logical_switch(self, lswitch_id, logical_switch, **kwargs):  # noqa: E501
        """Update a Logical Switch  # noqa: E501

        Modifies attributes of an existing logical switch. Modifiable attributes include admin_state, replication_mode, switching_profile_ids and vlan. You cannot modify the original transport_zone_id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_logical_switch(lswitch_id, logical_switch, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lswitch_id: (required)
        :param LogicalSwitch logical_switch: (required)
        :return: LogicalSwitch
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_logical_switch_with_http_info(lswitch_id, logical_switch, **kwargs)  # noqa: E501
        else:
            (data) = self.update_logical_switch_with_http_info(lswitch_id, logical_switch, **kwargs)  # noqa: E501
            return data

    def update_logical_switch_with_http_info(self, lswitch_id, logical_switch, **kwargs):  # noqa: E501
        """Update a Logical Switch  # noqa: E501

        Modifies attributes of an existing logical switch. Modifiable attributes include admin_state, replication_mode, switching_profile_ids and vlan. You cannot modify the original transport_zone_id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_logical_switch_with_http_info(lswitch_id, logical_switch, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lswitch_id: (required)
        :param LogicalSwitch logical_switch: (required)
        :return: LogicalSwitch
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lswitch_id', 'logical_switch']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_logical_switch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lswitch_id' is set
        if ('lswitch_id' not in params or
                params['lswitch_id'] is None):
            raise ValueError("Missing the required parameter `lswitch_id` when calling `update_logical_switch`")  # noqa: E501
        # verify the required parameter 'logical_switch' is set
        if ('logical_switch' not in params or
                params['logical_switch'] is None):
            raise ValueError("Missing the required parameter `logical_switch` when calling `update_logical_switch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lswitch_id' in params:
            path_params['lswitch-id'] = params['lswitch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'logical_switch' in params:
            body_params = params['logical_switch']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-switches/{lswitch-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalSwitch',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_switching_profile(self, switching_profile_id, base_switching_profile, **kwargs):  # noqa: E501
        """Update a Switching Profile  # noqa: E501

        Updates the user-configurable parameters of a switching profile. Only the qos, port-mirroring, spoof-guard and port-security switching profiles can be modified. You cannot modify the ipfix or ip-discovery switching profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_switching_profile(switching_profile_id, base_switching_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str switching_profile_id: (required)
        :param BaseSwitchingProfile base_switching_profile: (required)
        :return: BaseSwitchingProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_switching_profile_with_http_info(switching_profile_id, base_switching_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.update_switching_profile_with_http_info(switching_profile_id, base_switching_profile, **kwargs)  # noqa: E501
            return data

    def update_switching_profile_with_http_info(self, switching_profile_id, base_switching_profile, **kwargs):  # noqa: E501
        """Update a Switching Profile  # noqa: E501

        Updates the user-configurable parameters of a switching profile. Only the qos, port-mirroring, spoof-guard and port-security switching profiles can be modified. You cannot modify the ipfix or ip-discovery switching profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_switching_profile_with_http_info(switching_profile_id, base_switching_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str switching_profile_id: (required)
        :param BaseSwitchingProfile base_switching_profile: (required)
        :return: BaseSwitchingProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['switching_profile_id', 'base_switching_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_switching_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'switching_profile_id' is set
        if ('switching_profile_id' not in params or
                params['switching_profile_id'] is None):
            raise ValueError("Missing the required parameter `switching_profile_id` when calling `update_switching_profile`")  # noqa: E501
        # verify the required parameter 'base_switching_profile' is set
        if ('base_switching_profile' not in params or
                params['base_switching_profile'] is None):
            raise ValueError("Missing the required parameter `base_switching_profile` when calling `update_switching_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'switching_profile_id' in params:
            path_params['switching-profile-id'] = params['switching_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'base_switching_profile' in params:
            body_params = params['base_switching_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/switching-profiles/{switching-profile-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseSwitchingProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
