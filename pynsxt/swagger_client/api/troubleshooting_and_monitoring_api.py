# coding: utf-8

"""
    NSX API

    VMware NSX REST API  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class TroubleshootingAndMonitoringApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_port_mirroring_sessions(self, port_mirroring_session, **kwargs):  # noqa: E501
        """Create a mirror session  # noqa: E501

        Create a mirror session  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_port_mirroring_sessions(port_mirroring_session, async=True)
        >>> result = thread.get()

        :param async bool
        :param PortMirroringSession port_mirroring_session: (required)
        :return: PortMirroringSession
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_port_mirroring_sessions_with_http_info(port_mirroring_session, **kwargs)  # noqa: E501
        else:
            (data) = self.create_port_mirroring_sessions_with_http_info(port_mirroring_session, **kwargs)  # noqa: E501
            return data

    def create_port_mirroring_sessions_with_http_info(self, port_mirroring_session, **kwargs):  # noqa: E501
        """Create a mirror session  # noqa: E501

        Create a mirror session  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_port_mirroring_sessions_with_http_info(port_mirroring_session, async=True)
        >>> result = thread.get()

        :param async bool
        :param PortMirroringSession port_mirroring_session: (required)
        :return: PortMirroringSession
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['port_mirroring_session']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_port_mirroring_sessions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'port_mirroring_session' is set
        if ('port_mirroring_session' not in params or
                params['port_mirroring_session'] is None):
            raise ValueError("Missing the required parameter `port_mirroring_session` when calling `create_port_mirroring_sessions`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'port_mirroring_session' in params:
            body_params = params['port_mirroring_session']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/mirror-sessions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PortMirroringSession',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_traceflow(self, traceflow_request, **kwargs):  # noqa: E501
        """Initiate a Traceflow Operation on the Specified Port  # noqa: E501

        Initiate a Traceflow Operation on the Specified Port  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_traceflow(traceflow_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param TraceflowRequest traceflow_request: (required)
        :return: Traceflow
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_traceflow_with_http_info(traceflow_request, **kwargs)  # noqa: E501
        else:
            (data) = self.create_traceflow_with_http_info(traceflow_request, **kwargs)  # noqa: E501
            return data

    def create_traceflow_with_http_info(self, traceflow_request, **kwargs):  # noqa: E501
        """Initiate a Traceflow Operation on the Specified Port  # noqa: E501

        Initiate a Traceflow Operation on the Specified Port  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_traceflow_with_http_info(traceflow_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param TraceflowRequest traceflow_request: (required)
        :return: Traceflow
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['traceflow_request']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_traceflow" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'traceflow_request' is set
        if ('traceflow_request' not in params or
                params['traceflow_request'] is None):
            raise ValueError("Missing the required parameter `traceflow_request` when calling `create_traceflow`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'traceflow_request' in params:
            body_params = params['traceflow_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/traceflows', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Traceflow',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_port_mirroring_session(self, mirror_session_id, **kwargs):  # noqa: E501
        """Delete the mirror session  # noqa: E501

        Delete the mirror session  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_port_mirroring_session(mirror_session_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str mirror_session_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_port_mirroring_session_with_http_info(mirror_session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_port_mirroring_session_with_http_info(mirror_session_id, **kwargs)  # noqa: E501
            return data

    def delete_port_mirroring_session_with_http_info(self, mirror_session_id, **kwargs):  # noqa: E501
        """Delete the mirror session  # noqa: E501

        Delete the mirror session  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_port_mirroring_session_with_http_info(mirror_session_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str mirror_session_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mirror_session_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_port_mirroring_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mirror_session_id' is set
        if ('mirror_session_id' not in params or
                params['mirror_session_id'] is None):
            raise ValueError("Missing the required parameter `mirror_session_id` when calling `delete_port_mirroring_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mirror_session_id' in params:
            path_params['mirror-session-id'] = params['mirror_session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/mirror-sessions/{mirror-session-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_traceflow(self, traceflow_id, **kwargs):  # noqa: E501
        """Delete the Traceflow round  # noqa: E501

        Delete the Traceflow round  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_traceflow(traceflow_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str traceflow_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_traceflow_with_http_info(traceflow_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_traceflow_with_http_info(traceflow_id, **kwargs)  # noqa: E501
            return data

    def delete_traceflow_with_http_info(self, traceflow_id, **kwargs):  # noqa: E501
        """Delete the Traceflow round  # noqa: E501

        Delete the Traceflow round  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_traceflow_with_http_info(traceflow_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str traceflow_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['traceflow_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_traceflow" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'traceflow_id' is set
        if ('traceflow_id' not in params or
                params['traceflow_id'] is None):
            raise ValueError("Missing the required parameter `traceflow_id` when calling `delete_traceflow`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'traceflow_id' in params:
            path_params['traceflow-id'] = params['traceflow_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/traceflows/{traceflow-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_transport_nodes_status(self, **kwargs):  # noqa: E501
        """Get high-level summary of all transport nodes. The service layer does not support source &#x3D; realtime or cached.  # noqa: E501

        Get high-level summary of all transport nodes. The service layer does not support source = realtime or cached.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_all_transport_nodes_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: HeatMapTransportZoneStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_all_transport_nodes_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_transport_nodes_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_transport_nodes_status_with_http_info(self, **kwargs):  # noqa: E501
        """Get high-level summary of all transport nodes. The service layer does not support source &#x3D; realtime or cached.  # noqa: E501

        Get high-level summary of all transport nodes. The service layer does not support source = realtime or cached.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_all_transport_nodes_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: HeatMapTransportZoneStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_transport_nodes_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HeatMapTransportZoneStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_transport_zone_status(self, **kwargs):  # noqa: E501
        """Get high-level summary of a transport zone. The service layer does not support source &#x3D; realtime or cached.  # noqa: E501

        Get high-level summary of a transport zone. The service layer does not support source = realtime or cached.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_all_transport_zone_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: HeatMapTransportNodesAggregateStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_all_transport_zone_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_transport_zone_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_transport_zone_status_with_http_info(self, **kwargs):  # noqa: E501
        """Get high-level summary of a transport zone. The service layer does not support source &#x3D; realtime or cached.  # noqa: E501

        Get high-level summary of a transport zone. The service layer does not support source = realtime or cached.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_all_transport_zone_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: HeatMapTransportNodesAggregateStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_transport_zone_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-zones/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HeatMapTransportNodesAggregateStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_forwarding_path(self, lport_id, peer_port_id, **kwargs):  # noqa: E501
        """Get networking entities between two logical ports with VIF attachment  # noqa: E501

        Get networking entities between two logical ports with VIF attachment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_forwarding_path(lport_id, peer_port_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lport_id: ID of source port (required)
        :param str peer_port_id: ID of peer port (required)
        :return: PortConnectionEntities
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_forwarding_path_with_http_info(lport_id, peer_port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_forwarding_path_with_http_info(lport_id, peer_port_id, **kwargs)  # noqa: E501
            return data

    def get_forwarding_path_with_http_info(self, lport_id, peer_port_id, **kwargs):  # noqa: E501
        """Get networking entities between two logical ports with VIF attachment  # noqa: E501

        Get networking entities between two logical ports with VIF attachment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_forwarding_path_with_http_info(lport_id, peer_port_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str lport_id: ID of source port (required)
        :param str peer_port_id: ID of peer port (required)
        :return: PortConnectionEntities
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lport_id', 'peer_port_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_forwarding_path" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lport_id' is set
        if ('lport_id' not in params or
                params['lport_id'] is None):
            raise ValueError("Missing the required parameter `lport_id` when calling `get_forwarding_path`")  # noqa: E501
        # verify the required parameter 'peer_port_id' is set
        if ('peer_port_id' not in params or
                params['peer_port_id'] is None):
            raise ValueError("Missing the required parameter `peer_port_id` when calling `get_forwarding_path`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lport_id' in params:
            path_params['lport-id'] = params['lport_id']  # noqa: E501

        query_params = []
        if 'peer_port_id' in params:
            query_params.append(('peer_port_id', params['peer_port_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-ports/{lport-id}/forwarding-path', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PortConnectionEntities',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_heatmap_transport_zone_status(self, zone_id, **kwargs):  # noqa: E501
        """Get high-level summary of a transport zone  # noqa: E501

        Get high-level summary of a transport zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_heatmap_transport_zone_status(zone_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str zone_id: ID of transport zone (required)
        :param str source: Data source type.
        :return: HeatMapTransportZoneStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_heatmap_transport_zone_status_with_http_info(zone_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_heatmap_transport_zone_status_with_http_info(zone_id, **kwargs)  # noqa: E501
            return data

    def get_heatmap_transport_zone_status_with_http_info(self, zone_id, **kwargs):  # noqa: E501
        """Get high-level summary of a transport zone  # noqa: E501

        Get high-level summary of a transport zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_heatmap_transport_zone_status_with_http_info(zone_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str zone_id: ID of transport zone (required)
        :param str source: Data source type.
        :return: HeatMapTransportZoneStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['zone_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_heatmap_transport_zone_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'zone_id' is set
        if ('zone_id' not in params or
                params['zone_id'] is None):
            raise ValueError("Missing the required parameter `zone_id` when calling `get_heatmap_transport_zone_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'zone_id' in params:
            path_params['zone-id'] = params['zone_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-zones/{zone-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HeatMapTransportZoneStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ipfix_obs_points(self, **kwargs):  # noqa: E501
        """Get the list of IPFIX observation points  # noqa: E501

        Get the list of IPFIX observation points  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_ipfix_obs_points(async=True)
        >>> result = thread.get()

        :param async bool
        :return: IpfixObsPointsListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_ipfix_obs_points_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_ipfix_obs_points_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_ipfix_obs_points_with_http_info(self, **kwargs):  # noqa: E501
        """Get the list of IPFIX observation points  # noqa: E501

        Get the list of IPFIX observation points  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_ipfix_obs_points_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: IpfixObsPointsListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ipfix_obs_points" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ipfix-obs-points', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IpfixObsPointsListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pnic_statuses_for_transport_node(self, node_id, **kwargs):  # noqa: E501
        """Get high-level summary of a transport node  # noqa: E501

        Get high-level summary of a transport node  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_pnic_statuses_for_transport_node(node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: ID of transport node (required)
        :return: PnicBondStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_pnic_statuses_for_transport_node_with_http_info(node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_pnic_statuses_for_transport_node_with_http_info(node_id, **kwargs)  # noqa: E501
            return data

    def get_pnic_statuses_for_transport_node_with_http_info(self, node_id, **kwargs):  # noqa: E501
        """Get high-level summary of a transport node  # noqa: E501

        Get high-level summary of a transport node  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_pnic_statuses_for_transport_node_with_http_info(node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: ID of transport node (required)
        :return: PnicBondStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pnic_statuses_for_transport_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `get_pnic_statuses_for_transport_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{node-id}/pnic-bond-status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PnicBondStatusListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_port_mirroring_session(self, mirror_session_id, **kwargs):  # noqa: E501
        """Get the mirror session  # noqa: E501

        Get the mirror session  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_port_mirroring_session(mirror_session_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str mirror_session_id: (required)
        :return: PortMirroringSession
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_port_mirroring_session_with_http_info(mirror_session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_port_mirroring_session_with_http_info(mirror_session_id, **kwargs)  # noqa: E501
            return data

    def get_port_mirroring_session_with_http_info(self, mirror_session_id, **kwargs):  # noqa: E501
        """Get the mirror session  # noqa: E501

        Get the mirror session  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_port_mirroring_session_with_http_info(mirror_session_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str mirror_session_id: (required)
        :return: PortMirroringSession
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mirror_session_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_port_mirroring_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mirror_session_id' is set
        if ('mirror_session_id' not in params or
                params['mirror_session_id'] is None):
            raise ValueError("Missing the required parameter `mirror_session_id` when calling `get_port_mirroring_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mirror_session_id' in params:
            path_params['mirror-session-id'] = params['mirror_session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/mirror-sessions/{mirror-session-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PortMirroringSession',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_switch_ipfix_config(self, **kwargs):  # noqa: E501
        """Read global switch IPFIX export configuration  # noqa: E501

        Read global switch IPFIX export configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_switch_ipfix_config(async=True)
        >>> result = thread.get()

        :param async bool
        :return: IpfixObsPointConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_switch_ipfix_config_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_switch_ipfix_config_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_switch_ipfix_config_with_http_info(self, **kwargs):  # noqa: E501
        """Read global switch IPFIX export configuration  # noqa: E501

        Read global switch IPFIX export configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_switch_ipfix_config_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: IpfixObsPointConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_switch_ipfix_config" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ipfix-obs-points/switch-global', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IpfixObsPointConfig',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_traceflow(self, traceflow_id, **kwargs):  # noqa: E501
        """Get the Traceflow round status and result summary  # noqa: E501

        Get the Traceflow round status and result summary  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_traceflow(traceflow_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str traceflow_id: (required)
        :return: Traceflow
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_traceflow_with_http_info(traceflow_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_traceflow_with_http_info(traceflow_id, **kwargs)  # noqa: E501
            return data

    def get_traceflow_with_http_info(self, traceflow_id, **kwargs):  # noqa: E501
        """Get the Traceflow round status and result summary  # noqa: E501

        Get the Traceflow round status and result summary  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_traceflow_with_http_info(traceflow_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str traceflow_id: (required)
        :return: Traceflow
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['traceflow_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_traceflow" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'traceflow_id' is set
        if ('traceflow_id' not in params or
                params['traceflow_id'] is None):
            raise ValueError("Missing the required parameter `traceflow_id` when calling `get_traceflow`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'traceflow_id' in params:
            path_params['traceflow-id'] = params['traceflow_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/traceflows/{traceflow-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Traceflow',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_traceflow_observations(self, traceflow_id, **kwargs):  # noqa: E501
        """Get observations for the Traceflow round  # noqa: E501

        Get observations for the Traceflow round  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_traceflow_observations(traceflow_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str traceflow_id: (required)
        :param str component_name: Observations having the given component name will be listed.
        :param str component_type: Observations having the given component type will be listed.
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str resource_type: The type of observations that will be listed.
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str transport_node_name: Observations having the given transport node name will be listed.
        :return: TraceflowObservationListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_traceflow_observations_with_http_info(traceflow_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_traceflow_observations_with_http_info(traceflow_id, **kwargs)  # noqa: E501
            return data

    def get_traceflow_observations_with_http_info(self, traceflow_id, **kwargs):  # noqa: E501
        """Get observations for the Traceflow round  # noqa: E501

        Get observations for the Traceflow round  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_traceflow_observations_with_http_info(traceflow_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str traceflow_id: (required)
        :param str component_name: Observations having the given component name will be listed.
        :param str component_type: Observations having the given component type will be listed.
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str resource_type: The type of observations that will be listed.
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str transport_node_name: Observations having the given transport node name will be listed.
        :return: TraceflowObservationListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['traceflow_id', 'component_name', 'component_type', 'cursor', 'included_fields', 'page_size', 'resource_type', 'sort_ascending', 'sort_by', 'transport_node_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_traceflow_observations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'traceflow_id' is set
        if ('traceflow_id' not in params or
                params['traceflow_id'] is None):
            raise ValueError("Missing the required parameter `traceflow_id` when calling `get_traceflow_observations`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_traceflow_observations`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_traceflow_observations`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'traceflow_id' in params:
            path_params['traceflow-id'] = params['traceflow_id']  # noqa: E501

        query_params = []
        if 'component_name' in params:
            query_params.append(('component_name', params['component_name']))  # noqa: E501
        if 'component_type' in params:
            query_params.append(('component_type', params['component_type']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'resource_type' in params:
            query_params.append(('resource_type', params['resource_type']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'transport_node_name' in params:
            query_params.append(('transport_node_name', params['transport_node_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/traceflows/{traceflow-id}/observations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TraceflowObservationListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transport_node_report(self, **kwargs):  # noqa: E501
        """Creates a status report of transport nodes of all the transport zones  # noqa: E501

        Creates a status report of transport nodes of all the transport zones  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transport_node_report(async=True)
        >>> result = thread.get()

        :param async bool
        :param str source: Data source type.
        :param str status: Transport node
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_transport_node_report_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_transport_node_report_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_transport_node_report_with_http_info(self, **kwargs):  # noqa: E501
        """Creates a status report of transport nodes of all the transport zones  # noqa: E501

        Creates a status report of transport nodes of all the transport zones  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transport_node_report_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str source: Data source type.
        :param str status: Transport node
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['source', 'status']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transport_node_report" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-zones/transport-node-status-report', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transport_node_report_for_a_transport_zone(self, zone_id, **kwargs):  # noqa: E501
        """Creates a status report of transport nodes in a transport zone  # noqa: E501

        Creates a status report of transport nodes in a transport zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transport_node_report_for_a_transport_zone(zone_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str zone_id: ID of transport zone (required)
        :param str source: Data source type.
        :param str status: Transport node
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_transport_node_report_for_a_transport_zone_with_http_info(zone_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transport_node_report_for_a_transport_zone_with_http_info(zone_id, **kwargs)  # noqa: E501
            return data

    def get_transport_node_report_for_a_transport_zone_with_http_info(self, zone_id, **kwargs):  # noqa: E501
        """Creates a status report of transport nodes in a transport zone  # noqa: E501

        Creates a status report of transport nodes in a transport zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transport_node_report_for_a_transport_zone_with_http_info(zone_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str zone_id: ID of transport zone (required)
        :param str source: Data source type.
        :param str status: Transport node
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['zone_id', 'source', 'status']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transport_node_report_for_a_transport_zone" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'zone_id' is set
        if ('zone_id' not in params or
                params['zone_id'] is None):
            raise ValueError("Missing the required parameter `zone_id` when calling `get_transport_node_report_for_a_transport_zone`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'zone_id' in params:
            path_params['zone-id'] = params['zone_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-zones/{zone-id}/transport-node-status-report', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transport_node_status(self, node_id, **kwargs):  # noqa: E501
        """Read status of a transport node  # noqa: E501

        Read status of a transport node  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transport_node_status(node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: ID of transport node (required)
        :param str source: Data source type.
        :return: TransportNodeStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_transport_node_status_with_http_info(node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transport_node_status_with_http_info(node_id, **kwargs)  # noqa: E501
            return data

    def get_transport_node_status_with_http_info(self, node_id, **kwargs):  # noqa: E501
        """Read status of a transport node  # noqa: E501

        Read status of a transport node  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transport_node_status_with_http_info(node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: ID of transport node (required)
        :param str source: Data source type.
        :return: TransportNodeStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transport_node_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `get_transport_node_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{node-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNodeStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_node_logs(self, **kwargs):  # noqa: E501
        """List available node logs  # noqa: E501

        Returns the number of log files and lists the log files that reside on the NSX virtual appliance. The list includes the filename, file size, and last-modified time in milliseconds since epoch (1 January 1970) for each log file. Knowing the last-modified time with millisecond accuracy since epoch is helpful when you are comparing two times, such as the time of a POST request and the end time on a server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_node_logs(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeLogPropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_node_logs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_node_logs_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_node_logs_with_http_info(self, **kwargs):  # noqa: E501
        """List available node logs  # noqa: E501

        Returns the number of log files and lists the log files that reside on the NSX virtual appliance. The list includes the filename, file size, and last-modified time in milliseconds since epoch (1 January 1970) for each log file. Knowing the last-modified time with millisecond accuracy since epoch is helpful when you are comparing two times, such as the time of a POST request and the end time on a server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_node_logs_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeLogPropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_node_logs" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeLogPropertiesListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_port_mirroring_session(self, **kwargs):  # noqa: E501
        """List all mirror sessions  # noqa: E501

        List all mirror sessions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_port_mirroring_session(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: PortMirroringSessionListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_port_mirroring_session_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_port_mirroring_session_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_port_mirroring_session_with_http_info(self, **kwargs):  # noqa: E501
        """List all mirror sessions  # noqa: E501

        List all mirror sessions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_port_mirroring_session_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: PortMirroringSessionListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_port_mirroring_session" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_port_mirroring_session`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_port_mirroring_session`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/mirror-sessions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PortMirroringSessionListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_remote_transport_node_status(self, node_id, **kwargs):  # noqa: E501
        """Read status of all transport nodes with tunnel connections to transport node   # noqa: E501

        Read status of all transport nodes with tunnel connections to transport node   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_remote_transport_node_status(node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: ID of transport node (required)
        :param str bfd_diagnostic_code: BFD diagnostic code of Tunnel as defined in RFC 5880
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str tunnel_status: Tunnel Status
        :return: TransportNodeStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_remote_transport_node_status_with_http_info(node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_remote_transport_node_status_with_http_info(node_id, **kwargs)  # noqa: E501
            return data

    def list_remote_transport_node_status_with_http_info(self, node_id, **kwargs):  # noqa: E501
        """Read status of all transport nodes with tunnel connections to transport node   # noqa: E501

        Read status of all transport nodes with tunnel connections to transport node   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_remote_transport_node_status_with_http_info(node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: ID of transport node (required)
        :param str bfd_diagnostic_code: BFD diagnostic code of Tunnel as defined in RFC 5880
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str tunnel_status: Tunnel Status
        :return: TransportNodeStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id', 'bfd_diagnostic_code', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'source', 'tunnel_status']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_remote_transport_node_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `list_remote_transport_node_status`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_remote_transport_node_status`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_remote_transport_node_status`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501

        query_params = []
        if 'bfd_diagnostic_code' in params:
            query_params.append(('bfd_diagnostic_code', params['bfd_diagnostic_code']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'tunnel_status' in params:
            query_params.append(('tunnel_status', params['tunnel_status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{node-id}/remote-transport-node-status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNodeStatusListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_traceflows(self, **kwargs):  # noqa: E501
        """List all Traceflow rounds  # noqa: E501

        List all Traceflow rounds; if a logical port id is given as a query parameter, only those originated from the logical port are returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_traceflows(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str lport_id: id of the source logical port where the trace flows originated
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: TraceflowListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_traceflows_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_traceflows_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_traceflows_with_http_info(self, **kwargs):  # noqa: E501
        """List all Traceflow rounds  # noqa: E501

        List all Traceflow rounds; if a logical port id is given as a query parameter, only those originated from the logical port are returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_traceflows_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str lport_id: id of the source logical port where the trace flows originated
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: TraceflowListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'lport_id', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_traceflows" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_traceflows`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_traceflows`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'lport_id' in params:
            query_params.append(('lport_id', params['lport_id']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/traceflows', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TraceflowListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_transport_node_status(self, **kwargs):  # noqa: E501
        """Read status of all the transport nodes  # noqa: E501

        Read status of all the transport nodes  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_transport_node_status(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str status: Transport node
        :return: TransportNodeStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_transport_node_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_transport_node_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_transport_node_status_with_http_info(self, **kwargs):  # noqa: E501
        """Read status of all the transport nodes  # noqa: E501

        Read status of all the transport nodes  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_transport_node_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str status: Transport node
        :return: TransportNodeStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'source', 'status']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_transport_node_status" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_transport_node_status`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_transport_node_status`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-zones/transport-node-status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNodeStatusListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_transport_node_status_for_transport_zone(self, zone_id, **kwargs):  # noqa: E501
        """Read status of transport nodes in a transport zone  # noqa: E501

        Read status of transport nodes in a transport zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_transport_node_status_for_transport_zone(zone_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str zone_id: ID of transport zone (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str status: Transport node
        :return: TransportNodeStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_transport_node_status_for_transport_zone_with_http_info(zone_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_transport_node_status_for_transport_zone_with_http_info(zone_id, **kwargs)  # noqa: E501
            return data

    def list_transport_node_status_for_transport_zone_with_http_info(self, zone_id, **kwargs):  # noqa: E501
        """Read status of transport nodes in a transport zone  # noqa: E501

        Read status of transport nodes in a transport zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_transport_node_status_for_transport_zone_with_http_info(zone_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str zone_id: ID of transport zone (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str status: Transport node
        :return: TransportNodeStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['zone_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'source', 'status']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_transport_node_status_for_transport_zone" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'zone_id' is set
        if ('zone_id' not in params or
                params['zone_id'] is None):
            raise ValueError("Missing the required parameter `zone_id` when calling `list_transport_node_status_for_transport_zone`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_transport_node_status_for_transport_zone`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_transport_node_status_for_transport_zone`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'zone_id' in params:
            path_params['zone-id'] = params['zone_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-zones/{zone-id}/transport-node-status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNodeStatusListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_node_log(self, log_name, **kwargs):  # noqa: E501
        """Read node log properties  # noqa: E501

        For a single specified log file, lists the filename, file size, and last-modified time.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_log(log_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str log_name: Name of log file to read properties (required)
        :return: NodeLogProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_node_log_with_http_info(log_name, **kwargs)  # noqa: E501
        else:
            (data) = self.read_node_log_with_http_info(log_name, **kwargs)  # noqa: E501
            return data

    def read_node_log_with_http_info(self, log_name, **kwargs):  # noqa: E501
        """Read node log properties  # noqa: E501

        For a single specified log file, lists the filename, file size, and last-modified time.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_log_with_http_info(log_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str log_name: Name of log file to read properties (required)
        :return: NodeLogProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['log_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_node_log" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'log_name' is set
        if ('log_name' not in params or
                params['log_name'] is None):
            raise ValueError("Missing the required parameter `log_name` when calling `read_node_log`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'log_name' in params:
            path_params['log-name'] = params['log_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/octet-stream'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/logs/{log-name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeLogProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_node_log_data(self, log_name, **kwargs):  # noqa: E501
        """Read node log contents  # noqa: E501

        For a single specified log file, returns the content of the log file. This method supports byte-range requests. To request just a portion of a log file, supply an HTTP Range header, e.g. \"Range: bytes=<start>-<end>\". <end> is optional, and, if omitted, the file contents from start to the end of the file are returned.'   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_log_data(log_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str log_name: Name of log to read (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_node_log_data_with_http_info(log_name, **kwargs)  # noqa: E501
        else:
            (data) = self.read_node_log_data_with_http_info(log_name, **kwargs)  # noqa: E501
            return data

    def read_node_log_data_with_http_info(self, log_name, **kwargs):  # noqa: E501
        """Read node log contents  # noqa: E501

        For a single specified log file, returns the content of the log file. This method supports byte-range requests. To request just a portion of a log file, supply an HTTP Range header, e.g. \"Range: bytes=<start>-<end>\". <end> is optional, and, if omitted, the file contents from start to the end of the file are returned.'   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_log_data_with_http_info(log_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str log_name: Name of log to read (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['log_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_node_log_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'log_name' is set
        if ('log_name' not in params or
                params['log_name'] is None):
            raise ValueError("Missing the required parameter `log_name` when calling `read_node_log_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'log_name' in params:
            path_params['log-name'] = params['log_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/logs/{log-name}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_port_mirroring_session(self, mirror_session_id, port_mirroring_session, **kwargs):  # noqa: E501
        """Update the mirror session  # noqa: E501

        Update the mirror session  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_port_mirroring_session(mirror_session_id, port_mirroring_session, async=True)
        >>> result = thread.get()

        :param async bool
        :param str mirror_session_id: (required)
        :param PortMirroringSession port_mirroring_session: (required)
        :return: PortMirroringSession
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_port_mirroring_session_with_http_info(mirror_session_id, port_mirroring_session, **kwargs)  # noqa: E501
        else:
            (data) = self.update_port_mirroring_session_with_http_info(mirror_session_id, port_mirroring_session, **kwargs)  # noqa: E501
            return data

    def update_port_mirroring_session_with_http_info(self, mirror_session_id, port_mirroring_session, **kwargs):  # noqa: E501
        """Update the mirror session  # noqa: E501

        Update the mirror session  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_port_mirroring_session_with_http_info(mirror_session_id, port_mirroring_session, async=True)
        >>> result = thread.get()

        :param async bool
        :param str mirror_session_id: (required)
        :param PortMirroringSession port_mirroring_session: (required)
        :return: PortMirroringSession
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mirror_session_id', 'port_mirroring_session']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_port_mirroring_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mirror_session_id' is set
        if ('mirror_session_id' not in params or
                params['mirror_session_id'] is None):
            raise ValueError("Missing the required parameter `mirror_session_id` when calling `update_port_mirroring_session`")  # noqa: E501
        # verify the required parameter 'port_mirroring_session' is set
        if ('port_mirroring_session' not in params or
                params['port_mirroring_session'] is None):
            raise ValueError("Missing the required parameter `port_mirroring_session` when calling `update_port_mirroring_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mirror_session_id' in params:
            path_params['mirror-session-id'] = params['mirror_session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'port_mirroring_session' in params:
            body_params = params['port_mirroring_session']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/mirror-sessions/{mirror-session-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PortMirroringSession',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_switch_ipfix_config(self, ipfix_obs_point_config, **kwargs):  # noqa: E501
        """Update global switch IPFIX export configuration  # noqa: E501

        Update global switch IPFIX export configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_switch_ipfix_config(ipfix_obs_point_config, async=True)
        >>> result = thread.get()

        :param async bool
        :param IpfixObsPointConfig ipfix_obs_point_config: (required)
        :return: IpfixObsPointConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_switch_ipfix_config_with_http_info(ipfix_obs_point_config, **kwargs)  # noqa: E501
        else:
            (data) = self.update_switch_ipfix_config_with_http_info(ipfix_obs_point_config, **kwargs)  # noqa: E501
            return data

    def update_switch_ipfix_config_with_http_info(self, ipfix_obs_point_config, **kwargs):  # noqa: E501
        """Update global switch IPFIX export configuration  # noqa: E501

        Update global switch IPFIX export configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_switch_ipfix_config_with_http_info(ipfix_obs_point_config, async=True)
        >>> result = thread.get()

        :param async bool
        :param IpfixObsPointConfig ipfix_obs_point_config: (required)
        :return: IpfixObsPointConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ipfix_obs_point_config']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_switch_ipfix_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ipfix_obs_point_config' is set
        if ('ipfix_obs_point_config' not in params or
                params['ipfix_obs_point_config'] is None):
            raise ValueError("Missing the required parameter `ipfix_obs_point_config` when calling `update_switch_ipfix_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ipfix_obs_point_config' in params:
            body_params = params['ipfix_obs_point_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ipfix-obs-points/switch-global', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IpfixObsPointConfig',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def verify_port_mirroring_session_verify(self, mirror_session_id, **kwargs):  # noqa: E501
        """Verify whether the mirror session is still valid  # noqa: E501

        Verify whether all participants are on the same transport node  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.verify_port_mirroring_session_verify(mirror_session_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str mirror_session_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.verify_port_mirroring_session_verify_with_http_info(mirror_session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.verify_port_mirroring_session_verify_with_http_info(mirror_session_id, **kwargs)  # noqa: E501
            return data

    def verify_port_mirroring_session_verify_with_http_info(self, mirror_session_id, **kwargs):  # noqa: E501
        """Verify whether the mirror session is still valid  # noqa: E501

        Verify whether all participants are on the same transport node  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.verify_port_mirroring_session_verify_with_http_info(mirror_session_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str mirror_session_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mirror_session_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_port_mirroring_session_verify" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mirror_session_id' is set
        if ('mirror_session_id' not in params or
                params['mirror_session_id'] is None):
            raise ValueError("Missing the required parameter `mirror_session_id` when calling `verify_port_mirroring_session_verify`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mirror_session_id' in params:
            path_params['mirror-session-id'] = params['mirror_session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/mirror-sessions/{mirror-session-id}?action=verify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
