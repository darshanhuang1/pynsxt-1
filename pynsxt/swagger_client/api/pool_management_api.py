# coding: utf-8

"""
    NSX API

    VMware NSX REST API  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class PoolManagementApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def allocate_or_release_from_ip_block_subnet(self, subnet_id, allocation_ip_address, action, **kwargs):  # noqa: E501
        """Allocate or Release an IP Address from a Ip Subnet  # noqa: E501

        Allocates or releases an IP address from the specified IP subnet. To allocate an address, include ?action=ALLOCATE in the request and a \"{}\" in the request body. When the request is successful, the response is \"allocation_id\": \"<ip-address>\", where <ip-address> is an IP address from the specified pool. To release an IP address (return it back to the pool), include ?action=RELEASE in the request and \"allocation_id\":<ip-address> in the request body, where <ip-address> is the address to be released. When the request is successful, the response is NULL.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.allocate_or_release_from_ip_block_subnet(subnet_id, allocation_ip_address, action, async=True)
        >>> result = thread.get()

        :param async bool
        :param str subnet_id: IP subnet id (required)
        :param AllocationIpAddress allocation_ip_address: (required)
        :param str action: Specifies allocate or release action (required)
        :return: AllocationIpAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.allocate_or_release_from_ip_block_subnet_with_http_info(subnet_id, allocation_ip_address, action, **kwargs)  # noqa: E501
        else:
            (data) = self.allocate_or_release_from_ip_block_subnet_with_http_info(subnet_id, allocation_ip_address, action, **kwargs)  # noqa: E501
            return data

    def allocate_or_release_from_ip_block_subnet_with_http_info(self, subnet_id, allocation_ip_address, action, **kwargs):  # noqa: E501
        """Allocate or Release an IP Address from a Ip Subnet  # noqa: E501

        Allocates or releases an IP address from the specified IP subnet. To allocate an address, include ?action=ALLOCATE in the request and a \"{}\" in the request body. When the request is successful, the response is \"allocation_id\": \"<ip-address>\", where <ip-address> is an IP address from the specified pool. To release an IP address (return it back to the pool), include ?action=RELEASE in the request and \"allocation_id\":<ip-address> in the request body, where <ip-address> is the address to be released. When the request is successful, the response is NULL.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.allocate_or_release_from_ip_block_subnet_with_http_info(subnet_id, allocation_ip_address, action, async=True)
        >>> result = thread.get()

        :param async bool
        :param str subnet_id: IP subnet id (required)
        :param AllocationIpAddress allocation_ip_address: (required)
        :param str action: Specifies allocate or release action (required)
        :return: AllocationIpAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subnet_id', 'allocation_ip_address', 'action']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method allocate_or_release_from_ip_block_subnet" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subnet_id' is set
        if ('subnet_id' not in params or
                params['subnet_id'] is None):
            raise ValueError("Missing the required parameter `subnet_id` when calling `allocate_or_release_from_ip_block_subnet`")  # noqa: E501
        # verify the required parameter 'allocation_ip_address' is set
        if ('allocation_ip_address' not in params or
                params['allocation_ip_address'] is None):
            raise ValueError("Missing the required parameter `allocation_ip_address` when calling `allocate_or_release_from_ip_block_subnet`")  # noqa: E501
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `allocate_or_release_from_ip_block_subnet`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subnet_id' in params:
            path_params['subnet-id'] = params['subnet_id']  # noqa: E501

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'allocation_ip_address' in params:
            body_params = params['allocation_ip_address']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/ip-subnets/{subnet-id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AllocationIpAddress',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def allocate_or_release_from_ip_pool(self, pool_id, allocation_ip_address, action, **kwargs):  # noqa: E501
        """Allocate or Release an IP Address from a Pool  # noqa: E501

        Allocates or releases an IP address from the specified IP pool. To allocate an address, include ?action=ALLOCATE in the request and \"allocation_id\":null in the request body. When the request is successful, the response is \"allocation_id\": \"<ip-address>\", where <ip-address> is an IP address from the specified pool. To release an IP address (return it back to the pool), include ?action=RELEASE in the request and \"allocation_id\":<ip-address> in the request body, where <ip-address> is the address to be released. When the request is successful, the response is NULL. Tags, display_name and description attributes are not supported for AllocationIpAddress in this release.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.allocate_or_release_from_ip_pool(pool_id, allocation_ip_address, action, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: IP pool ID (required)
        :param AllocationIpAddress allocation_ip_address: (required)
        :param str action: Specifies allocate or release action (required)
        :return: AllocationIpAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.allocate_or_release_from_ip_pool_with_http_info(pool_id, allocation_ip_address, action, **kwargs)  # noqa: E501
        else:
            (data) = self.allocate_or_release_from_ip_pool_with_http_info(pool_id, allocation_ip_address, action, **kwargs)  # noqa: E501
            return data

    def allocate_or_release_from_ip_pool_with_http_info(self, pool_id, allocation_ip_address, action, **kwargs):  # noqa: E501
        """Allocate or Release an IP Address from a Pool  # noqa: E501

        Allocates or releases an IP address from the specified IP pool. To allocate an address, include ?action=ALLOCATE in the request and \"allocation_id\":null in the request body. When the request is successful, the response is \"allocation_id\": \"<ip-address>\", where <ip-address> is an IP address from the specified pool. To release an IP address (return it back to the pool), include ?action=RELEASE in the request and \"allocation_id\":<ip-address> in the request body, where <ip-address> is the address to be released. When the request is successful, the response is NULL. Tags, display_name and description attributes are not supported for AllocationIpAddress in this release.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.allocate_or_release_from_ip_pool_with_http_info(pool_id, allocation_ip_address, action, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: IP pool ID (required)
        :param AllocationIpAddress allocation_ip_address: (required)
        :param str action: Specifies allocate or release action (required)
        :return: AllocationIpAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pool_id', 'allocation_ip_address', 'action']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method allocate_or_release_from_ip_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `allocate_or_release_from_ip_pool`")  # noqa: E501
        # verify the required parameter 'allocation_ip_address' is set
        if ('allocation_ip_address' not in params or
                params['allocation_ip_address'] is None):
            raise ValueError("Missing the required parameter `allocation_ip_address` when calling `allocate_or_release_from_ip_pool`")  # noqa: E501
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `allocate_or_release_from_ip_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'allocation_ip_address' in params:
            body_params = params['allocation_ip_address']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/ip-pools/{pool-id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AllocationIpAddress',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ip_block(self, ip_block, **kwargs):  # noqa: E501
        """Create a new IP address block.  # noqa: E501

        Creates a new IPv4 address block using the specified cidr. cidr is a required parameter. display_name & description are optional parameters   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ip_block(ip_block, async=True)
        >>> result = thread.get()

        :param async bool
        :param IpBlock ip_block: (required)
        :return: IpBlock
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_ip_block_with_http_info(ip_block, **kwargs)  # noqa: E501
        else:
            (data) = self.create_ip_block_with_http_info(ip_block, **kwargs)  # noqa: E501
            return data

    def create_ip_block_with_http_info(self, ip_block, **kwargs):  # noqa: E501
        """Create a new IP address block.  # noqa: E501

        Creates a new IPv4 address block using the specified cidr. cidr is a required parameter. display_name & description are optional parameters   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ip_block_with_http_info(ip_block, async=True)
        >>> result = thread.get()

        :param async bool
        :param IpBlock ip_block: (required)
        :return: IpBlock
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ip_block']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ip_block" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ip_block' is set
        if ('ip_block' not in params or
                params['ip_block'] is None):
            raise ValueError("Missing the required parameter `ip_block` when calling `create_ip_block`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ip_block' in params:
            body_params = params['ip_block']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/ip-blocks', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IpBlock',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ip_block_subnet(self, ip_block_subnet, **kwargs):  # noqa: E501
        """Create subnet of specified size within an IP block  # noqa: E501

        Carves out a subnet of requested size from the specified IP block. The \"size\" parameter  and the \"block_id \" are the requireds field while invoking this API. If the IP block has sufficient resources/space to allocate a subnet of specified size, the response will contain all the details of the newly created subnet including the display_name, description, cidr & allocation_ranges. Returns a conflict error if the IP block does not have enough resources/space to allocate a subnet of the requested size.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ip_block_subnet(ip_block_subnet, async=True)
        >>> result = thread.get()

        :param async bool
        :param IpBlockSubnet ip_block_subnet: (required)
        :return: IpBlockSubnet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_ip_block_subnet_with_http_info(ip_block_subnet, **kwargs)  # noqa: E501
        else:
            (data) = self.create_ip_block_subnet_with_http_info(ip_block_subnet, **kwargs)  # noqa: E501
            return data

    def create_ip_block_subnet_with_http_info(self, ip_block_subnet, **kwargs):  # noqa: E501
        """Create subnet of specified size within an IP block  # noqa: E501

        Carves out a subnet of requested size from the specified IP block. The \"size\" parameter  and the \"block_id \" are the requireds field while invoking this API. If the IP block has sufficient resources/space to allocate a subnet of specified size, the response will contain all the details of the newly created subnet including the display_name, description, cidr & allocation_ranges. Returns a conflict error if the IP block does not have enough resources/space to allocate a subnet of the requested size.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ip_block_subnet_with_http_info(ip_block_subnet, async=True)
        >>> result = thread.get()

        :param async bool
        :param IpBlockSubnet ip_block_subnet: (required)
        :return: IpBlockSubnet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ip_block_subnet']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ip_block_subnet" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ip_block_subnet' is set
        if ('ip_block_subnet' not in params or
                params['ip_block_subnet'] is None):
            raise ValueError("Missing the required parameter `ip_block_subnet` when calling `create_ip_block_subnet`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ip_block_subnet' in params:
            body_params = params['ip_block_subnet']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/ip-subnets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IpBlockSubnet',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ip_pool(self, ip_pool, **kwargs):  # noqa: E501
        """Create an IP Pool  # noqa: E501

        Creates a new IPv4 or IPv6 address pool. Required parameters are allocation_ranges and cidr. Optional parameters are display_name, description, dns_nameservers, dns_suffix, and gateway_ip.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ip_pool(ip_pool, async=True)
        >>> result = thread.get()

        :param async bool
        :param IpPool ip_pool: (required)
        :return: IpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_ip_pool_with_http_info(ip_pool, **kwargs)  # noqa: E501
        else:
            (data) = self.create_ip_pool_with_http_info(ip_pool, **kwargs)  # noqa: E501
            return data

    def create_ip_pool_with_http_info(self, ip_pool, **kwargs):  # noqa: E501
        """Create an IP Pool  # noqa: E501

        Creates a new IPv4 or IPv6 address pool. Required parameters are allocation_ranges and cidr. Optional parameters are display_name, description, dns_nameservers, dns_suffix, and gateway_ip.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ip_pool_with_http_info(ip_pool, async=True)
        >>> result = thread.get()

        :param async bool
        :param IpPool ip_pool: (required)
        :return: IpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ip_pool']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ip_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ip_pool' is set
        if ('ip_pool' not in params or
                params['ip_pool'] is None):
            raise ValueError("Missing the required parameter `ip_pool` when calling `create_ip_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ip_pool' in params:
            body_params = params['ip_pool']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/ip-pools', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IpPool',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ip_block(self, block_id, **kwargs):  # noqa: E501
        """Delete an IP Address Block  # noqa: E501

        Deletes the IP address block with specified id if it exists. IP block cannot be deleted if there are allocated subnets from the block.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_ip_block(block_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str block_id: IP address block id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_ip_block_with_http_info(block_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ip_block_with_http_info(block_id, **kwargs)  # noqa: E501
            return data

    def delete_ip_block_with_http_info(self, block_id, **kwargs):  # noqa: E501
        """Delete an IP Address Block  # noqa: E501

        Deletes the IP address block with specified id if it exists. IP block cannot be deleted if there are allocated subnets from the block.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_ip_block_with_http_info(block_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str block_id: IP address block id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['block_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ip_block" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'block_id' is set
        if ('block_id' not in params or
                params['block_id'] is None):
            raise ValueError("Missing the required parameter `block_id` when calling `delete_ip_block`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'block_id' in params:
            path_params['block-id'] = params['block_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/ip-blocks/{block-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ip_block_subnet(self, subnet_id, **kwargs):  # noqa: E501
        """Delete subnet within an IP block  # noqa: E501

        Deletes a subnet with specified id within a given IP address block. Deletion is allowed only when there are no allocated IP addresses from that subnet.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_ip_block_subnet(subnet_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str subnet_id: Subnet id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_ip_block_subnet_with_http_info(subnet_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ip_block_subnet_with_http_info(subnet_id, **kwargs)  # noqa: E501
            return data

    def delete_ip_block_subnet_with_http_info(self, subnet_id, **kwargs):  # noqa: E501
        """Delete subnet within an IP block  # noqa: E501

        Deletes a subnet with specified id within a given IP address block. Deletion is allowed only when there are no allocated IP addresses from that subnet.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_ip_block_subnet_with_http_info(subnet_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str subnet_id: Subnet id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subnet_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ip_block_subnet" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subnet_id' is set
        if ('subnet_id' not in params or
                params['subnet_id'] is None):
            raise ValueError("Missing the required parameter `subnet_id` when calling `delete_ip_block_subnet`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subnet_id' in params:
            path_params['subnet-id'] = params['subnet_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/ip-subnets/{subnet-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ip_pool(self, pool_id, **kwargs):  # noqa: E501
        """Delete an IP Pool  # noqa: E501

        Deletes the specified IP address pool. By default, if the IpPool is used in other configurations (such as transport node template), it won't be deleted. In such situations, pass \"force=true\" as query param to force delete the IpPool  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_ip_pool(pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: IP pool ID (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_ip_pool_with_http_info(pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ip_pool_with_http_info(pool_id, **kwargs)  # noqa: E501
            return data

    def delete_ip_pool_with_http_info(self, pool_id, **kwargs):  # noqa: E501
        """Delete an IP Pool  # noqa: E501

        Deletes the specified IP address pool. By default, if the IpPool is used in other configurations (such as transport node template), it won't be deleted. In such situations, pass \"force=true\" as query param to force delete the IpPool  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_ip_pool_with_http_info(pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: IP pool ID (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pool_id', 'force']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ip_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `delete_ip_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/ip-pools/{pool-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_ip_block_subnets(self, **kwargs):  # noqa: E501
        """List subnets within an IP block  # noqa: E501

        Returns information about all subnets present within an IP address block. Information includes subnet's id, display_name, description, cidr and allocation ranges.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ip_block_subnets(async=True)
        >>> result = thread.get()

        :param async bool
        :param str block_id:
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: IpBlockSubnetListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_ip_block_subnets_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_ip_block_subnets_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_ip_block_subnets_with_http_info(self, **kwargs):  # noqa: E501
        """List subnets within an IP block  # noqa: E501

        Returns information about all subnets present within an IP address block. Information includes subnet's id, display_name, description, cidr and allocation ranges.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ip_block_subnets_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str block_id:
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: IpBlockSubnetListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['block_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_ip_block_subnets" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ip_block_subnets`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ip_block_subnets`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'block_id' in params:
            query_params.append(('block_id', params['block_id']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/ip-subnets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IpBlockSubnetListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_ip_blocks(self, **kwargs):  # noqa: E501
        """Returns list of configured IP address blocks.  # noqa: E501

        Returns information about configured IP address blocks. Information includes the id, display name, description & CIDR of IP address blocks   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ip_blocks(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: IpBlockListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_ip_blocks_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_ip_blocks_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_ip_blocks_with_http_info(self, **kwargs):  # noqa: E501
        """Returns list of configured IP address blocks.  # noqa: E501

        Returns information about configured IP address blocks. Information includes the id, display name, description & CIDR of IP address blocks   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ip_blocks_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: IpBlockListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_ip_blocks" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ip_blocks`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ip_blocks`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/ip-blocks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IpBlockListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_ip_pool_allocations(self, pool_id, **kwargs):  # noqa: E501
        """List IP Pool Allocations  # noqa: E501

        Returns information about which addresses have been allocated from a specified IP address pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ip_pool_allocations(pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: IP pool ID (required)
        :return: AllocationIpAddressListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_ip_pool_allocations_with_http_info(pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_ip_pool_allocations_with_http_info(pool_id, **kwargs)  # noqa: E501
            return data

    def list_ip_pool_allocations_with_http_info(self, pool_id, **kwargs):  # noqa: E501
        """List IP Pool Allocations  # noqa: E501

        Returns information about which addresses have been allocated from a specified IP address pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ip_pool_allocations_with_http_info(pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: IP pool ID (required)
        :return: AllocationIpAddressListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pool_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_ip_pool_allocations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `list_ip_pool_allocations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/ip-pools/{pool-id}/allocations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AllocationIpAddressListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_ip_pools(self, **kwargs):  # noqa: E501
        """List IP Pools  # noqa: E501

        Returns information about the configured IP address pools. Information includes the display name and description of the pool and the details of each of the subnets in the pool, including the DNS servers, allocation ranges, gateway, and CIDR subnet address.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ip_pools(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: IpPoolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_ip_pools_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_ip_pools_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_ip_pools_with_http_info(self, **kwargs):  # noqa: E501
        """List IP Pools  # noqa: E501

        Returns information about the configured IP address pools. Information includes the display name and description of the pool and the details of each of the subnets in the pool, including the DNS servers, allocation ranges, gateway, and CIDR subnet address.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ip_pools_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: IpPoolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_ip_pools" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ip_pools`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ip_pools`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/ip-pools', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IpPoolListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_mac_pools(self, **kwargs):  # noqa: E501
        """List MAC Pools  # noqa: E501

        Returns a list of all the MAC pools   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_mac_pools(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: MacPoolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_mac_pools_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_mac_pools_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_mac_pools_with_http_info(self, **kwargs):  # noqa: E501
        """List MAC Pools  # noqa: E501

        Returns a list of all the MAC pools   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_mac_pools_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: MacPoolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_mac_pools" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_mac_pools`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_mac_pools`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/mac-pools', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MacPoolListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_vni_pools(self, **kwargs):  # noqa: E501
        """List VNI Pools  # noqa: E501

        Returns information about the default and configured virtual network identifier (VNI) pools for use when building logical network segments. Each virtual network has a unique ID called a VNI. Instead of creating a new VNI each time you need a new logical switch, you can instead allocate a VNI from a VNI pool. VNI pools are sometimes called segment ID pools. Each VNI pool has a range of usable VNIs. By default, there is one pool with the range 5000 through 65535. To create multiple smaller pools, specify a smaller range for each pool, such as 5000-5200 and 5201-5400. The VNI range determines the maximum number of logical switches that can be created in each network segment.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_vni_pools(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: VniPoolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_vni_pools_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_vni_pools_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_vni_pools_with_http_info(self, **kwargs):  # noqa: E501
        """List VNI Pools  # noqa: E501

        Returns information about the default and configured virtual network identifier (VNI) pools for use when building logical network segments. Each virtual network has a unique ID called a VNI. Instead of creating a new VNI each time you need a new logical switch, you can instead allocate a VNI from a VNI pool. VNI pools are sometimes called segment ID pools. Each VNI pool has a range of usable VNIs. By default, there is one pool with the range 5000 through 65535. To create multiple smaller pools, specify a smaller range for each pool, such as 5000-5200 and 5201-5400. The VNI range determines the maximum number of logical switches that can be created in each network segment.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_vni_pools_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: VniPoolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_vni_pools" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_vni_pools`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_vni_pools`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/vni-pools', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VniPoolListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_vtep_label_pools(self, **kwargs):  # noqa: E501
        """List virtual tunnel endpoint Label Pools  # noqa: E501

        Returns a list of all virtual tunnel endpoint label pools   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_vtep_label_pools(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: VtepLabelPoolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_vtep_label_pools_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_vtep_label_pools_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_vtep_label_pools_with_http_info(self, **kwargs):  # noqa: E501
        """List virtual tunnel endpoint Label Pools  # noqa: E501

        Returns a list of all virtual tunnel endpoint label pools   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_vtep_label_pools_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: VtepLabelPoolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_vtep_label_pools" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_vtep_label_pools`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_vtep_label_pools`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/vtep-label-pools', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VtepLabelPoolListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_ip_block(self, block_id, **kwargs):  # noqa: E501
        """Get IP address block information.  # noqa: E501

        Returns information about the IP address block with specified id. Information includes id, display_name, description & cidr.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ip_block(block_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str block_id: IP address block id (required)
        :return: IpBlock
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_ip_block_with_http_info(block_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_ip_block_with_http_info(block_id, **kwargs)  # noqa: E501
            return data

    def read_ip_block_with_http_info(self, block_id, **kwargs):  # noqa: E501
        """Get IP address block information.  # noqa: E501

        Returns information about the IP address block with specified id. Information includes id, display_name, description & cidr.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ip_block_with_http_info(block_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str block_id: IP address block id (required)
        :return: IpBlock
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['block_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_ip_block" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'block_id' is set
        if ('block_id' not in params or
                params['block_id'] is None):
            raise ValueError("Missing the required parameter `block_id` when calling `read_ip_block`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'block_id' in params:
            path_params['block-id'] = params['block_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/ip-blocks/{block-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IpBlock',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_ip_block_subnet(self, subnet_id, **kwargs):  # noqa: E501
        """Get the subnet within an IP block  # noqa: E501

        Returns information about the subnet with specified id within a given IP address block. Information includes display_name, description, cidr and allocation_ranges.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ip_block_subnet(subnet_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str subnet_id: Subnet id (required)
        :return: IpBlockSubnet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_ip_block_subnet_with_http_info(subnet_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_ip_block_subnet_with_http_info(subnet_id, **kwargs)  # noqa: E501
            return data

    def read_ip_block_subnet_with_http_info(self, subnet_id, **kwargs):  # noqa: E501
        """Get the subnet within an IP block  # noqa: E501

        Returns information about the subnet with specified id within a given IP address block. Information includes display_name, description, cidr and allocation_ranges.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ip_block_subnet_with_http_info(subnet_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str subnet_id: Subnet id (required)
        :return: IpBlockSubnet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subnet_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_ip_block_subnet" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subnet_id' is set
        if ('subnet_id' not in params or
                params['subnet_id'] is None):
            raise ValueError("Missing the required parameter `subnet_id` when calling `read_ip_block_subnet`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'subnet_id' in params:
            path_params['subnet-id'] = params['subnet_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/ip-subnets/{subnet-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IpBlockSubnet',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_ip_pool(self, pool_id, **kwargs):  # noqa: E501
        """Read IP Pool  # noqa: E501

        Returns information about the specified IP address pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ip_pool(pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: IP pool ID (required)
        :return: IpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_ip_pool_with_http_info(pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_ip_pool_with_http_info(pool_id, **kwargs)  # noqa: E501
            return data

    def read_ip_pool_with_http_info(self, pool_id, **kwargs):  # noqa: E501
        """Read IP Pool  # noqa: E501

        Returns information about the specified IP address pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ip_pool_with_http_info(pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: IP pool ID (required)
        :return: IpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pool_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_ip_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `read_ip_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/ip-pools/{pool-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IpPool',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_mac_pool(self, pool_id, **kwargs):  # noqa: E501
        """Read MAC Pool  # noqa: E501

        Returns information about the specified MAC pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_mac_pool(pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: MAC pool ID (required)
        :return: MacPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_mac_pool_with_http_info(pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_mac_pool_with_http_info(pool_id, **kwargs)  # noqa: E501
            return data

    def read_mac_pool_with_http_info(self, pool_id, **kwargs):  # noqa: E501
        """Read MAC Pool  # noqa: E501

        Returns information about the specified MAC pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_mac_pool_with_http_info(pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: MAC pool ID (required)
        :return: MacPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pool_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_mac_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `read_mac_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/mac-pools/{pool-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MacPool',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_vni_pool(self, pool_id, **kwargs):  # noqa: E501
        """Read VNI Pool  # noqa: E501

        Returns information about the specified virtual network identifier (VNI) pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_vni_pool(pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: VNI pool ID (required)
        :return: VniPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_vni_pool_with_http_info(pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_vni_pool_with_http_info(pool_id, **kwargs)  # noqa: E501
            return data

    def read_vni_pool_with_http_info(self, pool_id, **kwargs):  # noqa: E501
        """Read VNI Pool  # noqa: E501

        Returns information about the specified virtual network identifier (VNI) pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_vni_pool_with_http_info(pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: VNI pool ID (required)
        :return: VniPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pool_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_vni_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `read_vni_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/vni-pools/{pool-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VniPool',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_vtep_label_pool(self, pool_id, **kwargs):  # noqa: E501
        """Read a virtual tunnel endpoint label pool  # noqa: E501

        Returns information about the specified virtual tunnel endpoint label pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_vtep_label_pool(pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: Virtual tunnel endpoint label pool ID (required)
        :return: VtepLabelPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_vtep_label_pool_with_http_info(pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_vtep_label_pool_with_http_info(pool_id, **kwargs)  # noqa: E501
            return data

    def read_vtep_label_pool_with_http_info(self, pool_id, **kwargs):  # noqa: E501
        """Read a virtual tunnel endpoint label pool  # noqa: E501

        Returns information about the specified virtual tunnel endpoint label pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_vtep_label_pool_with_http_info(pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: Virtual tunnel endpoint label pool ID (required)
        :return: VtepLabelPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pool_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_vtep_label_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `read_vtep_label_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/vtep-label-pools/{pool-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VtepLabelPool',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ip_block(self, block_id, ip_block, **kwargs):  # noqa: E501
        """Update an IP Address Block  # noqa: E501

        Modifies the IP address block with specifed id. display_name, description and cidr are parameters that can be modified. If a new cidr is specified, it should contain all existing subnets in the IP block. Returns a conflict error if the IP address block cidr can not be modified due to the presence of subnets that it contains. Eg: If the IP block contains a subnet 192.168.0.1/24 and we try to change the IP block cidr to 10.1.0.1/16, it results in a conflict.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_ip_block(block_id, ip_block, async=True)
        >>> result = thread.get()

        :param async bool
        :param str block_id: IP address block id (required)
        :param IpBlock ip_block: (required)
        :return: IpBlock
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_ip_block_with_http_info(block_id, ip_block, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ip_block_with_http_info(block_id, ip_block, **kwargs)  # noqa: E501
            return data

    def update_ip_block_with_http_info(self, block_id, ip_block, **kwargs):  # noqa: E501
        """Update an IP Address Block  # noqa: E501

        Modifies the IP address block with specifed id. display_name, description and cidr are parameters that can be modified. If a new cidr is specified, it should contain all existing subnets in the IP block. Returns a conflict error if the IP address block cidr can not be modified due to the presence of subnets that it contains. Eg: If the IP block contains a subnet 192.168.0.1/24 and we try to change the IP block cidr to 10.1.0.1/16, it results in a conflict.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_ip_block_with_http_info(block_id, ip_block, async=True)
        >>> result = thread.get()

        :param async bool
        :param str block_id: IP address block id (required)
        :param IpBlock ip_block: (required)
        :return: IpBlock
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['block_id', 'ip_block']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ip_block" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'block_id' is set
        if ('block_id' not in params or
                params['block_id'] is None):
            raise ValueError("Missing the required parameter `block_id` when calling `update_ip_block`")  # noqa: E501
        # verify the required parameter 'ip_block' is set
        if ('ip_block' not in params or
                params['ip_block'] is None):
            raise ValueError("Missing the required parameter `ip_block` when calling `update_ip_block`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'block_id' in params:
            path_params['block-id'] = params['block_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ip_block' in params:
            body_params = params['ip_block']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/ip-blocks/{block-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IpBlock',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ip_pool(self, pool_id, ip_pool, **kwargs):  # noqa: E501
        """Update an IP Pool  # noqa: E501

        Modifies the specified IP address pool. Modifiable parameters include the description, display_name, and all subnet information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_ip_pool(pool_id, ip_pool, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: IP pool ID (required)
        :param IpPool ip_pool: (required)
        :return: IpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_ip_pool_with_http_info(pool_id, ip_pool, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ip_pool_with_http_info(pool_id, ip_pool, **kwargs)  # noqa: E501
            return data

    def update_ip_pool_with_http_info(self, pool_id, ip_pool, **kwargs):  # noqa: E501
        """Update an IP Pool  # noqa: E501

        Modifies the specified IP address pool. Modifiable parameters include the description, display_name, and all subnet information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_ip_pool_with_http_info(pool_id, ip_pool, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: IP pool ID (required)
        :param IpPool ip_pool: (required)
        :return: IpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pool_id', 'ip_pool']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ip_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `update_ip_pool`")  # noqa: E501
        # verify the required parameter 'ip_pool' is set
        if ('ip_pool' not in params or
                params['ip_pool'] is None):
            raise ValueError("Missing the required parameter `ip_pool` when calling `update_ip_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ip_pool' in params:
            body_params = params['ip_pool']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/ip-pools/{pool-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IpPool',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_vni_pool(self, pool_id, vni_pool, **kwargs):  # noqa: E501
        """Update a VNI Pool  # noqa: E501

        Updates the specified VNI pool. Modifiable parameters include description, display_name and ranges. Ranges can be added, modified or deleted. Overlapping ranges are not allowed. Only range end can be modified for any existing range. Range shrinking or deletion is not allowed if there are any allocated VNIs.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vni_pool(pool_id, vni_pool, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: VNI pool ID (required)
        :param VniPool vni_pool: (required)
        :return: VniPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_vni_pool_with_http_info(pool_id, vni_pool, **kwargs)  # noqa: E501
        else:
            (data) = self.update_vni_pool_with_http_info(pool_id, vni_pool, **kwargs)  # noqa: E501
            return data

    def update_vni_pool_with_http_info(self, pool_id, vni_pool, **kwargs):  # noqa: E501
        """Update a VNI Pool  # noqa: E501

        Updates the specified VNI pool. Modifiable parameters include description, display_name and ranges. Ranges can be added, modified or deleted. Overlapping ranges are not allowed. Only range end can be modified for any existing range. Range shrinking or deletion is not allowed if there are any allocated VNIs.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vni_pool_with_http_info(pool_id, vni_pool, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: VNI pool ID (required)
        :param VniPool vni_pool: (required)
        :return: VniPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pool_id', 'vni_pool']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_vni_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `update_vni_pool`")  # noqa: E501
        # verify the required parameter 'vni_pool' is set
        if ('vni_pool' not in params or
                params['vni_pool'] is None):
            raise ValueError("Missing the required parameter `vni_pool` when calling `update_vni_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'vni_pool' in params:
            body_params = params['vni_pool']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/pools/vni-pools/{pool-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VniPool',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
