# coding: utf-8

"""
    NSX API

    VMware NSX REST API  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class LogicalRoutingAndServicesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_bgp_neighbor(self, logical_router_id, bgp_neighbor, **kwargs):  # noqa: E501
        """Add a new BGP Neighbor on a Logical Router  # noqa: E501

        Add a new BGP Neighbor on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_bgp_neighbor(logical_router_id, bgp_neighbor, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param BgpNeighbor bgp_neighbor: (required)
        :return: BgpNeighbor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_bgp_neighbor_with_http_info(logical_router_id, bgp_neighbor, **kwargs)  # noqa: E501
        else:
            (data) = self.add_bgp_neighbor_with_http_info(logical_router_id, bgp_neighbor, **kwargs)  # noqa: E501
            return data

    def add_bgp_neighbor_with_http_info(self, logical_router_id, bgp_neighbor, **kwargs):  # noqa: E501
        """Add a new BGP Neighbor on a Logical Router  # noqa: E501

        Add a new BGP Neighbor on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_bgp_neighbor_with_http_info(logical_router_id, bgp_neighbor, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param BgpNeighbor bgp_neighbor: (required)
        :return: BgpNeighbor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'bgp_neighbor']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_bgp_neighbor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `add_bgp_neighbor`")  # noqa: E501
        # verify the required parameter 'bgp_neighbor' is set
        if ('bgp_neighbor' not in params or
                params['bgp_neighbor'] is None):
            raise ValueError("Missing the required parameter `bgp_neighbor` when calling `add_bgp_neighbor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bgp_neighbor' in params:
            body_params = params['bgp_neighbor']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/neighbors', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpNeighbor',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_ip_prefix_list(self, logical_router_id, ip_prefix_list, **kwargs):  # noqa: E501
        """Add IPPrefixList on a Logical Router  # noqa: E501

        Adds a new IPPrefixList on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_ip_prefix_list(logical_router_id, ip_prefix_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param IPPrefixList ip_prefix_list: (required)
        :return: IPPrefixList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_ip_prefix_list_with_http_info(logical_router_id, ip_prefix_list, **kwargs)  # noqa: E501
        else:
            (data) = self.add_ip_prefix_list_with_http_info(logical_router_id, ip_prefix_list, **kwargs)  # noqa: E501
            return data

    def add_ip_prefix_list_with_http_info(self, logical_router_id, ip_prefix_list, **kwargs):  # noqa: E501
        """Add IPPrefixList on a Logical Router  # noqa: E501

        Adds a new IPPrefixList on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_ip_prefix_list_with_http_info(logical_router_id, ip_prefix_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param IPPrefixList ip_prefix_list: (required)
        :return: IPPrefixList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'ip_prefix_list']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_ip_prefix_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `add_ip_prefix_list`")  # noqa: E501
        # verify the required parameter 'ip_prefix_list' is set
        if ('ip_prefix_list' not in params or
                params['ip_prefix_list'] is None):
            raise ValueError("Missing the required parameter `ip_prefix_list` when calling `add_ip_prefix_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ip_prefix_list' in params:
            body_params = params['ip_prefix_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/ip-prefix-lists', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IPPrefixList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_nat_rule(self, logical_router_id, nat_rule, **kwargs):  # noqa: E501
        """Add a NAT rule in a specific logical router  # noqa: E501

        Add a NAT rule in a specific logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_nat_rule(logical_router_id, nat_rule, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param NatRule nat_rule: (required)
        :return: NatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_nat_rule_with_http_info(logical_router_id, nat_rule, **kwargs)  # noqa: E501
        else:
            (data) = self.add_nat_rule_with_http_info(logical_router_id, nat_rule, **kwargs)  # noqa: E501
            return data

    def add_nat_rule_with_http_info(self, logical_router_id, nat_rule, **kwargs):  # noqa: E501
        """Add a NAT rule in a specific logical router  # noqa: E501

        Add a NAT rule in a specific logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_nat_rule_with_http_info(logical_router_id, nat_rule, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param NatRule nat_rule: (required)
        :return: NatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'nat_rule']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_nat_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `add_nat_rule`")  # noqa: E501
        # verify the required parameter 'nat_rule' is set
        if ('nat_rule' not in params or
                params['nat_rule'] is None):
            raise ValueError("Missing the required parameter `nat_rule` when calling `add_nat_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'nat_rule' in params:
            body_params = params['nat_rule']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/nat/rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NatRule',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_route_map(self, logical_router_id, route_map, **kwargs):  # noqa: E501
        """Add RouteMap on a Logical Router  # noqa: E501

        Adds a new RouteMap on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_route_map(logical_router_id, route_map, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param RouteMap route_map: (required)
        :return: RouteMap
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_route_map_with_http_info(logical_router_id, route_map, **kwargs)  # noqa: E501
        else:
            (data) = self.add_route_map_with_http_info(logical_router_id, route_map, **kwargs)  # noqa: E501
            return data

    def add_route_map_with_http_info(self, logical_router_id, route_map, **kwargs):  # noqa: E501
        """Add RouteMap on a Logical Router  # noqa: E501

        Adds a new RouteMap on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_route_map_with_http_info(logical_router_id, route_map, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param RouteMap route_map: (required)
        :return: RouteMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'route_map']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_route_map" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `add_route_map`")  # noqa: E501
        # verify the required parameter 'route_map' is set
        if ('route_map' not in params or
                params['route_map'] is None):
            raise ValueError("Missing the required parameter `route_map` when calling `add_route_map`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'route_map' in params:
            body_params = params['route_map']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/route-maps', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RouteMap',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_static_route(self, logical_router_id, static_route, **kwargs):  # noqa: E501
        """Add Static Routes on a Logical Router  # noqa: E501

        Adds a new static route on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_static_route(logical_router_id, static_route, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param StaticRoute static_route: (required)
        :return: StaticRoute
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_static_route_with_http_info(logical_router_id, static_route, **kwargs)  # noqa: E501
        else:
            (data) = self.add_static_route_with_http_info(logical_router_id, static_route, **kwargs)  # noqa: E501
            return data

    def add_static_route_with_http_info(self, logical_router_id, static_route, **kwargs):  # noqa: E501
        """Add Static Routes on a Logical Router  # noqa: E501

        Adds a new static route on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_static_route_with_http_info(logical_router_id, static_route, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param StaticRoute static_route: (required)
        :return: StaticRoute
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'static_route']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_static_route" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `add_static_route`")  # noqa: E501
        # verify the required parameter 'static_route' is set
        if ('static_route' not in params or
                params['static_route'] is None):
            raise ValueError("Missing the required parameter `static_route` when calling `add_static_route`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'static_route' in params:
            body_params = params['static_route']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/static-routes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StaticRoute',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_dhcp_relay(self, dhcp_relay_service, **kwargs):  # noqa: E501
        """Create a DHCP Relay Service  # noqa: E501

        Creates a dhcp relay service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_dhcp_relay(dhcp_relay_service, async=True)
        >>> result = thread.get()

        :param async bool
        :param DhcpRelayService dhcp_relay_service: (required)
        :return: DhcpRelayService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_dhcp_relay_with_http_info(dhcp_relay_service, **kwargs)  # noqa: E501
        else:
            (data) = self.create_dhcp_relay_with_http_info(dhcp_relay_service, **kwargs)  # noqa: E501
            return data

    def create_dhcp_relay_with_http_info(self, dhcp_relay_service, **kwargs):  # noqa: E501
        """Create a DHCP Relay Service  # noqa: E501

        Creates a dhcp relay service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_dhcp_relay_with_http_info(dhcp_relay_service, async=True)
        >>> result = thread.get()

        :param async bool
        :param DhcpRelayService dhcp_relay_service: (required)
        :return: DhcpRelayService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dhcp_relay_service']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dhcp_relay" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dhcp_relay_service' is set
        if ('dhcp_relay_service' not in params or
                params['dhcp_relay_service'] is None):
            raise ValueError("Missing the required parameter `dhcp_relay_service` when calling `create_dhcp_relay`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dhcp_relay_service' in params:
            body_params = params['dhcp_relay_service']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/relays', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpRelayService',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_dhcp_relay_profile(self, dhcp_relay_profile, **kwargs):  # noqa: E501
        """Create a DHCP Relay Profile  # noqa: E501

        Creates a dhcp relay profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_dhcp_relay_profile(dhcp_relay_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param DhcpRelayProfile dhcp_relay_profile: (required)
        :return: DhcpRelayProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_dhcp_relay_profile_with_http_info(dhcp_relay_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.create_dhcp_relay_profile_with_http_info(dhcp_relay_profile, **kwargs)  # noqa: E501
            return data

    def create_dhcp_relay_profile_with_http_info(self, dhcp_relay_profile, **kwargs):  # noqa: E501
        """Create a DHCP Relay Profile  # noqa: E501

        Creates a dhcp relay profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_dhcp_relay_profile_with_http_info(dhcp_relay_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param DhcpRelayProfile dhcp_relay_profile: (required)
        :return: DhcpRelayProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dhcp_relay_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dhcp_relay_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dhcp_relay_profile' is set
        if ('dhcp_relay_profile' not in params or
                params['dhcp_relay_profile'] is None):
            raise ValueError("Missing the required parameter `dhcp_relay_profile` when calling `create_dhcp_relay_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dhcp_relay_profile' in params:
            body_params = params['dhcp_relay_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/relay-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpRelayProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_logical_router(self, logical_router, **kwargs):  # noqa: E501
        """Create a Logical Router  # noqa: E501

        Creates a logical router. The required parameters are router_type (TIER0 or TIER1) and edge_cluster_id (TIER0 only). Optional parameters include internal and external transit network addresses.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_logical_router(logical_router, async=True)
        >>> result = thread.get()

        :param async bool
        :param LogicalRouter logical_router: (required)
        :return: LogicalRouter
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_logical_router_with_http_info(logical_router, **kwargs)  # noqa: E501
        else:
            (data) = self.create_logical_router_with_http_info(logical_router, **kwargs)  # noqa: E501
            return data

    def create_logical_router_with_http_info(self, logical_router, **kwargs):  # noqa: E501
        """Create a Logical Router  # noqa: E501

        Creates a logical router. The required parameters are router_type (TIER0 or TIER1) and edge_cluster_id (TIER0 only). Optional parameters include internal and external transit network addresses.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_logical_router_with_http_info(logical_router, async=True)
        >>> result = thread.get()

        :param async bool
        :param LogicalRouter logical_router: (required)
        :return: LogicalRouter
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_logical_router" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router' is set
        if ('logical_router' not in params or
                params['logical_router'] is None):
            raise ValueError("Missing the required parameter `logical_router` when calling `create_logical_router`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'logical_router' in params:
            body_params = params['logical_router']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouter',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_logical_router_port(self, logical_router_port, **kwargs):  # noqa: E501
        """Create a Logical Router Port  # noqa: E501

        Creates a logical router port. The required parameters include resource_type (LogicalRouterUpLinkPort, LogicalRouterDownLinkPort, LogicalRouterLinkPort, LogicalRouterLoopbackPort); and logical_router_id (the router to which each logical router port is assigned). The service_bindings parameter is optional.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_logical_router_port(logical_router_port, async=True)
        >>> result = thread.get()

        :param async bool
        :param LogicalRouterPort logical_router_port: (required)
        :return: LogicalRouterPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_logical_router_port_with_http_info(logical_router_port, **kwargs)  # noqa: E501
        else:
            (data) = self.create_logical_router_port_with_http_info(logical_router_port, **kwargs)  # noqa: E501
            return data

    def create_logical_router_port_with_http_info(self, logical_router_port, **kwargs):  # noqa: E501
        """Create a Logical Router Port  # noqa: E501

        Creates a logical router port. The required parameters include resource_type (LogicalRouterUpLinkPort, LogicalRouterDownLinkPort, LogicalRouterLinkPort, LogicalRouterLoopbackPort); and logical_router_id (the router to which each logical router port is assigned). The service_bindings parameter is optional.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_logical_router_port_with_http_info(logical_router_port, async=True)
        >>> result = thread.get()

        :param async bool
        :param LogicalRouterPort logical_router_port: (required)
        :return: LogicalRouterPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_port']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_logical_router_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_port' is set
        if ('logical_router_port' not in params or
                params['logical_router_port'] is None):
            raise ValueError("Missing the required parameter `logical_router_port` when calling `create_logical_router_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'logical_router_port' in params:
            body_params = params['logical_router_port']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-router-ports', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterPort',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_service(self, logical_service, **kwargs):  # noqa: E501
        """Create a Logical Router Service  # noqa: E501

        Creates a service that can be applied to one or more logical router ports. For some service types, you must create a service-profile before you can create a service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_service(logical_service, async=True)
        >>> result = thread.get()

        :param async bool
        :param LogicalService logical_service: (required)
        :return: LogicalService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_service_with_http_info(logical_service, **kwargs)  # noqa: E501
        else:
            (data) = self.create_service_with_http_info(logical_service, **kwargs)  # noqa: E501
            return data

    def create_service_with_http_info(self, logical_service, **kwargs):  # noqa: E501
        """Create a Logical Router Service  # noqa: E501

        Creates a service that can be applied to one or more logical router ports. For some service types, you must create a service-profile before you can create a service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_service_with_http_info(logical_service, async=True)
        >>> result = thread.get()

        :param async bool
        :param LogicalService logical_service: (required)
        :return: LogicalService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_service']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_service' is set
        if ('logical_service' not in params or
                params['logical_service'] is None):
            raise ValueError("Missing the required parameter `logical_service` when calling `create_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'logical_service' in params:
            body_params = params['logical_service']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/services', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalService',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_service_profile(self, service_profile, **kwargs):  # noqa: E501
        """Create a Service Profile  # noqa: E501

        Creates a service profile, which can then be used to create a service. Services are then applied to one or more logical router ports.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_service_profile(service_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param ServiceProfile service_profile: (required)
        :return: ServiceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_service_profile_with_http_info(service_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.create_service_profile_with_http_info(service_profile, **kwargs)  # noqa: E501
            return data

    def create_service_profile_with_http_info(self, service_profile, **kwargs):  # noqa: E501
        """Create a Service Profile  # noqa: E501

        Creates a service profile, which can then be used to create a service. Services are then applied to one or more logical router ports.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_service_profile_with_http_info(service_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param ServiceProfile service_profile: (required)
        :return: ServiceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_service_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_profile' is set
        if ('service_profile' not in params or
                params['service_profile'] is None):
            raise ValueError("Missing the required parameter `service_profile` when calling `create_service_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'service_profile' in params:
            body_params = params['service_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/service-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_static_hop_bfd_peer(self, logical_router_id, static_hop_bfd_peer, **kwargs):  # noqa: E501
        """Create a static hop BFD peer  # noqa: E501

        Creates a BFD peer for static route. The required parameters includes peer IP address.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_static_hop_bfd_peer(logical_router_id, static_hop_bfd_peer, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param StaticHopBfdPeer static_hop_bfd_peer: (required)
        :return: StaticHopBfdPeer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_static_hop_bfd_peer_with_http_info(logical_router_id, static_hop_bfd_peer, **kwargs)  # noqa: E501
        else:
            (data) = self.create_static_hop_bfd_peer_with_http_info(logical_router_id, static_hop_bfd_peer, **kwargs)  # noqa: E501
            return data

    def create_static_hop_bfd_peer_with_http_info(self, logical_router_id, static_hop_bfd_peer, **kwargs):  # noqa: E501
        """Create a static hop BFD peer  # noqa: E501

        Creates a BFD peer for static route. The required parameters includes peer IP address.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_static_hop_bfd_peer_with_http_info(logical_router_id, static_hop_bfd_peer, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param StaticHopBfdPeer static_hop_bfd_peer: (required)
        :return: StaticHopBfdPeer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'static_hop_bfd_peer']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_static_hop_bfd_peer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `create_static_hop_bfd_peer`")  # noqa: E501
        # verify the required parameter 'static_hop_bfd_peer' is set
        if ('static_hop_bfd_peer' not in params or
                params['static_hop_bfd_peer'] is None):
            raise ValueError("Missing the required parameter `static_hop_bfd_peer` when calling `create_static_hop_bfd_peer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'static_hop_bfd_peer' in params:
            body_params = params['static_hop_bfd_peer']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/static-routes/bfd-peers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StaticHopBfdPeer',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_bgp_neighbor(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Delete a specific BGP Neighbor on a Logical Router  # noqa: E501

        Delete a specific BGP Neighbor on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_bgp_neighbor(logical_router_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_bgp_neighbor_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_bgp_neighbor_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def delete_bgp_neighbor_with_http_info(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Delete a specific BGP Neighbor on a Logical Router  # noqa: E501

        Delete a specific BGP Neighbor on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_bgp_neighbor_with_http_info(logical_router_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_bgp_neighbor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `delete_bgp_neighbor`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_bgp_neighbor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/neighbors/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dhcp_relay(self, relay_id, **kwargs):  # noqa: E501
        """Delete a DHCP Relay Service  # noqa: E501

        Deletes the specified dhcp relay service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dhcp_relay(relay_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str relay_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_dhcp_relay_with_http_info(relay_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dhcp_relay_with_http_info(relay_id, **kwargs)  # noqa: E501
            return data

    def delete_dhcp_relay_with_http_info(self, relay_id, **kwargs):  # noqa: E501
        """Delete a DHCP Relay Service  # noqa: E501

        Deletes the specified dhcp relay service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dhcp_relay_with_http_info(relay_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str relay_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['relay_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dhcp_relay" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'relay_id' is set
        if ('relay_id' not in params or
                params['relay_id'] is None):
            raise ValueError("Missing the required parameter `relay_id` when calling `delete_dhcp_relay`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'relay_id' in params:
            path_params['relay-id'] = params['relay_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/relays/{relay-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dhcp_relay_profile(self, relay_profile_id, **kwargs):  # noqa: E501
        """Delete a DHCP Relay Profile  # noqa: E501

        Deletes the specified dhcp relay profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dhcp_relay_profile(relay_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str relay_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_dhcp_relay_profile_with_http_info(relay_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dhcp_relay_profile_with_http_info(relay_profile_id, **kwargs)  # noqa: E501
            return data

    def delete_dhcp_relay_profile_with_http_info(self, relay_profile_id, **kwargs):  # noqa: E501
        """Delete a DHCP Relay Profile  # noqa: E501

        Deletes the specified dhcp relay profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dhcp_relay_profile_with_http_info(relay_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str relay_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['relay_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dhcp_relay_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'relay_profile_id' is set
        if ('relay_profile_id' not in params or
                params['relay_profile_id'] is None):
            raise ValueError("Missing the required parameter `relay_profile_id` when calling `delete_dhcp_relay_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'relay_profile_id' in params:
            path_params['relay-profile-id'] = params['relay_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/relay-profiles/{relay-profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ip_prefix_list(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Delete a specific IPPrefixList on a Logical Router  # noqa: E501

        Deletes a specific IPPrefixList on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_ip_prefix_list(logical_router_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_ip_prefix_list_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ip_prefix_list_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def delete_ip_prefix_list_with_http_info(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Delete a specific IPPrefixList on a Logical Router  # noqa: E501

        Deletes a specific IPPrefixList on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_ip_prefix_list_with_http_info(logical_router_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ip_prefix_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `delete_ip_prefix_list`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_ip_prefix_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/ip-prefix-lists/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_logical_router(self, logical_router_id, **kwargs):  # noqa: E501
        """Delete a Logical Router  # noqa: E501

        Deletes the specified logical router. You must delete associated logical router ports before you can delete a logical router. Otherwise use force delete which will delete all related ports and other entities associated with that LR. To force delete logical router pass force=true in query param.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_logical_router(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_logical_router_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_logical_router_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def delete_logical_router_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Delete a Logical Router  # noqa: E501

        Deletes the specified logical router. You must delete associated logical router ports before you can delete a logical router. Otherwise use force delete which will delete all related ports and other entities associated with that LR. To force delete logical router pass force=true in query param.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_logical_router_with_http_info(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'force']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_logical_router" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `delete_logical_router`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_logical_router_port(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Delete a Logical Router Port  # noqa: E501

        Deletes the specified logical router port. You must delete logical router ports before you can delete the associated logical router. To Delete Tier0 router link port you must have to delete attached tier1 router link port, otherwise pass \"force=true\" as query param to force delete the Tier0 router link port.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_logical_router_port(logical_router_port_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_port_id: (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_logical_router_port_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_logical_router_port_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
            return data

    def delete_logical_router_port_with_http_info(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Delete a Logical Router Port  # noqa: E501

        Deletes the specified logical router port. You must delete logical router ports before you can delete the associated logical router. To Delete Tier0 router link port you must have to delete attached tier1 router link port, otherwise pass \"force=true\" as query param to force delete the Tier0 router link port.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_logical_router_port_with_http_info(logical_router_port_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_port_id: (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_port_id', 'force']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_logical_router_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_port_id' is set
        if ('logical_router_port_id' not in params or
                params['logical_router_port_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_port_id` when calling `delete_logical_router_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_port_id' in params:
            path_params['logical-router-port-id'] = params['logical_router_port_id']  # noqa: E501

        query_params = []
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-router-ports/{logical-router-port-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_nat_rule(self, logical_router_id, rule_id, **kwargs):  # noqa: E501
        """Delete a specific NAT rule from a logical router  # noqa: E501

        Delete a specific NAT rule from a logical router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_nat_rule(logical_router_id, rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str rule_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_nat_rule_with_http_info(logical_router_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_nat_rule_with_http_info(logical_router_id, rule_id, **kwargs)  # noqa: E501
            return data

    def delete_nat_rule_with_http_info(self, logical_router_id, rule_id, **kwargs):  # noqa: E501
        """Delete a specific NAT rule from a logical router  # noqa: E501

        Delete a specific NAT rule from a logical router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_nat_rule_with_http_info(logical_router_id, rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str rule_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'rule_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_nat_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `delete_nat_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `delete_nat_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/nat/rules/{rule-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_route_map(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Delete a specific RouteMap on a Logical Router  # noqa: E501

        Deletes a specific RouteMap on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_route_map(logical_router_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_route_map_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_route_map_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def delete_route_map_with_http_info(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Delete a specific RouteMap on a Logical Router  # noqa: E501

        Deletes a specific RouteMap on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_route_map_with_http_info(logical_router_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_route_map" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `delete_route_map`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_route_map`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/route-maps/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_service(self, service_id, **kwargs):  # noqa: E501
        """Delete a Logical Router Service  # noqa: E501

        Deletes the specified logical router service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_service(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_service_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_service_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def delete_service_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Delete a Logical Router Service  # noqa: E501

        Deletes the specified logical router service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_service_with_http_info(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `delete_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/services/{service-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_service_profile(self, service_profile_id, **kwargs):  # noqa: E501
        """Delete a Service Profile  # noqa: E501

        Deletes the specified service profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_service_profile(service_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_service_profile_with_http_info(service_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_service_profile_with_http_info(service_profile_id, **kwargs)  # noqa: E501
            return data

    def delete_service_profile_with_http_info(self, service_profile_id, **kwargs):  # noqa: E501
        """Delete a Service Profile  # noqa: E501

        Deletes the specified service profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_service_profile_with_http_info(service_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_service_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_profile_id' is set
        if ('service_profile_id' not in params or
                params['service_profile_id'] is None):
            raise ValueError("Missing the required parameter `service_profile_id` when calling `delete_service_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_profile_id' in params:
            path_params['service-profile-id'] = params['service_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/service-profiles/{service-profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_static_hop_bfd_peer(self, logical_router_id, bfd_peer_id, **kwargs):  # noqa: E501
        """Delete a specified static route BFD peer cofigured on a specified logical router  # noqa: E501

        Deletes the specified BFD peer present on specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_static_hop_bfd_peer(logical_router_id, bfd_peer_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str bfd_peer_id: (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_static_hop_bfd_peer_with_http_info(logical_router_id, bfd_peer_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_static_hop_bfd_peer_with_http_info(logical_router_id, bfd_peer_id, **kwargs)  # noqa: E501
            return data

    def delete_static_hop_bfd_peer_with_http_info(self, logical_router_id, bfd_peer_id, **kwargs):  # noqa: E501
        """Delete a specified static route BFD peer cofigured on a specified logical router  # noqa: E501

        Deletes the specified BFD peer present on specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_static_hop_bfd_peer_with_http_info(logical_router_id, bfd_peer_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str bfd_peer_id: (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'bfd_peer_id', 'force']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_static_hop_bfd_peer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `delete_static_hop_bfd_peer`")  # noqa: E501
        # verify the required parameter 'bfd_peer_id' is set
        if ('bfd_peer_id' not in params or
                params['bfd_peer_id'] is None):
            raise ValueError("Missing the required parameter `bfd_peer_id` when calling `delete_static_hop_bfd_peer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'bfd_peer_id' in params:
            path_params['bfd-peer-id'] = params['bfd_peer_id']  # noqa: E501

        query_params = []
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/static-routes/bfd-peers/{bfd-peer-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_static_route(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Delete a specific Static Route on a Logical Router  # noqa: E501

        Deletes a specific static route on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_static_route(logical_router_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_static_route_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_static_route_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def delete_static_route_with_http_info(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Delete a specific Static Route on a Logical Router  # noqa: E501

        Deletes a specific static route on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_static_route_with_http_info(logical_router_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_static_route" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `delete_static_route`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_static_route`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/static-routes/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bgp_neighbors_status(self, logical_router_id, **kwargs):  # noqa: E501
        """Get the status of all the BGP neighbors for the Logical Router of the given id  # noqa: E501

        Returns the status of all the BGP neighbors for the Logical Router of the given id. To get BGP neighbors status for the logical router from particular node, parameter \"transport_node_id=<transportnode_id>\" needs to be specified. The query parameter \"source=cached\" is not supported.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_bgp_neighbors_status(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str transport_node_id: Transport node id
        :return: BgpNeighborsStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_bgp_neighbors_status_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bgp_neighbors_status_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def get_bgp_neighbors_status_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Get the status of all the BGP neighbors for the Logical Router of the given id  # noqa: E501

        Returns the status of all the BGP neighbors for the Logical Router of the given id. To get BGP neighbors status for the logical router from particular node, parameter \"transport_node_id=<transportnode_id>\" needs to be specified. The query parameter \"source=cached\" is not supported.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_bgp_neighbors_status_with_http_info(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str transport_node_id: Transport node id
        :return: BgpNeighborsStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'source', 'transport_node_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bgp_neighbors_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_bgp_neighbors_status`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_bgp_neighbors_status`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_bgp_neighbors_status`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/neighbors/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpNeighborsStatusListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_forwarding_table(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get FIB table on a specified node for a logical router  # noqa: E501

        Returns the FIB for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. To filter the result by network address, paramter \"network_prefix=<a.b.c.d/mask>\" needs to be specified. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_forwarding_table(logical_router_id, transport_node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str network_prefix: IPv4 CIDR Block
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :return: LogicalRouterRouteTable
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_router_forwarding_table_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_forwarding_table_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_forwarding_table_with_http_info(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get FIB table on a specified node for a logical router  # noqa: E501

        Returns the FIB for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. To filter the result by network address, paramter \"network_prefix=<a.b.c.d/mask>\" needs to be specified. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_forwarding_table_with_http_info(logical_router_id, transport_node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str network_prefix: IPv4 CIDR Block
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :return: LogicalRouterRouteTable
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'transport_node_id', 'cursor', 'included_fields', 'network_prefix', 'page_size', 'sort_ascending', 'sort_by', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_forwarding_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_logical_router_forwarding_table`")  # noqa: E501
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `get_logical_router_forwarding_table`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_logical_router_forwarding_table`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_logical_router_forwarding_table`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'network_prefix' in params:
            query_params.append(('network_prefix', params['network_prefix']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/forwarding-table', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterRouteTable',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_forwarding_table_in_csv_format_csv(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get FIB table on a specified node for a logical router  # noqa: E501

        Returns the FIB table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. To filter the result by network address, paramter \"network_prefix=<a.b.c.d/mask>\" needs to be specified. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_forwarding_table_in_csv_format_csv(logical_router_id, transport_node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str network_prefix: IPv4 CIDR Block
        :param str source: Data source type.
        :return: LogicalRouterRouteTableInCsvFormat
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_router_forwarding_table_in_csv_format_csv_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_forwarding_table_in_csv_format_csv_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_forwarding_table_in_csv_format_csv_with_http_info(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get FIB table on a specified node for a logical router  # noqa: E501

        Returns the FIB table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. To filter the result by network address, paramter \"network_prefix=<a.b.c.d/mask>\" needs to be specified. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_forwarding_table_in_csv_format_csv_with_http_info(logical_router_id, transport_node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str network_prefix: IPv4 CIDR Block
        :param str source: Data source type.
        :return: LogicalRouterRouteTableInCsvFormat
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'transport_node_id', 'network_prefix', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_forwarding_table_in_csv_format_csv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_logical_router_forwarding_table_in_csv_format_csv`")  # noqa: E501
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `get_logical_router_forwarding_table_in_csv_format_csv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'network_prefix' in params:
            query_params.append(('network_prefix', params['network_prefix']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/csv'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/forwarding-table?format=csv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterRouteTableInCsvFormat',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_port_arp_table(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Get the ARP table for the Logical Router Port of the given id  # noqa: E501

        Returns ARP table for the Logical Router Port of the given id, on a node if a query parameter \"transport_node_id=<transport-node-id>\" is given. The transport_node_id parameter is mandatory if the router port is not uplink type. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_port_arp_table(logical_router_port_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_port_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: LogicalRouterPortArpTable
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_router_port_arp_table_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_port_arp_table_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_port_arp_table_with_http_info(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Get the ARP table for the Logical Router Port of the given id  # noqa: E501

        Returns ARP table for the Logical Router Port of the given id, on a node if a query parameter \"transport_node_id=<transport-node-id>\" is given. The transport_node_id parameter is mandatory if the router port is not uplink type. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_port_arp_table_with_http_info(logical_router_port_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_port_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: LogicalRouterPortArpTable
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_port_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'source', 'transport_node_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_port_arp_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_port_id' is set
        if ('logical_router_port_id' not in params or
                params['logical_router_port_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_port_id` when calling `get_logical_router_port_arp_table`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_logical_router_port_arp_table`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_logical_router_port_arp_table`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'logical_router_port_id' in params:
            path_params['logical-router-port-id'] = params['logical_router_port_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-router-ports/{logical-router-port-id}/arp-table', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterPortArpTable',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_port_arp_table_in_csv_format_csv(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Get the ARP table for the Logical Router Port of the given id  # noqa: E501

        Returns ARP table in CSV format for the Logical Router Port of the given id, on a node if a query parameter \"transport_node_id=<transport-node-id>\" is given. The transport_node_id parameter is mandatory if the router port is not uplink type. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_port_arp_table_in_csv_format_csv(logical_router_port_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_port_id: (required)
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: LogicalRouterPortArpTableInCsvFormat
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_router_port_arp_table_in_csv_format_csv_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_port_arp_table_in_csv_format_csv_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_port_arp_table_in_csv_format_csv_with_http_info(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Get the ARP table for the Logical Router Port of the given id  # noqa: E501

        Returns ARP table in CSV format for the Logical Router Port of the given id, on a node if a query parameter \"transport_node_id=<transport-node-id>\" is given. The transport_node_id parameter is mandatory if the router port is not uplink type. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_port_arp_table_in_csv_format_csv_with_http_info(logical_router_port_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_port_id: (required)
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: LogicalRouterPortArpTableInCsvFormat
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_port_id', 'source', 'transport_node_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_port_arp_table_in_csv_format_csv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_port_id' is set
        if ('logical_router_port_id' not in params or
                params['logical_router_port_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_port_id` when calling `get_logical_router_port_arp_table_in_csv_format_csv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_port_id' in params:
            path_params['logical-router-port-id'] = params['logical_router_port_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/csv'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-router-ports/{logical-router-port-id}/arp-table?format=csv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterPortArpTableInCsvFormat',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_port_statistics(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Get the statistics of a specified logical router port on all or a specified node  # noqa: E501

        Returns the statistics for the Logical Router Port. If query parameter \"transport_node_id=<transport-node-id>\" is given,  only the statistics from the given node for the logical router port will be returned. Otherwise the statistics from each node for the same logical router port will be returned. The transport_node_id is mandatory if the router port is not uplink type. The query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_port_statistics(logical_router_port_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_port_id: (required)
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: LogicalRouterPortStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_router_port_statistics_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_port_statistics_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_port_statistics_with_http_info(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Get the statistics of a specified logical router port on all or a specified node  # noqa: E501

        Returns the statistics for the Logical Router Port. If query parameter \"transport_node_id=<transport-node-id>\" is given,  only the statistics from the given node for the logical router port will be returned. Otherwise the statistics from each node for the same logical router port will be returned. The transport_node_id is mandatory if the router port is not uplink type. The query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_port_statistics_with_http_info(logical_router_port_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_port_id: (required)
        :param str source: Data source type.
        :param str transport_node_id: TransportNode Id
        :return: LogicalRouterPortStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_port_id', 'source', 'transport_node_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_port_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_port_id' is set
        if ('logical_router_port_id' not in params or
                params['logical_router_port_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_port_id` when calling `get_logical_router_port_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_port_id' in params:
            path_params['logical-router-port-id'] = params['logical_router_port_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-router-ports/{logical-router-port-id}/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterPortStatistics',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_port_statistics_summary(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Get the statistics summary of a specified logical router port  # noqa: E501

        Returns the summation of statistics from all nodes for the Specified Logical Router Port. The query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_port_statistics_summary(logical_router_port_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_port_id: (required)
        :param str source: Data source type.
        :return: LogicalRouterPortStatisticsSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_router_port_statistics_summary_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_port_statistics_summary_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_port_statistics_summary_with_http_info(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Get the statistics summary of a specified logical router port  # noqa: E501

        Returns the summation of statistics from all nodes for the Specified Logical Router Port. The query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_port_statistics_summary_with_http_info(logical_router_port_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_port_id: (required)
        :param str source: Data source type.
        :return: LogicalRouterPortStatisticsSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_port_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_port_statistics_summary" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_port_id' is set
        if ('logical_router_port_id' not in params or
                params['logical_router_port_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_port_id` when calling `get_logical_router_port_statistics_summary`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_port_id' in params:
            path_params['logical-router-port-id'] = params['logical_router_port_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-router-ports/{logical-router-port-id}/statistics/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterPortStatisticsSummary',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_route_table(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get route table on a given node for a logical router  # noqa: E501

        Deprecated - Please use /logical-routers/<logical-router-id>/routing/routing-table for RIB and /logical-routers/<logical-router-id>/routing/forwarding-table for FIB. Returns the route table for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_route_table(logical_router_id, transport_node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :return: LogicalRouterRouteTable
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_router_route_table_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_route_table_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_route_table_with_http_info(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get route table on a given node for a logical router  # noqa: E501

        Deprecated - Please use /logical-routers/<logical-router-id>/routing/routing-table for RIB and /logical-routers/<logical-router-id>/routing/forwarding-table for FIB. Returns the route table for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_route_table_with_http_info(logical_router_id, transport_node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :return: LogicalRouterRouteTable
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'transport_node_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_route_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_logical_router_route_table`")  # noqa: E501
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `get_logical_router_route_table`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_logical_router_route_table`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_logical_router_route_table`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/route-table', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterRouteTable',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_route_table_in_csv_format_csv(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get route table on a node for a logical router  # noqa: E501

        Deprecated - Please use /logical-routers/<logical-router-id>/routing/routing-table for RIB and /logical-routers/<logical-router-id>/routing/forwarding-table for FIB. Returns the route table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_route_table_in_csv_format_csv(logical_router_id, transport_node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str source: Data source type.
        :return: LogicalRouterRouteTableInCsvFormat
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_router_route_table_in_csv_format_csv_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_route_table_in_csv_format_csv_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_route_table_in_csv_format_csv_with_http_info(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get route table on a node for a logical router  # noqa: E501

        Deprecated - Please use /logical-routers/<logical-router-id>/routing/routing-table for RIB and /logical-routers/<logical-router-id>/routing/forwarding-table for FIB. Returns the route table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_route_table_in_csv_format_csv_with_http_info(logical_router_id, transport_node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str source: Data source type.
        :return: LogicalRouterRouteTableInCsvFormat
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'transport_node_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_route_table_in_csv_format_csv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_logical_router_route_table_in_csv_format_csv`")  # noqa: E501
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `get_logical_router_route_table_in_csv_format_csv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/csv'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/route-table?format=csv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterRouteTableInCsvFormat',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_routing_table(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get RIB table on a specified node for a logical router  # noqa: E501

        Returns the route table(RIB) for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. To filter the result by network address, parameter \"network_prefix=<a.b.c.d/mask>\" needs to be specified. To filter the result by route source, parameter \"route_source=<source_type>\" needs to be specified where source_type can be BGP, STATIC, CONNECTED, NSX_STATIC, TIER1_NAT or TIER0_NAT. It is also possible to filter the RIB table using both network address and route source filter together. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_routing_table(logical_router_id, transport_node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str network_prefix: IPv4 CIDR Block
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str route_source: To filter the RIB table based on the source from which route is learned.
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :return: LogicalRouterRouteTable
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_router_routing_table_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_routing_table_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_routing_table_with_http_info(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get RIB table on a specified node for a logical router  # noqa: E501

        Returns the route table(RIB) for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. To filter the result by network address, parameter \"network_prefix=<a.b.c.d/mask>\" needs to be specified. To filter the result by route source, parameter \"route_source=<source_type>\" needs to be specified where source_type can be BGP, STATIC, CONNECTED, NSX_STATIC, TIER1_NAT or TIER0_NAT. It is also possible to filter the RIB table using both network address and route source filter together. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_routing_table_with_http_info(logical_router_id, transport_node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str network_prefix: IPv4 CIDR Block
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str route_source: To filter the RIB table based on the source from which route is learned.
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str source: Data source type.
        :return: LogicalRouterRouteTable
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'transport_node_id', 'cursor', 'included_fields', 'network_prefix', 'page_size', 'route_source', 'sort_ascending', 'sort_by', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_routing_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_logical_router_routing_table`")  # noqa: E501
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `get_logical_router_routing_table`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_logical_router_routing_table`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_logical_router_routing_table`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'network_prefix' in params:
            query_params.append(('network_prefix', params['network_prefix']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'route_source' in params:
            query_params.append(('route_source', params['route_source']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/routing-table', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterRouteTable',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_routing_table_in_csv_format_csv(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get RIB table on a specified node for a logical router  # noqa: E501

        Returns the route table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. To filter the result by network address, paramter \"network_prefix=<a.b.c.d/mask>\" needs to be specified. To filter the result by route source, parameter \"route_source=<source_type>\" needs to be specified where source_type can be BGP, STATIC, CONNECTED, NSX_STATIC, TIER1_NAT or TIER0_NAT. It is also possible to filter the RIB table using both network address and route source filter together. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_routing_table_in_csv_format_csv(logical_router_id, transport_node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str network_prefix: IPv4 CIDR Block
        :param str route_source: To filter the RIB table based on the source from which route is learned.
        :param str source: Data source type.
        :return: LogicalRouterRouteTableInCsvFormat
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_router_routing_table_in_csv_format_csv_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_routing_table_in_csv_format_csv_with_http_info(logical_router_id, transport_node_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_routing_table_in_csv_format_csv_with_http_info(self, logical_router_id, transport_node_id, **kwargs):  # noqa: E501
        """Get RIB table on a specified node for a logical router  # noqa: E501

        Returns the route table in CSV format for the logical router on a node of the given transport-node-id. Query parameter \"transport_node_id=<transport-node-id>\" is required. To filter the result by network address, paramter \"network_prefix=<a.b.c.d/mask>\" needs to be specified. To filter the result by route source, parameter \"route_source=<source_type>\" needs to be specified where source_type can be BGP, STATIC, CONNECTED, NSX_STATIC, TIER1_NAT or TIER0_NAT. It is also possible to filter the RIB table using both network address and route source filter together. The query parameter \"source=cached\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_routing_table_in_csv_format_csv_with_http_info(logical_router_id, transport_node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str transport_node_id: TransportNode Id (required)
        :param str network_prefix: IPv4 CIDR Block
        :param str route_source: To filter the RIB table based on the source from which route is learned.
        :param str source: Data source type.
        :return: LogicalRouterRouteTableInCsvFormat
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'transport_node_id', 'network_prefix', 'route_source', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_routing_table_in_csv_format_csv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_logical_router_routing_table_in_csv_format_csv`")  # noqa: E501
        # verify the required parameter 'transport_node_id' is set
        if ('transport_node_id' not in params or
                params['transport_node_id'] is None):
            raise ValueError("Missing the required parameter `transport_node_id` when calling `get_logical_router_routing_table_in_csv_format_csv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'network_prefix' in params:
            query_params.append(('network_prefix', params['network_prefix']))  # noqa: E501
        if 'route_source' in params:
            query_params.append(('route_source', params['route_source']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'transport_node_id' in params:
            query_params.append(('transport_node_id', params['transport_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/csv'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/routing-table?format=csv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterRouteTableInCsvFormat',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logical_router_status(self, logical_router_id, **kwargs):  # noqa: E501
        """Get the status for the Logical Router of the given id  # noqa: E501

        Returns status for the Logical Router of the given id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_status(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str source: Data source type.
        :return: LogicalRouterStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_logical_router_status_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_logical_router_status_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def get_logical_router_status_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Get the status for the Logical Router of the given id  # noqa: E501

        Returns status for the Logical Router of the given id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_logical_router_status_with_http_info(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str source: Data source type.
        :return: LogicalRouterStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logical_router_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_logical_router_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_nat_rule(self, logical_router_id, rule_id, **kwargs):  # noqa: E501
        """Get a specific NAT rule from a given logical router  # noqa: E501

        Get a specific NAT rule from a given logical router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_nat_rule(logical_router_id, rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str rule_id: (required)
        :return: NatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_nat_rule_with_http_info(logical_router_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_nat_rule_with_http_info(logical_router_id, rule_id, **kwargs)  # noqa: E501
            return data

    def get_nat_rule_with_http_info(self, logical_router_id, rule_id, **kwargs):  # noqa: E501
        """Get a specific NAT rule from a given logical router  # noqa: E501

        Get a specific NAT rule from a given logical router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_nat_rule_with_http_info(logical_router_id, rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str rule_id: (required)
        :return: NatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'rule_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_nat_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_nat_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `get_nat_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/nat/rules/{rule-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NatRule',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_nat_statistics_per_logical_router(self, logical_router_id, **kwargs):  # noqa: E501
        """Get the statistics of all rules of the logical router  # noqa: E501

        Returns the summation of statistics for all rules from all nodes for the Specified Logical Router. Also gives the per transport node statistics for provided logical router. The query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_nat_statistics_per_logical_router(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str source: Data source type.
        :return: NatStatisticsPerLogicalRouter
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_nat_statistics_per_logical_router_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_nat_statistics_per_logical_router_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def get_nat_statistics_per_logical_router_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Get the statistics of all rules of the logical router  # noqa: E501

        Returns the summation of statistics for all rules from all nodes for the Specified Logical Router. Also gives the per transport node statistics for provided logical router. The query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_nat_statistics_per_logical_router_with_http_info(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str source: Data source type.
        :return: NatStatisticsPerLogicalRouter
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_nat_statistics_per_logical_router" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_nat_statistics_per_logical_router`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/nat/rules/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NatStatisticsPerLogicalRouter',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_nat_statistics_per_rule(self, logical_router_id, rule_id, **kwargs):  # noqa: E501
        """Get the statistics of a specified logical router NAT Rule  # noqa: E501

        Returns the summation of statistics from all nodes for the Specified Logical Router NAT Rule. Query parameter \"source=realtime\" is the only supported source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_nat_statistics_per_rule(logical_router_id, rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str rule_id: (required)
        :param str source: Data source type.
        :return: NatStatisticsPerRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_nat_statistics_per_rule_with_http_info(logical_router_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_nat_statistics_per_rule_with_http_info(logical_router_id, rule_id, **kwargs)  # noqa: E501
            return data

    def get_nat_statistics_per_rule_with_http_info(self, logical_router_id, rule_id, **kwargs):  # noqa: E501
        """Get the statistics of a specified logical router NAT Rule  # noqa: E501

        Returns the summation of statistics from all nodes for the Specified Logical Router NAT Rule. Query parameter \"source=realtime\" is the only supported source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_nat_statistics_per_rule_with_http_info(logical_router_id, rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str rule_id: (required)
        :param str source: Data source type.
        :return: NatStatisticsPerRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'rule_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_nat_statistics_per_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `get_nat_statistics_per_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `get_nat_statistics_per_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/nat/rules/{rule-id}/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NatStatisticsPerRule',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_nat_statistics_per_transport_node(self, node_id, **kwargs):  # noqa: E501
        """Get statistics for all logical router NAT rules on a transport node  # noqa: E501

        Returns the summation of statistics for all rules from all logical routers which are present on given transport node. Only cached statistics are supported. The query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_nat_statistics_per_transport_node(node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: (required)
        :param str source: Data source type.
        :return: NatStatisticsPerTransportNode
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_nat_statistics_per_transport_node_with_http_info(node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_nat_statistics_per_transport_node_with_http_info(node_id, **kwargs)  # noqa: E501
            return data

    def get_nat_statistics_per_transport_node_with_http_info(self, node_id, **kwargs):  # noqa: E501
        """Get statistics for all logical router NAT rules on a transport node  # noqa: E501

        Returns the summation of statistics for all rules from all logical routers which are present on given transport node. Only cached statistics are supported. The query parameter \"source=realtime\" is not supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_nat_statistics_per_transport_node_with_http_info(node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: (required)
        :param str source: Data source type.
        :return: NatStatisticsPerTransportNode
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_nat_statistics_per_transport_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `get_nat_statistics_per_transport_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{node-id}/statistics/nat-rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NatStatisticsPerTransportNode',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_bgp_neighbors(self, logical_router_id, **kwargs):  # noqa: E501
        """Paginated list of BGP Neighbors on a Logical Router  # noqa: E501

        Paginated list of BGP Neighbors on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_bgp_neighbors(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: BgpNeighborListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_bgp_neighbors_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_bgp_neighbors_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def list_bgp_neighbors_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Paginated list of BGP Neighbors on a Logical Router  # noqa: E501

        Paginated list of BGP Neighbors on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_bgp_neighbors_with_http_info(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: BgpNeighborListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_bgp_neighbors" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `list_bgp_neighbors`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_bgp_neighbors`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_bgp_neighbors`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/neighbors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpNeighborListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_dhcp_relay_profiles(self, **kwargs):  # noqa: E501
        """List All DHCP Relay Profiles  # noqa: E501

        Returns information about all dhcp relay profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_dhcp_relay_profiles(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DhcpRelayProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_dhcp_relay_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_dhcp_relay_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_dhcp_relay_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """List All DHCP Relay Profiles  # noqa: E501

        Returns information about all dhcp relay profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_dhcp_relay_profiles_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DhcpRelayProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_dhcp_relay_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_dhcp_relay_profiles`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_dhcp_relay_profiles`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/relay-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpRelayProfileListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_dhcp_relays(self, **kwargs):  # noqa: E501
        """List all DHCP Relay Services  # noqa: E501

        Returns information about all configured dhcp relay services.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_dhcp_relays(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DhcpRelayServiceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_dhcp_relays_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_dhcp_relays_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_dhcp_relays_with_http_info(self, **kwargs):  # noqa: E501
        """List all DHCP Relay Services  # noqa: E501

        Returns information about all configured dhcp relay services.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_dhcp_relays_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DhcpRelayServiceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_dhcp_relays" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_dhcp_relays`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_dhcp_relays`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/relays', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpRelayServiceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_ip_prefix_lists(self, logical_router_id, **kwargs):  # noqa: E501
        """Paginated List of IPPrefixLists  # noqa: E501

        Paginated List of IPPrefixLists  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ip_prefix_lists(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: IPPrefixListListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_ip_prefix_lists_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_ip_prefix_lists_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def list_ip_prefix_lists_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Paginated List of IPPrefixLists  # noqa: E501

        Paginated List of IPPrefixLists  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ip_prefix_lists_with_http_info(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: IPPrefixListListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_ip_prefix_lists" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `list_ip_prefix_lists`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ip_prefix_lists`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ip_prefix_lists`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/ip-prefix-lists', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IPPrefixListListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_logical_router_ports(self, **kwargs):  # noqa: E501
        """List Logical Router Ports  # noqa: E501

        Returns information about all logical router ports. Information includes the resource_type (LogicalRouterUpLinkPort, LogicalRouterDownLinkPort, LogicalRouterLinkPort, LogicalRouterLoopbackPort); logical_router_id (the router to which each logical router port is assigned); and any service_bindings (such as DHCP relay service). The GET request can include a query parameter (logical_router_id or logical_switch_id).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_logical_router_ports(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str logical_router_id: Logical Router identifier
        :param str logical_switch_id: Logical Switch identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str resource_type: Resource types of logical router port
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LogicalRouterPortListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_logical_router_ports_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_logical_router_ports_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_logical_router_ports_with_http_info(self, **kwargs):  # noqa: E501
        """List Logical Router Ports  # noqa: E501

        Returns information about all logical router ports. Information includes the resource_type (LogicalRouterUpLinkPort, LogicalRouterDownLinkPort, LogicalRouterLinkPort, LogicalRouterLoopbackPort); logical_router_id (the router to which each logical router port is assigned); and any service_bindings (such as DHCP relay service). The GET request can include a query parameter (logical_router_id or logical_switch_id).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_logical_router_ports_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str logical_router_id: Logical Router identifier
        :param str logical_switch_id: Logical Switch identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str resource_type: Resource types of logical router port
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LogicalRouterPortListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'logical_router_id', 'logical_switch_id', 'page_size', 'resource_type', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_logical_router_ports" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_logical_router_ports`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_logical_router_ports`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'logical_router_id' in params:
            query_params.append(('logical_router_id', params['logical_router_id']))  # noqa: E501
        if 'logical_switch_id' in params:
            query_params.append(('logical_switch_id', params['logical_switch_id']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'resource_type' in params:
            query_params.append(('resource_type', params['resource_type']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-router-ports', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterPortListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_logical_routers(self, **kwargs):  # noqa: E501
        """List Logical Routers  # noqa: E501

        Returns information about all logical routers, including the UUID, internal and external transit network addresses, and the router type (TIER0 or TIER1). You can get information for only TIER0 routers or only the TIER1 routers by including the router_type query parameter.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_logical_routers(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str router_type: Type of Logical Router
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LogicalRouterListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_logical_routers_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_logical_routers_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_logical_routers_with_http_info(self, **kwargs):  # noqa: E501
        """List Logical Routers  # noqa: E501

        Returns information about all logical routers, including the UUID, internal and external transit network addresses, and the router type (TIER0 or TIER1). You can get information for only TIER0 routers or only the TIER1 routers by including the router_type query parameter.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_logical_routers_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str router_type: Type of Logical Router
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LogicalRouterListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'router_type', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_logical_routers" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_logical_routers`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_logical_routers`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'router_type' in params:
            query_params.append(('router_type', params['router_type']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_nat_rules(self, logical_router_id, **kwargs):  # noqa: E501
        """List NAT rules of the logical router  # noqa: E501

        Returns paginated list of all user defined NAT rules of the specific logical router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_nat_rules(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: NatRuleListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_nat_rules_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_nat_rules_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def list_nat_rules_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """List NAT rules of the logical router  # noqa: E501

        Returns paginated list of all user defined NAT rules of the specific logical router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_nat_rules_with_http_info(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: NatRuleListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_nat_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `list_nat_rules`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_nat_rules`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_nat_rules`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/nat/rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NatRuleListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_route_maps(self, logical_router_id, **kwargs):  # noqa: E501
        """Paginated List of RouteMaps  # noqa: E501

        Paginated List of RouteMaps  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_route_maps(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: RouteMapListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_route_maps_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_route_maps_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def list_route_maps_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Paginated List of RouteMaps  # noqa: E501

        Paginated List of RouteMaps  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_route_maps_with_http_info(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: RouteMapListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_route_maps" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `list_route_maps`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_route_maps`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_route_maps`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/route-maps', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RouteMapListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_service_profiles(self, **kwargs):  # noqa: E501
        """List All Service Profiles  # noqa: E501

        Returns information about all service profiles. A service profile is a configuration that you can use to create a service, which is then applied to one or more logical router ports. Currently, only the DhcpRelayProfile is supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_service_profiles(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str resource_type:
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ServiceProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_service_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_service_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_service_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """List All Service Profiles  # noqa: E501

        Returns information about all service profiles. A service profile is a configuration that you can use to create a service, which is then applied to one or more logical router ports. Currently, only the DhcpRelayProfile is supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_service_profiles_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str resource_type:
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ServiceProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'resource_type', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_service_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_service_profiles`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_service_profiles`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'resource_type' in params:
            query_params.append(('resource_type', params['resource_type']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/service-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceProfileListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_services(self, **kwargs):  # noqa: E501
        """List all Logical Router Services  # noqa: E501

        Returns information about all configured logical router services that can be applied to one or more logical router ports. You must create a service-profile before you can create a service. Currently, only DhcpRelayService is supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_services(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str resource_type:
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LogicalServiceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_services_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_services_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_services_with_http_info(self, **kwargs):  # noqa: E501
        """List all Logical Router Services  # noqa: E501

        Returns information about all configured logical router services that can be applied to one or more logical router ports. You must create a service-profile before you can create a service. Currently, only DhcpRelayService is supported.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_services_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str resource_type:
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LogicalServiceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'resource_type', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_services" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_services`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_services`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'resource_type' in params:
            query_params.append(('resource_type', params['resource_type']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/services', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalServiceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_static_hop_bfd_peers(self, logical_router_id, **kwargs):  # noqa: E501
        """List static routes BFD Peers  # noqa: E501

        Returns information about all BFD peers created on specified logical router for static routes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_static_hop_bfd_peers(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: StaticHopBfdPeerListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_static_hop_bfd_peers_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_static_hop_bfd_peers_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def list_static_hop_bfd_peers_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """List static routes BFD Peers  # noqa: E501

        Returns information about all BFD peers created on specified logical router for static routes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_static_hop_bfd_peers_with_http_info(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: StaticHopBfdPeerListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_static_hop_bfd_peers" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `list_static_hop_bfd_peers`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_static_hop_bfd_peers`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_static_hop_bfd_peers`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/static-routes/bfd-peers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StaticHopBfdPeerListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_static_routes(self, logical_router_id, **kwargs):  # noqa: E501
        """Paginated List of Static Routes  # noqa: E501

        Returns information about configured static routes, including the network address and next hops for each static route.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_static_routes(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: StaticRouteListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_static_routes_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_static_routes_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def list_static_routes_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Paginated List of Static Routes  # noqa: E501

        Returns information about configured static routes, including the network address and next hops for each static route.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_static_routes_with_http_info(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: StaticRouteListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_static_routes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `list_static_routes`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_static_routes`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_static_routes`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/static-routes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StaticRouteListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def re_process_logical_router_reprocess(self, logical_router_id, **kwargs):  # noqa: E501
        """Reprocesses a logical router configuration and publish updates to controller  # noqa: E501

        Reprocess logical router configuration and configuration of related entities like logical router ports, static routing, etc. Any missing Updates are published to controller.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.re_process_logical_router_reprocess(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.re_process_logical_router_reprocess_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.re_process_logical_router_reprocess_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def re_process_logical_router_reprocess_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Reprocesses a logical router configuration and publish updates to controller  # noqa: E501

        Reprocess logical router configuration and configuration of related entities like logical router ports, static routing, etc. Any missing Updates are published to controller.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.re_process_logical_router_reprocess_with_http_info(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method re_process_logical_router_reprocess" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `re_process_logical_router_reprocess`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}?action=reprocess', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_advertise_rule_list(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the Advertisement Rules on a Logical Router  # noqa: E501

        Returns the advertisement rule list for the specified TIER1 logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_advertise_rule_list(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :return: AdvertiseRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_advertise_rule_list_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_advertise_rule_list_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def read_advertise_rule_list_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the Advertisement Rules on a Logical Router  # noqa: E501

        Returns the advertisement rule list for the specified TIER1 logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_advertise_rule_list_with_http_info(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :return: AdvertiseRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_advertise_rule_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_advertise_rule_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/advertisement/rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdvertiseRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_advertisement_config(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the Advertisement Configuration on a Logical Router  # noqa: E501

        Returns information about the routes to be advertised by the specified TIER1 logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_advertisement_config(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :return: AdvertisementConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_advertisement_config_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_advertisement_config_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def read_advertisement_config_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the Advertisement Configuration on a Logical Router  # noqa: E501

        Returns information about the routes to be advertised by the specified TIER1 logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_advertisement_config_with_http_info(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :return: AdvertisementConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_advertisement_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_advertisement_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/advertisement', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdvertisementConfig',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_bgp_config(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the BGP Configuration on a Logical Router  # noqa: E501

        Returns information about the BGP configuration on a specified logical router. Information includes whether or not the BGP configuration is enabled, the AS number, and whether or not graceful restart is enabled.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_bgp_config(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :return: BgpConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_bgp_config_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_bgp_config_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def read_bgp_config_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the BGP Configuration on a Logical Router  # noqa: E501

        Returns information about the BGP configuration on a specified logical router. Information includes whether or not the BGP configuration is enabled, the AS number, and whether or not graceful restart is enabled.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_bgp_config_with_http_info(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :return: BgpConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_bgp_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_bgp_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpConfig',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_bgp_neighbor(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Read a specific BGP Neighbor on a Logical Router  # noqa: E501

        Read a specific BGP Neighbor on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_bgp_neighbor(logical_router_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: BgpNeighbor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_bgp_neighbor_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_bgp_neighbor_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def read_bgp_neighbor_with_http_info(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Read a specific BGP Neighbor on a Logical Router  # noqa: E501

        Read a specific BGP Neighbor on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_bgp_neighbor_with_http_info(logical_router_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: BgpNeighbor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_bgp_neighbor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_bgp_neighbor`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `read_bgp_neighbor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/neighbors/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpNeighbor',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_debug_info_text(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the debug information for the logical router  # noqa: E501

        API to download below information as text which will be used for debugging and troubleshooting. 1) Logical router sub-components and ports. 2) Routing configuration as sent to central control plane. 3) TIER1 advertised network information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_debug_info_text(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_debug_info_text_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_debug_info_text_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def read_debug_info_text_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the debug information for the logical router  # noqa: E501

        API to download below information as text which will be used for debugging and troubleshooting. 1) Logical router sub-components and ports. 2) Routing configuration as sent to central control plane. 3) TIER1 advertised network information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_debug_info_text_with_http_info(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_debug_info_text" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_debug_info_text`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain; charset=utf-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/debug-info?format=text', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_dhcp_relay(self, relay_id, **kwargs):  # noqa: E501
        """Read a DHCP Relay Service  # noqa: E501

        Returns the dhcp relay service information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_dhcp_relay(relay_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str relay_id: (required)
        :return: DhcpRelayService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_dhcp_relay_with_http_info(relay_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_dhcp_relay_with_http_info(relay_id, **kwargs)  # noqa: E501
            return data

    def read_dhcp_relay_with_http_info(self, relay_id, **kwargs):  # noqa: E501
        """Read a DHCP Relay Service  # noqa: E501

        Returns the dhcp relay service information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_dhcp_relay_with_http_info(relay_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str relay_id: (required)
        :return: DhcpRelayService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['relay_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_dhcp_relay" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'relay_id' is set
        if ('relay_id' not in params or
                params['relay_id'] is None):
            raise ValueError("Missing the required parameter `relay_id` when calling `read_dhcp_relay`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'relay_id' in params:
            path_params['relay-id'] = params['relay_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/relays/{relay-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpRelayService',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_dhcp_relay_profile(self, relay_profile_id, **kwargs):  # noqa: E501
        """Read a DHCP Relay Profile  # noqa: E501

        Returns information about the specified dhcp relay profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_dhcp_relay_profile(relay_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str relay_profile_id: (required)
        :return: DhcpRelayProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_dhcp_relay_profile_with_http_info(relay_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_dhcp_relay_profile_with_http_info(relay_profile_id, **kwargs)  # noqa: E501
            return data

    def read_dhcp_relay_profile_with_http_info(self, relay_profile_id, **kwargs):  # noqa: E501
        """Read a DHCP Relay Profile  # noqa: E501

        Returns information about the specified dhcp relay profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_dhcp_relay_profile_with_http_info(relay_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str relay_profile_id: (required)
        :return: DhcpRelayProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['relay_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_dhcp_relay_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'relay_profile_id' is set
        if ('relay_profile_id' not in params or
                params['relay_profile_id'] is None):
            raise ValueError("Missing the required parameter `relay_profile_id` when calling `read_dhcp_relay_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'relay_profile_id' in params:
            path_params['relay-profile-id'] = params['relay_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/relay-profiles/{relay-profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpRelayProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_ip_prefix_list(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Get a specific IPPrefixList on a Logical Router  # noqa: E501

        Read a specific IPPrefixList on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ip_prefix_list(logical_router_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: IPPrefixList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_ip_prefix_list_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_ip_prefix_list_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def read_ip_prefix_list_with_http_info(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Get a specific IPPrefixList on a Logical Router  # noqa: E501

        Read a specific IPPrefixList on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ip_prefix_list_with_http_info(logical_router_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: IPPrefixList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_ip_prefix_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_ip_prefix_list`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `read_ip_prefix_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/ip-prefix-lists/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IPPrefixList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_logical_router(self, logical_router_id, **kwargs):  # noqa: E501
        """Read Logical Router  # noqa: E501

        Returns information about the specified logical router.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_logical_router(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :return: LogicalRouter
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_logical_router_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_logical_router_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def read_logical_router_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Read Logical Router  # noqa: E501

        Returns information about the specified logical router.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_logical_router_with_http_info(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :return: LogicalRouter
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_logical_router" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_logical_router`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouter',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_logical_router_port(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Read Logical Router Port  # noqa: E501

        Returns information about the specified logical router port.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_logical_router_port(logical_router_port_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_port_id: (required)
        :return: LogicalRouterPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_logical_router_port_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_logical_router_port_with_http_info(logical_router_port_id, **kwargs)  # noqa: E501
            return data

    def read_logical_router_port_with_http_info(self, logical_router_port_id, **kwargs):  # noqa: E501
        """Read Logical Router Port  # noqa: E501

        Returns information about the specified logical router port.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_logical_router_port_with_http_info(logical_router_port_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_port_id: (required)
        :return: LogicalRouterPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_port_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_logical_router_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_port_id' is set
        if ('logical_router_port_id' not in params or
                params['logical_router_port_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_port_id` when calling `read_logical_router_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_port_id' in params:
            path_params['logical-router-port-id'] = params['logical_router_port_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-router-ports/{logical-router-port-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterPort',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_redistribution_config(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the Redistribution Configuration on a Logical Router  # noqa: E501

        Returns information about configured route redistribution for the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_redistribution_config(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :return: RedistributionConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_redistribution_config_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_redistribution_config_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def read_redistribution_config_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the Redistribution Configuration on a Logical Router  # noqa: E501

        Returns information about configured route redistribution for the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_redistribution_config_with_http_info(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :return: RedistributionConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_redistribution_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_redistribution_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/redistribution', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RedistributionConfig',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_redistribution_rule_list(self, logical_router_id, **kwargs):  # noqa: E501
        """Read All the Redistribution Rules on a Logical Router  # noqa: E501

        Returns all the route redistribution rules for the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_redistribution_rule_list(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :return: RedistributionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_redistribution_rule_list_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_redistribution_rule_list_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def read_redistribution_rule_list_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Read All the Redistribution Rules on a Logical Router  # noqa: E501

        Returns all the route redistribution rules for the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_redistribution_rule_list_with_http_info(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :return: RedistributionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_redistribution_rule_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_redistribution_rule_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/redistribution/rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RedistributionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_route_map(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Get a specific RouteMap on a Logical Router  # noqa: E501

        Read a specific RouteMap on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_route_map(logical_router_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: RouteMap
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_route_map_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_route_map_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def read_route_map_with_http_info(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Get a specific RouteMap on a Logical Router  # noqa: E501

        Read a specific RouteMap on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_route_map_with_http_info(logical_router_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: RouteMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_route_map" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_route_map`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `read_route_map`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/route-maps/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RouteMap',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_routing_bfd_config(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the Routing BFD Configuration  # noqa: E501

        Returns the BFD configuration for all routing BFD peers. This will be inherited |   by all BFD peers for LogicalRouter unless overriden while configuring the Peer.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_routing_bfd_config(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :return: BfdConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_routing_bfd_config_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_routing_bfd_config_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def read_routing_bfd_config_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the Routing BFD Configuration  # noqa: E501

        Returns the BFD configuration for all routing BFD peers. This will be inherited |   by all BFD peers for LogicalRouter unless overriden while configuring the Peer.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_routing_bfd_config_with_http_info(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :return: BfdConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_routing_bfd_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_routing_bfd_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bfd-config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BfdConfig',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_routing_config(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the Routing Configuration  # noqa: E501

        Returns the routing configuration for a specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_routing_config(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :return: RoutingConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_routing_config_with_http_info(logical_router_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_routing_config_with_http_info(logical_router_id, **kwargs)  # noqa: E501
            return data

    def read_routing_config_with_http_info(self, logical_router_id, **kwargs):  # noqa: E501
        """Read the Routing Configuration  # noqa: E501

        Returns the routing configuration for a specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_routing_config_with_http_info(logical_router_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :return: RoutingConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_routing_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_routing_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RoutingConfig',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_service(self, service_id, **kwargs):  # noqa: E501
        """Read a Logical Router Service  # noqa: E501

        Returns information about the specified service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_service(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :return: LogicalService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_service_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_service_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def read_service_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Read a Logical Router Service  # noqa: E501

        Returns information about the specified service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_service_with_http_info(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :return: LogicalService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `read_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/services/{service-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalService',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_service_profile(self, service_profile_id, **kwargs):  # noqa: E501
        """Read a Service Profile  # noqa: E501

        Returns information about the specified service profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_service_profile(service_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_profile_id: (required)
        :return: ServiceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_service_profile_with_http_info(service_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_service_profile_with_http_info(service_profile_id, **kwargs)  # noqa: E501
            return data

    def read_service_profile_with_http_info(self, service_profile_id, **kwargs):  # noqa: E501
        """Read a Service Profile  # noqa: E501

        Returns information about the specified service profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_service_profile_with_http_info(service_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_profile_id: (required)
        :return: ServiceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_service_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_profile_id' is set
        if ('service_profile_id' not in params or
                params['service_profile_id'] is None):
            raise ValueError("Missing the required parameter `service_profile_id` when calling `read_service_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_profile_id' in params:
            path_params['service-profile-id'] = params['service_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/service-profiles/{service-profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_static_hop_bfd_peer(self, logical_router_id, bfd_peer_id, **kwargs):  # noqa: E501
        """Read a static route BFD peer  # noqa: E501

        Read the BFD peer having specified ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_static_hop_bfd_peer(logical_router_id, bfd_peer_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str bfd_peer_id: (required)
        :return: StaticHopBfdPeer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_static_hop_bfd_peer_with_http_info(logical_router_id, bfd_peer_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_static_hop_bfd_peer_with_http_info(logical_router_id, bfd_peer_id, **kwargs)  # noqa: E501
            return data

    def read_static_hop_bfd_peer_with_http_info(self, logical_router_id, bfd_peer_id, **kwargs):  # noqa: E501
        """Read a static route BFD peer  # noqa: E501

        Read the BFD peer having specified ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_static_hop_bfd_peer_with_http_info(logical_router_id, bfd_peer_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str bfd_peer_id: (required)
        :return: StaticHopBfdPeer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'bfd_peer_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_static_hop_bfd_peer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_static_hop_bfd_peer`")  # noqa: E501
        # verify the required parameter 'bfd_peer_id' is set
        if ('bfd_peer_id' not in params or
                params['bfd_peer_id'] is None):
            raise ValueError("Missing the required parameter `bfd_peer_id` when calling `read_static_hop_bfd_peer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'bfd_peer_id' in params:
            path_params['bfd-peer-id'] = params['bfd_peer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/static-routes/bfd-peers/{bfd-peer-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StaticHopBfdPeer',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_static_route(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Get a specific Static Route on a Logical Router  # noqa: E501

        Read a specific static routes on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_static_route(logical_router_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: StaticRoute
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_static_route_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_static_route_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def read_static_route_with_http_info(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Get a specific Static Route on a Logical Router  # noqa: E501

        Read a specific static routes on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_static_route_with_http_info(logical_router_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :return: StaticRoute
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_static_route" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `read_static_route`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `read_static_route`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/static-routes/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StaticRoute',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def un_set_password_on_bgp_neighbor(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Unset/Delete password property on specific BGP Neighbor on Logical Router  # noqa: E501

        Unset/Delete the password property on the specific BGP Neighbor. No other property of the BgpNeighbor can be updated using this API   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.un_set_password_on_bgp_neighbor(logical_router_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :param str action:
        :return: BgpNeighbor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.un_set_password_on_bgp_neighbor_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.un_set_password_on_bgp_neighbor_with_http_info(logical_router_id, id, **kwargs)  # noqa: E501
            return data

    def un_set_password_on_bgp_neighbor_with_http_info(self, logical_router_id, id, **kwargs):  # noqa: E501
        """Unset/Delete password property on specific BGP Neighbor on Logical Router  # noqa: E501

        Unset/Delete the password property on the specific BGP Neighbor. No other property of the BgpNeighbor can be updated using this API   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.un_set_password_on_bgp_neighbor_with_http_info(logical_router_id, id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :param str action:
        :return: BgpNeighbor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id', 'action']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method un_set_password_on_bgp_neighbor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `un_set_password_on_bgp_neighbor`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `un_set_password_on_bgp_neighbor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/neighbors/{id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpNeighbor',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_advertise_rule_list(self, logical_router_id, advertise_rule_list, **kwargs):  # noqa: E501
        """Update the Advertisement Rules on a Logical Router  # noqa: E501

        Modifies the advertisement rules on the specified logical router. The PUT request must include all the rules with the networks parameter. Modifiable parameters are networks, display_name, and description. Set the rules list to empty to delete/clear all rules.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_advertise_rule_list(logical_router_id, advertise_rule_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param AdvertiseRuleList advertise_rule_list: (required)
        :return: AdvertiseRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_advertise_rule_list_with_http_info(logical_router_id, advertise_rule_list, **kwargs)  # noqa: E501
        else:
            (data) = self.update_advertise_rule_list_with_http_info(logical_router_id, advertise_rule_list, **kwargs)  # noqa: E501
            return data

    def update_advertise_rule_list_with_http_info(self, logical_router_id, advertise_rule_list, **kwargs):  # noqa: E501
        """Update the Advertisement Rules on a Logical Router  # noqa: E501

        Modifies the advertisement rules on the specified logical router. The PUT request must include all the rules with the networks parameter. Modifiable parameters are networks, display_name, and description. Set the rules list to empty to delete/clear all rules.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_advertise_rule_list_with_http_info(logical_router_id, advertise_rule_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param AdvertiseRuleList advertise_rule_list: (required)
        :return: AdvertiseRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'advertise_rule_list']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_advertise_rule_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_advertise_rule_list`")  # noqa: E501
        # verify the required parameter 'advertise_rule_list' is set
        if ('advertise_rule_list' not in params or
                params['advertise_rule_list'] is None):
            raise ValueError("Missing the required parameter `advertise_rule_list` when calling `update_advertise_rule_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'advertise_rule_list' in params:
            body_params = params['advertise_rule_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/advertisement/rules', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdvertiseRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_advertisement_config(self, logical_router_id, advertisement_config, **kwargs):  # noqa: E501
        """Update the Advertisement Configuration on a Logical Router  # noqa: E501

        Modifies the route advertisement configuration on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_advertisement_config(logical_router_id, advertisement_config, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param AdvertisementConfig advertisement_config: (required)
        :return: AdvertisementConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_advertisement_config_with_http_info(logical_router_id, advertisement_config, **kwargs)  # noqa: E501
        else:
            (data) = self.update_advertisement_config_with_http_info(logical_router_id, advertisement_config, **kwargs)  # noqa: E501
            return data

    def update_advertisement_config_with_http_info(self, logical_router_id, advertisement_config, **kwargs):  # noqa: E501
        """Update the Advertisement Configuration on a Logical Router  # noqa: E501

        Modifies the route advertisement configuration on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_advertisement_config_with_http_info(logical_router_id, advertisement_config, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param AdvertisementConfig advertisement_config: (required)
        :return: AdvertisementConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'advertisement_config']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_advertisement_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_advertisement_config`")  # noqa: E501
        # verify the required parameter 'advertisement_config' is set
        if ('advertisement_config' not in params or
                params['advertisement_config'] is None):
            raise ValueError("Missing the required parameter `advertisement_config` when calling `update_advertisement_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'advertisement_config' in params:
            body_params = params['advertisement_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/advertisement', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdvertisementConfig',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_bgp_config(self, logical_router_id, bgp_config, **kwargs):  # noqa: E501
        """Update the BGP Configuration on a Logical Router  # noqa: E501

        Modifies the BGP configuration on a specified TIER0 logical router. Modifiable parameters include enabled, graceful_restart, as_number.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_bgp_config(logical_router_id, bgp_config, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param BgpConfig bgp_config: (required)
        :return: BgpConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_bgp_config_with_http_info(logical_router_id, bgp_config, **kwargs)  # noqa: E501
        else:
            (data) = self.update_bgp_config_with_http_info(logical_router_id, bgp_config, **kwargs)  # noqa: E501
            return data

    def update_bgp_config_with_http_info(self, logical_router_id, bgp_config, **kwargs):  # noqa: E501
        """Update the BGP Configuration on a Logical Router  # noqa: E501

        Modifies the BGP configuration on a specified TIER0 logical router. Modifiable parameters include enabled, graceful_restart, as_number.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_bgp_config_with_http_info(logical_router_id, bgp_config, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param BgpConfig bgp_config: (required)
        :return: BgpConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'bgp_config']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_bgp_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_bgp_config`")  # noqa: E501
        # verify the required parameter 'bgp_config' is set
        if ('bgp_config' not in params or
                params['bgp_config'] is None):
            raise ValueError("Missing the required parameter `bgp_config` when calling `update_bgp_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bgp_config' in params:
            body_params = params['bgp_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpConfig',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_bgp_neighbor(self, logical_router_id, id, bgp_neighbor, **kwargs):  # noqa: E501
        """Update a specific BGP Neighbor on a Logical Router  # noqa: E501

        Update a specific BGP Neighbor on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_bgp_neighbor(logical_router_id, id, bgp_neighbor, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :param BgpNeighbor bgp_neighbor: (required)
        :return: BgpNeighbor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_bgp_neighbor_with_http_info(logical_router_id, id, bgp_neighbor, **kwargs)  # noqa: E501
        else:
            (data) = self.update_bgp_neighbor_with_http_info(logical_router_id, id, bgp_neighbor, **kwargs)  # noqa: E501
            return data

    def update_bgp_neighbor_with_http_info(self, logical_router_id, id, bgp_neighbor, **kwargs):  # noqa: E501
        """Update a specific BGP Neighbor on a Logical Router  # noqa: E501

        Update a specific BGP Neighbor on a Logical Router   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_bgp_neighbor_with_http_info(logical_router_id, id, bgp_neighbor, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :param BgpNeighbor bgp_neighbor: (required)
        :return: BgpNeighbor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id', 'bgp_neighbor']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_bgp_neighbor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_bgp_neighbor`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_bgp_neighbor`")  # noqa: E501
        # verify the required parameter 'bgp_neighbor' is set
        if ('bgp_neighbor' not in params or
                params['bgp_neighbor'] is None):
            raise ValueError("Missing the required parameter `bgp_neighbor` when calling `update_bgp_neighbor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bgp_neighbor' in params:
            body_params = params['bgp_neighbor']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bgp/neighbors/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BgpNeighbor',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dhcp_relay(self, relay_id, dhcp_relay_service, **kwargs):  # noqa: E501
        """Update a DHCP Relay Service  # noqa: E501

        Modifies the specified dhcp relay service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dhcp_relay(relay_id, dhcp_relay_service, async=True)
        >>> result = thread.get()

        :param async bool
        :param str relay_id: (required)
        :param DhcpRelayService dhcp_relay_service: (required)
        :return: DhcpRelayService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dhcp_relay_with_http_info(relay_id, dhcp_relay_service, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dhcp_relay_with_http_info(relay_id, dhcp_relay_service, **kwargs)  # noqa: E501
            return data

    def update_dhcp_relay_with_http_info(self, relay_id, dhcp_relay_service, **kwargs):  # noqa: E501
        """Update a DHCP Relay Service  # noqa: E501

        Modifies the specified dhcp relay service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dhcp_relay_with_http_info(relay_id, dhcp_relay_service, async=True)
        >>> result = thread.get()

        :param async bool
        :param str relay_id: (required)
        :param DhcpRelayService dhcp_relay_service: (required)
        :return: DhcpRelayService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['relay_id', 'dhcp_relay_service']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dhcp_relay" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'relay_id' is set
        if ('relay_id' not in params or
                params['relay_id'] is None):
            raise ValueError("Missing the required parameter `relay_id` when calling `update_dhcp_relay`")  # noqa: E501
        # verify the required parameter 'dhcp_relay_service' is set
        if ('dhcp_relay_service' not in params or
                params['dhcp_relay_service'] is None):
            raise ValueError("Missing the required parameter `dhcp_relay_service` when calling `update_dhcp_relay`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'relay_id' in params:
            path_params['relay-id'] = params['relay_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dhcp_relay_service' in params:
            body_params = params['dhcp_relay_service']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/relays/{relay-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpRelayService',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dhcp_relay_profile(self, relay_profile_id, dhcp_relay_profile, **kwargs):  # noqa: E501
        """Update a DHCP Relay Profile  # noqa: E501

        Modifies the specified dhcp relay profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dhcp_relay_profile(relay_profile_id, dhcp_relay_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str relay_profile_id: (required)
        :param DhcpRelayProfile dhcp_relay_profile: (required)
        :return: DhcpRelayProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dhcp_relay_profile_with_http_info(relay_profile_id, dhcp_relay_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dhcp_relay_profile_with_http_info(relay_profile_id, dhcp_relay_profile, **kwargs)  # noqa: E501
            return data

    def update_dhcp_relay_profile_with_http_info(self, relay_profile_id, dhcp_relay_profile, **kwargs):  # noqa: E501
        """Update a DHCP Relay Profile  # noqa: E501

        Modifies the specified dhcp relay profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dhcp_relay_profile_with_http_info(relay_profile_id, dhcp_relay_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str relay_profile_id: (required)
        :param DhcpRelayProfile dhcp_relay_profile: (required)
        :return: DhcpRelayProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['relay_profile_id', 'dhcp_relay_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dhcp_relay_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'relay_profile_id' is set
        if ('relay_profile_id' not in params or
                params['relay_profile_id'] is None):
            raise ValueError("Missing the required parameter `relay_profile_id` when calling `update_dhcp_relay_profile`")  # noqa: E501
        # verify the required parameter 'dhcp_relay_profile' is set
        if ('dhcp_relay_profile' not in params or
                params['dhcp_relay_profile'] is None):
            raise ValueError("Missing the required parameter `dhcp_relay_profile` when calling `update_dhcp_relay_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'relay_profile_id' in params:
            path_params['relay-profile-id'] = params['relay_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dhcp_relay_profile' in params:
            body_params = params['dhcp_relay_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/relay-profiles/{relay-profile-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpRelayProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ip_prefix_list(self, logical_router_id, id, ip_prefix_list, **kwargs):  # noqa: E501
        """Update a specific IPPrefixList on a Logical Router  # noqa: E501

        Update a specific IPPrefixList on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_ip_prefix_list(logical_router_id, id, ip_prefix_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :param IPPrefixList ip_prefix_list: (required)
        :return: IPPrefixList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_ip_prefix_list_with_http_info(logical_router_id, id, ip_prefix_list, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ip_prefix_list_with_http_info(logical_router_id, id, ip_prefix_list, **kwargs)  # noqa: E501
            return data

    def update_ip_prefix_list_with_http_info(self, logical_router_id, id, ip_prefix_list, **kwargs):  # noqa: E501
        """Update a specific IPPrefixList on a Logical Router  # noqa: E501

        Update a specific IPPrefixList on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_ip_prefix_list_with_http_info(logical_router_id, id, ip_prefix_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :param IPPrefixList ip_prefix_list: (required)
        :return: IPPrefixList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id', 'ip_prefix_list']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ip_prefix_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_ip_prefix_list`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_ip_prefix_list`")  # noqa: E501
        # verify the required parameter 'ip_prefix_list' is set
        if ('ip_prefix_list' not in params or
                params['ip_prefix_list'] is None):
            raise ValueError("Missing the required parameter `ip_prefix_list` when calling `update_ip_prefix_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ip_prefix_list' in params:
            body_params = params['ip_prefix_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/ip-prefix-lists/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IPPrefixList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_logical_router(self, logical_router_id, logical_router, **kwargs):  # noqa: E501
        """Update a Logical Router  # noqa: E501

        Modifies the specified logical router. Modifiable attributes include the internal_transit_network, external_transit_networks, and edge_cluster_id (for TIER0 routers).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_logical_router(logical_router_id, logical_router, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param LogicalRouter logical_router: (required)
        :return: LogicalRouter
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_logical_router_with_http_info(logical_router_id, logical_router, **kwargs)  # noqa: E501
        else:
            (data) = self.update_logical_router_with_http_info(logical_router_id, logical_router, **kwargs)  # noqa: E501
            return data

    def update_logical_router_with_http_info(self, logical_router_id, logical_router, **kwargs):  # noqa: E501
        """Update a Logical Router  # noqa: E501

        Modifies the specified logical router. Modifiable attributes include the internal_transit_network, external_transit_networks, and edge_cluster_id (for TIER0 routers).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_logical_router_with_http_info(logical_router_id, logical_router, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param LogicalRouter logical_router: (required)
        :return: LogicalRouter
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'logical_router']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_logical_router" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_logical_router`")  # noqa: E501
        # verify the required parameter 'logical_router' is set
        if ('logical_router' not in params or
                params['logical_router'] is None):
            raise ValueError("Missing the required parameter `logical_router` when calling `update_logical_router`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'logical_router' in params:
            body_params = params['logical_router']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouter',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_logical_router_port(self, logical_router_port_id, logical_router_port, **kwargs):  # noqa: E501
        """Update a Logical Router Port  # noqa: E501

        Modifies the specified logical router port. Required parameters include the resource_type and logical_router_id. Modifiable parameters include the resource_type (LogicalRouterUpLinkPort, LogicalRouterDownLinkPort, LogicalRouterLinkPort, LogicalRouterLoopbackPort), logical_router_id (to reassign the port to a different router), and service_bindings.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_logical_router_port(logical_router_port_id, logical_router_port, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_port_id: (required)
        :param LogicalRouterPort logical_router_port: (required)
        :return: LogicalRouterPort
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_logical_router_port_with_http_info(logical_router_port_id, logical_router_port, **kwargs)  # noqa: E501
        else:
            (data) = self.update_logical_router_port_with_http_info(logical_router_port_id, logical_router_port, **kwargs)  # noqa: E501
            return data

    def update_logical_router_port_with_http_info(self, logical_router_port_id, logical_router_port, **kwargs):  # noqa: E501
        """Update a Logical Router Port  # noqa: E501

        Modifies the specified logical router port. Required parameters include the resource_type and logical_router_id. Modifiable parameters include the resource_type (LogicalRouterUpLinkPort, LogicalRouterDownLinkPort, LogicalRouterLinkPort, LogicalRouterLoopbackPort), logical_router_id (to reassign the port to a different router), and service_bindings.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_logical_router_port_with_http_info(logical_router_port_id, logical_router_port, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_port_id: (required)
        :param LogicalRouterPort logical_router_port: (required)
        :return: LogicalRouterPort
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_port_id', 'logical_router_port']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_logical_router_port" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_port_id' is set
        if ('logical_router_port_id' not in params or
                params['logical_router_port_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_port_id` when calling `update_logical_router_port`")  # noqa: E501
        # verify the required parameter 'logical_router_port' is set
        if ('logical_router_port' not in params or
                params['logical_router_port'] is None):
            raise ValueError("Missing the required parameter `logical_router_port` when calling `update_logical_router_port`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_port_id' in params:
            path_params['logical-router-port-id'] = params['logical_router_port_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'logical_router_port' in params:
            body_params = params['logical_router_port']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-router-ports/{logical-router-port-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalRouterPort',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_nat_rule(self, logical_router_id, rule_id, nat_rule, **kwargs):  # noqa: E501
        """Update a specific NAT rule from a given logical router  # noqa: E501

        Update a specific NAT rule from a given logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_nat_rule(logical_router_id, rule_id, nat_rule, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str rule_id: (required)
        :param NatRule nat_rule: (required)
        :return: NatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_nat_rule_with_http_info(logical_router_id, rule_id, nat_rule, **kwargs)  # noqa: E501
        else:
            (data) = self.update_nat_rule_with_http_info(logical_router_id, rule_id, nat_rule, **kwargs)  # noqa: E501
            return data

    def update_nat_rule_with_http_info(self, logical_router_id, rule_id, nat_rule, **kwargs):  # noqa: E501
        """Update a specific NAT rule from a given logical router  # noqa: E501

        Update a specific NAT rule from a given logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_nat_rule_with_http_info(logical_router_id, rule_id, nat_rule, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str rule_id: (required)
        :param NatRule nat_rule: (required)
        :return: NatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'rule_id', 'nat_rule']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_nat_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_nat_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `update_nat_rule`")  # noqa: E501
        # verify the required parameter 'nat_rule' is set
        if ('nat_rule' not in params or
                params['nat_rule'] is None):
            raise ValueError("Missing the required parameter `nat_rule` when calling `update_nat_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'nat_rule' in params:
            body_params = params['nat_rule']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/nat/rules/{rule-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NatRule',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_redistribution_config(self, logical_router_id, redistribution_config, **kwargs):  # noqa: E501
        """Update the Redistribution Configuration on a Logical Router  # noqa: E501

        Modifies existing route redistribution rules for the specified TIER0 logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_redistribution_config(logical_router_id, redistribution_config, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param RedistributionConfig redistribution_config: (required)
        :return: RedistributionConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_redistribution_config_with_http_info(logical_router_id, redistribution_config, **kwargs)  # noqa: E501
        else:
            (data) = self.update_redistribution_config_with_http_info(logical_router_id, redistribution_config, **kwargs)  # noqa: E501
            return data

    def update_redistribution_config_with_http_info(self, logical_router_id, redistribution_config, **kwargs):  # noqa: E501
        """Update the Redistribution Configuration on a Logical Router  # noqa: E501

        Modifies existing route redistribution rules for the specified TIER0 logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_redistribution_config_with_http_info(logical_router_id, redistribution_config, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param RedistributionConfig redistribution_config: (required)
        :return: RedistributionConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'redistribution_config']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_redistribution_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_redistribution_config`")  # noqa: E501
        # verify the required parameter 'redistribution_config' is set
        if ('redistribution_config' not in params or
                params['redistribution_config'] is None):
            raise ValueError("Missing the required parameter `redistribution_config` when calling `update_redistribution_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'redistribution_config' in params:
            body_params = params['redistribution_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/redistribution', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RedistributionConfig',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_redistribution_rule_list(self, logical_router_id, redistribution_rule_list, **kwargs):  # noqa: E501
        """Update All the Redistribution Rules on a Logical Router  # noqa: E501

        Modifies all route redistribution rules for the specified TIER0 logical router. Set the rules list to empty to delete/clear all rules.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_redistribution_rule_list(logical_router_id, redistribution_rule_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param RedistributionRuleList redistribution_rule_list: (required)
        :return: RedistributionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_redistribution_rule_list_with_http_info(logical_router_id, redistribution_rule_list, **kwargs)  # noqa: E501
        else:
            (data) = self.update_redistribution_rule_list_with_http_info(logical_router_id, redistribution_rule_list, **kwargs)  # noqa: E501
            return data

    def update_redistribution_rule_list_with_http_info(self, logical_router_id, redistribution_rule_list, **kwargs):  # noqa: E501
        """Update All the Redistribution Rules on a Logical Router  # noqa: E501

        Modifies all route redistribution rules for the specified TIER0 logical router. Set the rules list to empty to delete/clear all rules.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_redistribution_rule_list_with_http_info(logical_router_id, redistribution_rule_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param RedistributionRuleList redistribution_rule_list: (required)
        :return: RedistributionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'redistribution_rule_list']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_redistribution_rule_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_redistribution_rule_list`")  # noqa: E501
        # verify the required parameter 'redistribution_rule_list' is set
        if ('redistribution_rule_list' not in params or
                params['redistribution_rule_list'] is None):
            raise ValueError("Missing the required parameter `redistribution_rule_list` when calling `update_redistribution_rule_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'redistribution_rule_list' in params:
            body_params = params['redistribution_rule_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/redistribution/rules', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RedistributionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_route_map(self, logical_router_id, id, route_map, **kwargs):  # noqa: E501
        """Update a specific RouteMap on a Logical Router  # noqa: E501

        Update a specific RouteMap on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_route_map(logical_router_id, id, route_map, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :param RouteMap route_map: (required)
        :return: RouteMap
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_route_map_with_http_info(logical_router_id, id, route_map, **kwargs)  # noqa: E501
        else:
            (data) = self.update_route_map_with_http_info(logical_router_id, id, route_map, **kwargs)  # noqa: E501
            return data

    def update_route_map_with_http_info(self, logical_router_id, id, route_map, **kwargs):  # noqa: E501
        """Update a specific RouteMap on a Logical Router  # noqa: E501

        Update a specific RouteMap on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_route_map_with_http_info(logical_router_id, id, route_map, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :param RouteMap route_map: (required)
        :return: RouteMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id', 'route_map']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_route_map" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_route_map`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_route_map`")  # noqa: E501
        # verify the required parameter 'route_map' is set
        if ('route_map' not in params or
                params['route_map'] is None):
            raise ValueError("Missing the required parameter `route_map` when calling `update_route_map`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'route_map' in params:
            body_params = params['route_map']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/route-maps/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RouteMap',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_routing_bfd_config(self, logical_router_id, bfd_config, **kwargs):  # noqa: E501
        """Update the BFD Configuration for BFD peers for routing  # noqa: E501

        Modifies the BFD configuration for routing BFD peers. Note - the configuration |   changes apply only to those routing BFD peers for which the BFD configuration has |   not been overridden at Peer level.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_routing_bfd_config(logical_router_id, bfd_config, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param BfdConfig bfd_config: (required)
        :return: BfdConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_routing_bfd_config_with_http_info(logical_router_id, bfd_config, **kwargs)  # noqa: E501
        else:
            (data) = self.update_routing_bfd_config_with_http_info(logical_router_id, bfd_config, **kwargs)  # noqa: E501
            return data

    def update_routing_bfd_config_with_http_info(self, logical_router_id, bfd_config, **kwargs):  # noqa: E501
        """Update the BFD Configuration for BFD peers for routing  # noqa: E501

        Modifies the BFD configuration for routing BFD peers. Note - the configuration |   changes apply only to those routing BFD peers for which the BFD configuration has |   not been overridden at Peer level.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_routing_bfd_config_with_http_info(logical_router_id, bfd_config, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param BfdConfig bfd_config: (required)
        :return: BfdConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'bfd_config']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_routing_bfd_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_routing_bfd_config`")  # noqa: E501
        # verify the required parameter 'bfd_config' is set
        if ('bfd_config' not in params or
                params['bfd_config'] is None):
            raise ValueError("Missing the required parameter `bfd_config` when calling `update_routing_bfd_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bfd_config' in params:
            body_params = params['bfd_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/bfd-config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BfdConfig',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_routing_config(self, logical_router_id, routing_config, **kwargs):  # noqa: E501
        """Update the Routing Configuration  # noqa: E501

        Modifies the routing configuration for a specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_routing_config(logical_router_id, routing_config, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param RoutingConfig routing_config: (required)
        :return: RoutingConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_routing_config_with_http_info(logical_router_id, routing_config, **kwargs)  # noqa: E501
        else:
            (data) = self.update_routing_config_with_http_info(logical_router_id, routing_config, **kwargs)  # noqa: E501
            return data

    def update_routing_config_with_http_info(self, logical_router_id, routing_config, **kwargs):  # noqa: E501
        """Update the Routing Configuration  # noqa: E501

        Modifies the routing configuration for a specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_routing_config_with_http_info(logical_router_id, routing_config, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param RoutingConfig routing_config: (required)
        :return: RoutingConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'routing_config']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_routing_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_routing_config`")  # noqa: E501
        # verify the required parameter 'routing_config' is set
        if ('routing_config' not in params or
                params['routing_config'] is None):
            raise ValueError("Missing the required parameter `routing_config` when calling `update_routing_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'routing_config' in params:
            body_params = params['routing_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RoutingConfig',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_service(self, service_id, logical_service, **kwargs):  # noqa: E501
        """Update a Logical Router Service  # noqa: E501

        Modifies the specified logical router service. The resource_type parameter is required. The modifiable parameters depend on the service type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_service(service_id, logical_service, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param LogicalService logical_service: (required)
        :return: LogicalService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_service_with_http_info(service_id, logical_service, **kwargs)  # noqa: E501
        else:
            (data) = self.update_service_with_http_info(service_id, logical_service, **kwargs)  # noqa: E501
            return data

    def update_service_with_http_info(self, service_id, logical_service, **kwargs):  # noqa: E501
        """Update a Logical Router Service  # noqa: E501

        Modifies the specified logical router service. The resource_type parameter is required. The modifiable parameters depend on the service type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_service_with_http_info(service_id, logical_service, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param LogicalService logical_service: (required)
        :return: LogicalService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'logical_service']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `update_service`")  # noqa: E501
        # verify the required parameter 'logical_service' is set
        if ('logical_service' not in params or
                params['logical_service'] is None):
            raise ValueError("Missing the required parameter `logical_service` when calling `update_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'logical_service' in params:
            body_params = params['logical_service']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/services/{service-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalService',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_service_profile(self, service_profile_id, service_profile, **kwargs):  # noqa: E501
        """Update a Service Profile  # noqa: E501

        Modifies the specified service profile. The PUT request must include the resource_type parameters. Modifiable parameters include description and display_name. Other parameters might be modifiable, depending on the specified service type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_service_profile(service_profile_id, service_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_profile_id: (required)
        :param ServiceProfile service_profile: (required)
        :return: ServiceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_service_profile_with_http_info(service_profile_id, service_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.update_service_profile_with_http_info(service_profile_id, service_profile, **kwargs)  # noqa: E501
            return data

    def update_service_profile_with_http_info(self, service_profile_id, service_profile, **kwargs):  # noqa: E501
        """Update a Service Profile  # noqa: E501

        Modifies the specified service profile. The PUT request must include the resource_type parameters. Modifiable parameters include description and display_name. Other parameters might be modifiable, depending on the specified service type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_service_profile_with_http_info(service_profile_id, service_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_profile_id: (required)
        :param ServiceProfile service_profile: (required)
        :return: ServiceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_profile_id', 'service_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_service_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_profile_id' is set
        if ('service_profile_id' not in params or
                params['service_profile_id'] is None):
            raise ValueError("Missing the required parameter `service_profile_id` when calling `update_service_profile`")  # noqa: E501
        # verify the required parameter 'service_profile' is set
        if ('service_profile' not in params or
                params['service_profile'] is None):
            raise ValueError("Missing the required parameter `service_profile` when calling `update_service_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_profile_id' in params:
            path_params['service-profile-id'] = params['service_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'service_profile' in params:
            body_params = params['service_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/service-profiles/{service-profile-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_static_hop_bfd_peer(self, logical_router_id, bfd_peer_id, static_hop_bfd_peer, **kwargs):  # noqa: E501
        """Update a static route BFD peer  # noqa: E501

        Modifies the static route BFD peer. Modifiable parameters includes peer IP, enable flag and configuration of the BFD peer.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_static_hop_bfd_peer(logical_router_id, bfd_peer_id, static_hop_bfd_peer, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str bfd_peer_id: (required)
        :param StaticHopBfdPeer static_hop_bfd_peer: (required)
        :return: StaticHopBfdPeer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_static_hop_bfd_peer_with_http_info(logical_router_id, bfd_peer_id, static_hop_bfd_peer, **kwargs)  # noqa: E501
        else:
            (data) = self.update_static_hop_bfd_peer_with_http_info(logical_router_id, bfd_peer_id, static_hop_bfd_peer, **kwargs)  # noqa: E501
            return data

    def update_static_hop_bfd_peer_with_http_info(self, logical_router_id, bfd_peer_id, static_hop_bfd_peer, **kwargs):  # noqa: E501
        """Update a static route BFD peer  # noqa: E501

        Modifies the static route BFD peer. Modifiable parameters includes peer IP, enable flag and configuration of the BFD peer.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_static_hop_bfd_peer_with_http_info(logical_router_id, bfd_peer_id, static_hop_bfd_peer, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str bfd_peer_id: (required)
        :param StaticHopBfdPeer static_hop_bfd_peer: (required)
        :return: StaticHopBfdPeer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'bfd_peer_id', 'static_hop_bfd_peer']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_static_hop_bfd_peer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_static_hop_bfd_peer`")  # noqa: E501
        # verify the required parameter 'bfd_peer_id' is set
        if ('bfd_peer_id' not in params or
                params['bfd_peer_id'] is None):
            raise ValueError("Missing the required parameter `bfd_peer_id` when calling `update_static_hop_bfd_peer`")  # noqa: E501
        # verify the required parameter 'static_hop_bfd_peer' is set
        if ('static_hop_bfd_peer' not in params or
                params['static_hop_bfd_peer'] is None):
            raise ValueError("Missing the required parameter `static_hop_bfd_peer` when calling `update_static_hop_bfd_peer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'bfd_peer_id' in params:
            path_params['bfd-peer-id'] = params['bfd_peer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'static_hop_bfd_peer' in params:
            body_params = params['static_hop_bfd_peer']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/static-routes/bfd-peers/{bfd-peer-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StaticHopBfdPeer',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_static_route(self, logical_router_id, id, static_route, **kwargs):  # noqa: E501
        """Update a specific Static Route Rule on a Logical Router  # noqa: E501

        Update a specific static route on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_static_route(logical_router_id, id, static_route, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :param StaticRoute static_route: (required)
        :return: StaticRoute
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_static_route_with_http_info(logical_router_id, id, static_route, **kwargs)  # noqa: E501
        else:
            (data) = self.update_static_route_with_http_info(logical_router_id, id, static_route, **kwargs)  # noqa: E501
            return data

    def update_static_route_with_http_info(self, logical_router_id, id, static_route, **kwargs):  # noqa: E501
        """Update a specific Static Route Rule on a Logical Router  # noqa: E501

        Update a specific static route on the specified logical router.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_static_route_with_http_info(logical_router_id, id, static_route, async=True)
        >>> result = thread.get()

        :param async bool
        :param str logical_router_id: (required)
        :param str id: (required)
        :param StaticRoute static_route: (required)
        :return: StaticRoute
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_router_id', 'id', 'static_route']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_static_route" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_router_id' is set
        if ('logical_router_id' not in params or
                params['logical_router_id'] is None):
            raise ValueError("Missing the required parameter `logical_router_id` when calling `update_static_route`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_static_route`")  # noqa: E501
        # verify the required parameter 'static_route' is set
        if ('static_route' not in params or
                params['static_route'] is None):
            raise ValueError("Missing the required parameter `static_route` when calling `update_static_route`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logical_router_id' in params:
            path_params['logical-router-id'] = params['logical_router_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'static_route' in params:
            body_params = params['static_route']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logical-routers/{logical-router-id}/routing/static-routes/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StaticRoute',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
