# coding: utf-8

"""
    NSX API

    VMware NSX REST API  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class GroupingObjectsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_mac_address(self, mac_set_id, mac_address_element, **kwargs):  # noqa: E501
        """Add a MAC address to a MACSet  # noqa: E501

        Add an individual MAC address to a MACSet   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_mac_address(mac_set_id, mac_address_element, async=True)
        >>> result = thread.get()

        :param async bool
        :param str mac_set_id: MAC Set Id (required)
        :param MACAddressElement mac_address_element: (required)
        :return: MACAddressElement
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_mac_address_with_http_info(mac_set_id, mac_address_element, **kwargs)  # noqa: E501
        else:
            (data) = self.add_mac_address_with_http_info(mac_set_id, mac_address_element, **kwargs)  # noqa: E501
            return data

    def add_mac_address_with_http_info(self, mac_set_id, mac_address_element, **kwargs):  # noqa: E501
        """Add a MAC address to a MACSet  # noqa: E501

        Add an individual MAC address to a MACSet   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_mac_address_with_http_info(mac_set_id, mac_address_element, async=True)
        >>> result = thread.get()

        :param async bool
        :param str mac_set_id: MAC Set Id (required)
        :param MACAddressElement mac_address_element: (required)
        :return: MACAddressElement
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mac_set_id', 'mac_address_element']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_mac_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mac_set_id' is set
        if ('mac_set_id' not in params or
                params['mac_set_id'] is None):
            raise ValueError("Missing the required parameter `mac_set_id` when calling `add_mac_address`")  # noqa: E501
        # verify the required parameter 'mac_address_element' is set
        if ('mac_address_element' not in params or
                params['mac_address_element'] is None):
            raise ValueError("Missing the required parameter `mac_address_element` when calling `add_mac_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mac_set_id' in params:
            path_params['mac-set-id'] = params['mac_set_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'mac_address_element' in params:
            body_params = params['mac_address_element']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/mac-sets/{mac-set-id}/members', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MACAddressElement',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_or_remove_ns_group_expression(self, ns_group_id, ns_group_expression_list, action, **kwargs):  # noqa: E501
        """Add NSGroup expression  # noqa: E501

        Add/remove the expressions passed in the request body to/from the NSGroup   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_or_remove_ns_group_expression(ns_group_id, ns_group_expression_list, action, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_group_id: NSGroup Id (required)
        :param NSGroupExpressionList ns_group_expression_list: (required)
        :param str action: Specifies addition or removal action (required)
        :return: NSGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_or_remove_ns_group_expression_with_http_info(ns_group_id, ns_group_expression_list, action, **kwargs)  # noqa: E501
        else:
            (data) = self.add_or_remove_ns_group_expression_with_http_info(ns_group_id, ns_group_expression_list, action, **kwargs)  # noqa: E501
            return data

    def add_or_remove_ns_group_expression_with_http_info(self, ns_group_id, ns_group_expression_list, action, **kwargs):  # noqa: E501
        """Add NSGroup expression  # noqa: E501

        Add/remove the expressions passed in the request body to/from the NSGroup   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_or_remove_ns_group_expression_with_http_info(ns_group_id, ns_group_expression_list, action, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_group_id: NSGroup Id (required)
        :param NSGroupExpressionList ns_group_expression_list: (required)
        :param str action: Specifies addition or removal action (required)
        :return: NSGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'ns_group_expression_list', 'action']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_or_remove_ns_group_expression" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `add_or_remove_ns_group_expression`")  # noqa: E501
        # verify the required parameter 'ns_group_expression_list' is set
        if ('ns_group_expression_list' not in params or
                params['ns_group_expression_list'] is None):
            raise ValueError("Missing the required parameter `ns_group_expression_list` when calling `add_or_remove_ns_group_expression`")  # noqa: E501
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `add_or_remove_ns_group_expression`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ns_group_expression_list' in params:
            body_params = params['ns_group_expression_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NSGroup',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ip_set(self, ip_set, **kwargs):  # noqa: E501
        """Create IPSet  # noqa: E501

        Creates a new IPSet that can group either IPv4 or IPv6 individual ip addresses, ranges or subnets.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ip_set(ip_set, async=True)
        >>> result = thread.get()

        :param async bool
        :param IPSet ip_set: (required)
        :return: IPSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_ip_set_with_http_info(ip_set, **kwargs)  # noqa: E501
        else:
            (data) = self.create_ip_set_with_http_info(ip_set, **kwargs)  # noqa: E501
            return data

    def create_ip_set_with_http_info(self, ip_set, **kwargs):  # noqa: E501
        """Create IPSet  # noqa: E501

        Creates a new IPSet that can group either IPv4 or IPv6 individual ip addresses, ranges or subnets.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ip_set_with_http_info(ip_set, async=True)
        >>> result = thread.get()

        :param async bool
        :param IPSet ip_set: (required)
        :return: IPSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ip_set']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ip_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ip_set' is set
        if ('ip_set' not in params or
                params['ip_set'] is None):
            raise ValueError("Missing the required parameter `ip_set` when calling `create_ip_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ip_set' in params:
            body_params = params['ip_set']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ip-sets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IPSet',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_mac_set(self, mac_set, **kwargs):  # noqa: E501
        """Create MACSet  # noqa: E501

        Creates a new MACSet that can group individual MAC addresses.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_mac_set(mac_set, async=True)
        >>> result = thread.get()

        :param async bool
        :param MACSet mac_set: (required)
        :return: MACSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_mac_set_with_http_info(mac_set, **kwargs)  # noqa: E501
        else:
            (data) = self.create_mac_set_with_http_info(mac_set, **kwargs)  # noqa: E501
            return data

    def create_mac_set_with_http_info(self, mac_set, **kwargs):  # noqa: E501
        """Create MACSet  # noqa: E501

        Creates a new MACSet that can group individual MAC addresses.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_mac_set_with_http_info(mac_set, async=True)
        >>> result = thread.get()

        :param async bool
        :param MACSet mac_set: (required)
        :return: MACSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mac_set']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_mac_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mac_set' is set
        if ('mac_set' not in params or
                params['mac_set'] is None):
            raise ValueError("Missing the required parameter `mac_set` when calling `create_mac_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'mac_set' in params:
            body_params = params['mac_set']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/mac-sets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MACSet',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ns_group(self, ns_group, **kwargs):  # noqa: E501
        """Create NSGroup  # noqa: E501

        Creates a new NSGroup that can group NSX resources - VIFs, Lports and LSwitches as well as the grouping objects - IPSet, MACSet and other NSGroups   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ns_group(ns_group, async=True)
        >>> result = thread.get()

        :param async bool
        :param NSGroup ns_group: (required)
        :return: NSGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_ns_group_with_http_info(ns_group, **kwargs)  # noqa: E501
        else:
            (data) = self.create_ns_group_with_http_info(ns_group, **kwargs)  # noqa: E501
            return data

    def create_ns_group_with_http_info(self, ns_group, **kwargs):  # noqa: E501
        """Create NSGroup  # noqa: E501

        Creates a new NSGroup that can group NSX resources - VIFs, Lports and LSwitches as well as the grouping objects - IPSet, MACSet and other NSGroups   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ns_group_with_http_info(ns_group, async=True)
        >>> result = thread.get()

        :param async bool
        :param NSGroup ns_group: (required)
        :return: NSGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ns_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group' is set
        if ('ns_group' not in params or
                params['ns_group'] is None):
            raise ValueError("Missing the required parameter `ns_group` when calling `create_ns_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ns_group' in params:
            body_params = params['ns_group']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NSGroup',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ns_service(self, ns_service, **kwargs):  # noqa: E501
        """Create NSService  # noqa: E501

        Creates a new NSService which allows users to specify characteristics to use for matching network traffic.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ns_service(ns_service, async=True)
        >>> result = thread.get()

        :param async bool
        :param NSService ns_service: (required)
        :return: NSService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_ns_service_with_http_info(ns_service, **kwargs)  # noqa: E501
        else:
            (data) = self.create_ns_service_with_http_info(ns_service, **kwargs)  # noqa: E501
            return data

    def create_ns_service_with_http_info(self, ns_service, **kwargs):  # noqa: E501
        """Create NSService  # noqa: E501

        Creates a new NSService which allows users to specify characteristics to use for matching network traffic.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ns_service_with_http_info(ns_service, async=True)
        >>> result = thread.get()

        :param async bool
        :param NSService ns_service: (required)
        :return: NSService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_service']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ns_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_service' is set
        if ('ns_service' not in params or
                params['ns_service'] is None):
            raise ValueError("Missing the required parameter `ns_service` when calling `create_ns_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ns_service' in params:
            body_params = params['ns_service']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-services', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NSService',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ns_service_group(self, ns_service_group, **kwargs):  # noqa: E501
        """Create NSServiceGroup  # noqa: E501

        Creates a new NSServiceGroup which can contain NSServices. A given NSServiceGroup can contain either only ether type of NSServices or only non-ether type of NSServices, i.e. an NSServiceGroup cannot contain a mix of both ether and non-ether types of NSServices.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ns_service_group(ns_service_group, async=True)
        >>> result = thread.get()

        :param async bool
        :param NSServiceGroup ns_service_group: (required)
        :return: NSServiceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_ns_service_group_with_http_info(ns_service_group, **kwargs)  # noqa: E501
        else:
            (data) = self.create_ns_service_group_with_http_info(ns_service_group, **kwargs)  # noqa: E501
            return data

    def create_ns_service_group_with_http_info(self, ns_service_group, **kwargs):  # noqa: E501
        """Create NSServiceGroup  # noqa: E501

        Creates a new NSServiceGroup which can contain NSServices. A given NSServiceGroup can contain either only ether type of NSServices or only non-ether type of NSServices, i.e. an NSServiceGroup cannot contain a mix of both ether and non-ether types of NSServices.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ns_service_group_with_http_info(ns_service_group, async=True)
        >>> result = thread.get()

        :param async bool
        :param NSServiceGroup ns_service_group: (required)
        :return: NSServiceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_service_group']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ns_service_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_service_group' is set
        if ('ns_service_group' not in params or
                params['ns_service_group'] is None):
            raise ValueError("Missing the required parameter `ns_service_group` when calling `create_ns_service_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ns_service_group' in params:
            body_params = params['ns_service_group']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-service-groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NSServiceGroup',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ip_set(self, ip_set_id, **kwargs):  # noqa: E501
        """Delete IPSet  # noqa: E501

        Deletes the specified IPSet.  By default, if the IPSet is added to an NSGroup, it won't be deleted. In such situations, pass \"force=true\" as query param to force delete the IPSet.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_ip_set(ip_set_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ip_set_id: IPSet Id (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_ip_set_with_http_info(ip_set_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ip_set_with_http_info(ip_set_id, **kwargs)  # noqa: E501
            return data

    def delete_ip_set_with_http_info(self, ip_set_id, **kwargs):  # noqa: E501
        """Delete IPSet  # noqa: E501

        Deletes the specified IPSet.  By default, if the IPSet is added to an NSGroup, it won't be deleted. In such situations, pass \"force=true\" as query param to force delete the IPSet.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_ip_set_with_http_info(ip_set_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ip_set_id: IPSet Id (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ip_set_id', 'force']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ip_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ip_set_id' is set
        if ('ip_set_id' not in params or
                params['ip_set_id'] is None):
            raise ValueError("Missing the required parameter `ip_set_id` when calling `delete_ip_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ip_set_id' in params:
            path_params['ip-set-id'] = params['ip_set_id']  # noqa: E501

        query_params = []
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ip-sets/{ip-set-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_mac_set(self, mac_set_id, **kwargs):  # noqa: E501
        """Delete MACSet  # noqa: E501

        Deletes the specified MACSet. By default, if the MACSet is added to an NSGroup, it won't be deleted. In such situations, pass \"force=true\" as query param to force delete the MACSet.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_mac_set(mac_set_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str mac_set_id: MACSet Id (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_mac_set_with_http_info(mac_set_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_mac_set_with_http_info(mac_set_id, **kwargs)  # noqa: E501
            return data

    def delete_mac_set_with_http_info(self, mac_set_id, **kwargs):  # noqa: E501
        """Delete MACSet  # noqa: E501

        Deletes the specified MACSet. By default, if the MACSet is added to an NSGroup, it won't be deleted. In such situations, pass \"force=true\" as query param to force delete the MACSet.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_mac_set_with_http_info(mac_set_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str mac_set_id: MACSet Id (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mac_set_id', 'force']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_mac_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mac_set_id' is set
        if ('mac_set_id' not in params or
                params['mac_set_id'] is None):
            raise ValueError("Missing the required parameter `mac_set_id` when calling `delete_mac_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mac_set_id' in params:
            path_params['mac-set-id'] = params['mac_set_id']  # noqa: E501

        query_params = []
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/mac-sets/{mac-set-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ns_group(self, ns_group_id, **kwargs):  # noqa: E501
        """Delete NSGroup  # noqa: E501

        Deletes the specified NSGroup. By default, if the NSGroup is added to another NSGroup, it won't be deleted. In such situations, pass \"force=true\" as query param to force delete the NSGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_ns_group(ns_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_group_id: NSGroup Id (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_ns_group_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ns_group_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def delete_ns_group_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Delete NSGroup  # noqa: E501

        Deletes the specified NSGroup. By default, if the NSGroup is added to another NSGroup, it won't be deleted. In such situations, pass \"force=true\" as query param to force delete the NSGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_ns_group_with_http_info(ns_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_group_id: NSGroup Id (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'force']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ns_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `delete_ns_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ns_service(self, ns_service_id, **kwargs):  # noqa: E501
        """Delete NSService  # noqa: E501

        Deletes the specified NSService. By default, if the NSService is being referred in an NSServiceGroup, it can't be deleted. In such situations, pass \"force=true\" as a parameter to force delete the NSService. System defined NSServices can't be deleted using \"force\" flag.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_ns_service(ns_service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_service_id: NSService Id (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_ns_service_with_http_info(ns_service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ns_service_with_http_info(ns_service_id, **kwargs)  # noqa: E501
            return data

    def delete_ns_service_with_http_info(self, ns_service_id, **kwargs):  # noqa: E501
        """Delete NSService  # noqa: E501

        Deletes the specified NSService. By default, if the NSService is being referred in an NSServiceGroup, it can't be deleted. In such situations, pass \"force=true\" as a parameter to force delete the NSService. System defined NSServices can't be deleted using \"force\" flag.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_ns_service_with_http_info(ns_service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_service_id: NSService Id (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_service_id', 'force']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ns_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_service_id' is set
        if ('ns_service_id' not in params or
                params['ns_service_id'] is None):
            raise ValueError("Missing the required parameter `ns_service_id` when calling `delete_ns_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_service_id' in params:
            path_params['ns-service-id'] = params['ns_service_id']  # noqa: E501

        query_params = []
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-services/{ns-service-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ns_service_group(self, ns_service_group_id, **kwargs):  # noqa: E501
        """Delete NSServiceGroup  # noqa: E501

        Deletes the specified NSServiceGroup. By default, if the NSServiceGroup is consumed in a Firewall rule, it won't get deleted. In such situations, pass \"force=true\" as query param to force delete the NSServiceGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_ns_service_group(ns_service_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_service_group_id: NSServiceGroup Id (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_ns_service_group_with_http_info(ns_service_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ns_service_group_with_http_info(ns_service_group_id, **kwargs)  # noqa: E501
            return data

    def delete_ns_service_group_with_http_info(self, ns_service_group_id, **kwargs):  # noqa: E501
        """Delete NSServiceGroup  # noqa: E501

        Deletes the specified NSServiceGroup. By default, if the NSServiceGroup is consumed in a Firewall rule, it won't get deleted. In such situations, pass \"force=true\" as query param to force delete the NSServiceGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_ns_service_group_with_http_info(ns_service_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_service_group_id: NSServiceGroup Id (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_service_group_id', 'force']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ns_service_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_service_group_id' is set
        if ('ns_service_group_id' not in params or
                params['ns_service_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_service_group_id` when calling `delete_ns_service_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_service_group_id' in params:
            path_params['ns-service-group-id'] = params['ns_service_group_id']  # noqa: E501

        query_params = []
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-service-groups/{ns-service-group-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_effective_ip_address_members(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective IPAddress translated from the NSGroup  # noqa: E501

        Returns effective ip address members of the specified NSGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_effective_ip_address_members(ns_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveIPAddressMemberListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_effective_ip_address_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_effective_ip_address_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def get_effective_ip_address_members_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective IPAddress translated from the NSGroup  # noqa: E501

        Returns effective ip address members of the specified NSGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_effective_ip_address_members_with_http_info(ns_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveIPAddressMemberListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_effective_ip_address_members" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `get_effective_ip_address_members`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_effective_ip_address_members`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_effective_ip_address_members`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}/effective-ip-address-members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EffectiveIPAddressMemberListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_effective_logical_port_members(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective Logical Ports translated from the NSgroup  # noqa: E501

        Returns effective logical port members of the specified NSGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_effective_logical_port_members(ns_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberResourceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_effective_logical_port_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_effective_logical_port_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def get_effective_logical_port_members_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective Logical Ports translated from the NSgroup  # noqa: E501

        Returns effective logical port members of the specified NSGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_effective_logical_port_members_with_http_info(ns_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberResourceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_effective_logical_port_members" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `get_effective_logical_port_members`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_effective_logical_port_members`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_effective_logical_port_members`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}/effective-logical-port-members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EffectiveMemberResourceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_effective_logical_switch_members(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective switch members translated from the NSGroup  # noqa: E501

        Returns effective logical switch members of the specified NSGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_effective_logical_switch_members(ns_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberResourceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_effective_logical_switch_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_effective_logical_switch_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def get_effective_logical_switch_members_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective switch members translated from the NSGroup  # noqa: E501

        Returns effective logical switch members of the specified NSGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_effective_logical_switch_members_with_http_info(ns_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberResourceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_effective_logical_switch_members" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `get_effective_logical_switch_members`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_effective_logical_switch_members`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_effective_logical_switch_members`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}/effective-logical-switch-members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EffectiveMemberResourceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_effective_virtual_machine_members(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective Virtual Machine members of the specified NSGroup.  # noqa: E501

        Returns effective virtual machine members of the specified NSGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_effective_virtual_machine_members(ns_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: VirtualMachineListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_effective_virtual_machine_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_effective_virtual_machine_members_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def get_effective_virtual_machine_members_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Get Effective Virtual Machine members of the specified NSGroup.  # noqa: E501

        Returns effective virtual machine members of the specified NSGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_effective_virtual_machine_members_with_http_info(ns_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: VirtualMachineListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_effective_virtual_machine_members" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `get_effective_virtual_machine_members`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_effective_virtual_machine_members`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_effective_virtual_machine_members`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}/effective-virtual-machine-members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VirtualMachineListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_mac_addresses(self, mac_set_id, **kwargs):  # noqa: E501
        """Get all MACAddresses in a MACSet  # noqa: E501

        List all MAC addresses in a MACSet   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_mac_addresses(mac_set_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str mac_set_id: MAC Set Id (required)
        :return: MACAddressElementListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_mac_addresses_with_http_info(mac_set_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_mac_addresses_with_http_info(mac_set_id, **kwargs)  # noqa: E501
            return data

    def get_mac_addresses_with_http_info(self, mac_set_id, **kwargs):  # noqa: E501
        """Get all MACAddresses in a MACSet  # noqa: E501

        List all MAC addresses in a MACSet   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_mac_addresses_with_http_info(mac_set_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str mac_set_id: MAC Set Id (required)
        :return: MACAddressElementListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mac_set_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_mac_addresses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mac_set_id' is set
        if ('mac_set_id' not in params or
                params['mac_set_id'] is None):
            raise ValueError("Missing the required parameter `mac_set_id` when calling `get_mac_addresses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mac_set_id' in params:
            path_params['mac-set-id'] = params['mac_set_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/mac-sets/{mac-set-id}/members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MACAddressElementListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_member_types(self, ns_group_id, **kwargs):  # noqa: E501
        """Get member types from NSGroup  # noqa: E501

        Returns member types for a specified NSGroup including child NSGroups. This considers static members and members added via membership criteria only   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_member_types(ns_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberTypeListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_member_types_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_member_types_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def get_member_types_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Get member types from NSGroup  # noqa: E501

        Returns member types for a specified NSGroup including child NSGroups. This considers static members and members added via membership criteria only   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_member_types_with_http_info(ns_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_group_id: NSGroup Id (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EffectiveMemberTypeListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_member_types" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `get_member_types`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_member_types`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_member_types`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}/member-types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EffectiveMemberTypeListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_associations(self, nsgroup_id, service_type, **kwargs):  # noqa: E501
        """Get services to which the given nsgroup belongs to   # noqa: E501

        Returns information about services that are associated with the given NSGroup. The service name is passed by service_type parameter   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_service_associations(nsgroup_id, service_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str nsgroup_id: (required)
        :param str service_type: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool fetch_parentgroup_associations: Fetch complete list of associated resources considering nesting 
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ServiceAssociationListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_service_associations_with_http_info(nsgroup_id, service_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_associations_with_http_info(nsgroup_id, service_type, **kwargs)  # noqa: E501
            return data

    def get_service_associations_with_http_info(self, nsgroup_id, service_type, **kwargs):  # noqa: E501
        """Get services to which the given nsgroup belongs to   # noqa: E501

        Returns information about services that are associated with the given NSGroup. The service name is passed by service_type parameter   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_service_associations_with_http_info(nsgroup_id, service_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str nsgroup_id: (required)
        :param str service_type: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool fetch_parentgroup_associations: Fetch complete list of associated resources considering nesting 
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ServiceAssociationListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['nsgroup_id', 'service_type', 'cursor', 'fetch_parentgroup_associations', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_associations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'nsgroup_id' is set
        if ('nsgroup_id' not in params or
                params['nsgroup_id'] is None):
            raise ValueError("Missing the required parameter `nsgroup_id` when calling `get_service_associations`")  # noqa: E501
        # verify the required parameter 'service_type' is set
        if ('service_type' not in params or
                params['service_type'] is None):
            raise ValueError("Missing the required parameter `service_type` when calling `get_service_associations`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_service_associations`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_service_associations`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'nsgroup_id' in params:
            path_params['nsgroup-id'] = params['nsgroup_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'fetch_parentgroup_associations' in params:
            query_params.append(('fetch_parentgroup_associations', params['fetch_parentgroup_associations']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'service_type' in params:
            query_params.append(('service_type', params['service_type']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{nsgroup-id}/service-associations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceAssociationListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_unassociated_virtual_machines(self, **kwargs):  # noqa: E501
        """Get the list of all the virtual machines that are not a part of any existing NSGroup.  # noqa: E501

        Get the list of all the virtual machines that are not a part of any existing NSGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_unassociated_virtual_machines(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str display_name: Display Name of the virtual machine
        :param str external_id: External id of the virtual machine
        :param str host_id: Id of the host where this vif is located
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: UnassociatedVMListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_unassociated_virtual_machines_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_unassociated_virtual_machines_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_unassociated_virtual_machines_with_http_info(self, **kwargs):  # noqa: E501
        """Get the list of all the virtual machines that are not a part of any existing NSGroup.  # noqa: E501

        Get the list of all the virtual machines that are not a part of any existing NSGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_unassociated_virtual_machines_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str display_name: Display Name of the virtual machine
        :param str external_id: External id of the virtual machine
        :param str host_id: Id of the host where this vif is located
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: UnassociatedVMListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'display_name', 'external_id', 'host_id', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_unassociated_virtual_machines" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_unassociated_virtual_machines`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_unassociated_virtual_machines`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'display_name' in params:
            query_params.append(('display_name', params['display_name']))  # noqa: E501
        if 'external_id' in params:
            query_params.append(('external_id', params['external_id']))  # noqa: E501
        if 'host_id' in params:
            query_params.append(('host_id', params['host_id']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/unassociated-virtual-machines', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UnassociatedVMListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_ip_sets(self, **kwargs):  # noqa: E501
        """List IPSets  # noqa: E501

        Returns paginated list of IPSets   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ip_sets(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: IPSetListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_ip_sets_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_ip_sets_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_ip_sets_with_http_info(self, **kwargs):  # noqa: E501
        """List IPSets  # noqa: E501

        Returns paginated list of IPSets   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ip_sets_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: IPSetListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_ip_sets" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ip_sets`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ip_sets`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ip-sets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IPSetListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_mac_sets(self, **kwargs):  # noqa: E501
        """List MACSets  # noqa: E501

        Returns paginated list of MACSets   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_mac_sets(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: MACSetListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_mac_sets_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_mac_sets_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_mac_sets_with_http_info(self, **kwargs):  # noqa: E501
        """List MACSets  # noqa: E501

        Returns paginated list of MACSets   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_mac_sets_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: MACSetListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_mac_sets" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_mac_sets`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_mac_sets`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/mac-sets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MACSetListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_ns_groups(self, **kwargs):  # noqa: E501
        """List NSGroups  # noqa: E501

        List the NSGroups in a paginated format. The page size is restricted to 50 NSGroups so that the size of the response remains small even in the worst case. Optionally, specify valid member types as request parameter to filter NSGroups.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ns_groups(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str member_types: Specify member types to filter corresponding NSGroups 
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool populate_references: Populate metadata of resource referenced by NSGroupExpressions 
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: NSGroupListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_ns_groups_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_ns_groups_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_ns_groups_with_http_info(self, **kwargs):  # noqa: E501
        """List NSGroups  # noqa: E501

        List the NSGroups in a paginated format. The page size is restricted to 50 NSGroups so that the size of the response remains small even in the worst case. Optionally, specify valid member types as request parameter to filter NSGroups.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ns_groups_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str member_types: Specify member types to filter corresponding NSGroups 
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool populate_references: Populate metadata of resource referenced by NSGroupExpressions 
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: NSGroupListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'member_types', 'page_size', 'populate_references', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_ns_groups" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ns_groups`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ns_groups`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'member_types' in params:
            query_params.append(('member_types', params['member_types']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'populate_references' in params:
            query_params.append(('populate_references', params['populate_references']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NSGroupListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_ns_service_groups(self, **kwargs):  # noqa: E501
        """List all NSServiceGroups  # noqa: E501

        Returns paginated list of NSServiceGroups   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ns_service_groups(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool default_service: Fetch all default NSServiceGroups
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: NSServiceGroupListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_ns_service_groups_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_ns_service_groups_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_ns_service_groups_with_http_info(self, **kwargs):  # noqa: E501
        """List all NSServiceGroups  # noqa: E501

        Returns paginated list of NSServiceGroups   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ns_service_groups_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool default_service: Fetch all default NSServiceGroups
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: NSServiceGroupListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'default_service', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_ns_service_groups" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ns_service_groups`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ns_service_groups`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'default_service' in params:
            query_params.append(('default_service', params['default_service']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-service-groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NSServiceGroupListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_ns_services(self, **kwargs):  # noqa: E501
        """List all NSServices  # noqa: E501

        Returns paginated list of NSServices   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ns_services(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool default_service: Fetch all default NSServices
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: NSServiceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_ns_services_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_ns_services_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_ns_services_with_http_info(self, **kwargs):  # noqa: E501
        """List all NSServices  # noqa: E501

        Returns paginated list of NSServices   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ns_services_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool default_service: Fetch all default NSServices
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: NSServiceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'default_service', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_ns_services" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ns_services`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ns_services`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'default_service' in params:
            query_params.append(('default_service', params['default_service']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-services', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NSServiceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_ip_set(self, ip_set_id, **kwargs):  # noqa: E501
        """Read IPSet  # noqa: E501

        Returns information about the specified IPSet   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ip_set(ip_set_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ip_set_id: IPSet Id (required)
        :return: IPSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_ip_set_with_http_info(ip_set_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_ip_set_with_http_info(ip_set_id, **kwargs)  # noqa: E501
            return data

    def read_ip_set_with_http_info(self, ip_set_id, **kwargs):  # noqa: E501
        """Read IPSet  # noqa: E501

        Returns information about the specified IPSet   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ip_set_with_http_info(ip_set_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ip_set_id: IPSet Id (required)
        :return: IPSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ip_set_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_ip_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ip_set_id' is set
        if ('ip_set_id' not in params or
                params['ip_set_id'] is None):
            raise ValueError("Missing the required parameter `ip_set_id` when calling `read_ip_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ip_set_id' in params:
            path_params['ip-set-id'] = params['ip_set_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ip-sets/{ip-set-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IPSet',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_mac_set(self, mac_set_id, **kwargs):  # noqa: E501
        """Read MACSet  # noqa: E501

        Returns information about the specified MACSet   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_mac_set(mac_set_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str mac_set_id: MACSet Id (required)
        :return: MACSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_mac_set_with_http_info(mac_set_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_mac_set_with_http_info(mac_set_id, **kwargs)  # noqa: E501
            return data

    def read_mac_set_with_http_info(self, mac_set_id, **kwargs):  # noqa: E501
        """Read MACSet  # noqa: E501

        Returns information about the specified MACSet   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_mac_set_with_http_info(mac_set_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str mac_set_id: MACSet Id (required)
        :return: MACSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mac_set_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_mac_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mac_set_id' is set
        if ('mac_set_id' not in params or
                params['mac_set_id'] is None):
            raise ValueError("Missing the required parameter `mac_set_id` when calling `read_mac_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mac_set_id' in params:
            path_params['mac-set-id'] = params['mac_set_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/mac-sets/{mac-set-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MACSet',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_ns_group(self, ns_group_id, **kwargs):  # noqa: E501
        """Read NSGroup  # noqa: E501

        Returns information about the specified NSGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ns_group(ns_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_group_id: NSGroup Id (required)
        :param bool populate_references: Populate metadata of resource referenced by NSGroupExpressions 
        :return: NSGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_ns_group_with_http_info(ns_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_ns_group_with_http_info(ns_group_id, **kwargs)  # noqa: E501
            return data

    def read_ns_group_with_http_info(self, ns_group_id, **kwargs):  # noqa: E501
        """Read NSGroup  # noqa: E501

        Returns information about the specified NSGroup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ns_group_with_http_info(ns_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_group_id: NSGroup Id (required)
        :param bool populate_references: Populate metadata of resource referenced by NSGroupExpressions 
        :return: NSGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'populate_references']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_ns_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `read_ns_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []
        if 'populate_references' in params:
            query_params.append(('populate_references', params['populate_references']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NSGroup',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_ns_service(self, ns_service_id, **kwargs):  # noqa: E501
        """Read NSService  # noqa: E501

        Returns information about the specified NSService   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ns_service(ns_service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_service_id: NSService Id (required)
        :return: NSService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_ns_service_with_http_info(ns_service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_ns_service_with_http_info(ns_service_id, **kwargs)  # noqa: E501
            return data

    def read_ns_service_with_http_info(self, ns_service_id, **kwargs):  # noqa: E501
        """Read NSService  # noqa: E501

        Returns information about the specified NSService   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ns_service_with_http_info(ns_service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_service_id: NSService Id (required)
        :return: NSService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_service_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_ns_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_service_id' is set
        if ('ns_service_id' not in params or
                params['ns_service_id'] is None):
            raise ValueError("Missing the required parameter `ns_service_id` when calling `read_ns_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_service_id' in params:
            path_params['ns-service-id'] = params['ns_service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-services/{ns-service-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NSService',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_ns_service_group(self, ns_service_group_id, **kwargs):  # noqa: E501
        """Read NSServiceGroup  # noqa: E501

        Returns information about the specified NSServiceGroup   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ns_service_group(ns_service_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_service_group_id: NSServiceGroup Id (required)
        :return: NSServiceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_ns_service_group_with_http_info(ns_service_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_ns_service_group_with_http_info(ns_service_group_id, **kwargs)  # noqa: E501
            return data

    def read_ns_service_group_with_http_info(self, ns_service_group_id, **kwargs):  # noqa: E501
        """Read NSServiceGroup  # noqa: E501

        Returns information about the specified NSServiceGroup   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ns_service_group_with_http_info(ns_service_group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_service_group_id: NSServiceGroup Id (required)
        :return: NSServiceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_service_group_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_ns_service_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_service_group_id' is set
        if ('ns_service_group_id' not in params or
                params['ns_service_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_service_group_id` when calling `read_ns_service_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_service_group_id' in params:
            path_params['ns-service-group-id'] = params['ns_service_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-service-groups/{ns-service-group-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NSServiceGroup',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_mac_address(self, mac_set_id, mac_address, **kwargs):  # noqa: E501
        """Remove a MAC address from given MACSet  # noqa: E501

        Remove an individual MAC address from a MACSet   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remove_mac_address(mac_set_id, mac_address, async=True)
        >>> result = thread.get()

        :param async bool
        :param str mac_set_id: MACSet Id (required)
        :param str mac_address: MAC address to be removed (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remove_mac_address_with_http_info(mac_set_id, mac_address, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_mac_address_with_http_info(mac_set_id, mac_address, **kwargs)  # noqa: E501
            return data

    def remove_mac_address_with_http_info(self, mac_set_id, mac_address, **kwargs):  # noqa: E501
        """Remove a MAC address from given MACSet  # noqa: E501

        Remove an individual MAC address from a MACSet   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remove_mac_address_with_http_info(mac_set_id, mac_address, async=True)
        >>> result = thread.get()

        :param async bool
        :param str mac_set_id: MACSet Id (required)
        :param str mac_address: MAC address to be removed (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mac_set_id', 'mac_address']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_mac_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mac_set_id' is set
        if ('mac_set_id' not in params or
                params['mac_set_id'] is None):
            raise ValueError("Missing the required parameter `mac_set_id` when calling `remove_mac_address`")  # noqa: E501
        # verify the required parameter 'mac_address' is set
        if ('mac_address' not in params or
                params['mac_address'] is None):
            raise ValueError("Missing the required parameter `mac_address` when calling `remove_mac_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mac_set_id' in params:
            path_params['mac-set-id'] = params['mac_set_id']  # noqa: E501
        if 'mac_address' in params:
            path_params['mac-address'] = params['mac_address']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/mac-sets/{mac-set-id}/members/{mac-address}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ip_set(self, ip_set_id, ip_set, **kwargs):  # noqa: E501
        """Update IPSet  # noqa: E501

        Updates the specified IPSet. Modifiable parameters include description, display_name and ip_addresses.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_ip_set(ip_set_id, ip_set, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ip_set_id: IPSet Id (required)
        :param IPSet ip_set: (required)
        :return: IPSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_ip_set_with_http_info(ip_set_id, ip_set, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ip_set_with_http_info(ip_set_id, ip_set, **kwargs)  # noqa: E501
            return data

    def update_ip_set_with_http_info(self, ip_set_id, ip_set, **kwargs):  # noqa: E501
        """Update IPSet  # noqa: E501

        Updates the specified IPSet. Modifiable parameters include description, display_name and ip_addresses.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_ip_set_with_http_info(ip_set_id, ip_set, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ip_set_id: IPSet Id (required)
        :param IPSet ip_set: (required)
        :return: IPSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ip_set_id', 'ip_set']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ip_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ip_set_id' is set
        if ('ip_set_id' not in params or
                params['ip_set_id'] is None):
            raise ValueError("Missing the required parameter `ip_set_id` when calling `update_ip_set`")  # noqa: E501
        # verify the required parameter 'ip_set' is set
        if ('ip_set' not in params or
                params['ip_set'] is None):
            raise ValueError("Missing the required parameter `ip_set` when calling `update_ip_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ip_set_id' in params:
            path_params['ip-set-id'] = params['ip_set_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ip_set' in params:
            body_params = params['ip_set']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ip-sets/{ip-set-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IPSet',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_mac_set(self, mac_set_id, mac_set, **kwargs):  # noqa: E501
        """Update MACSet  # noqa: E501

        Updates the specified MACSet. Modifiable parameters include the description, display_name and mac_addresses.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_mac_set(mac_set_id, mac_set, async=True)
        >>> result = thread.get()

        :param async bool
        :param str mac_set_id: MACSet Id (required)
        :param MACSet mac_set: (required)
        :return: MACSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_mac_set_with_http_info(mac_set_id, mac_set, **kwargs)  # noqa: E501
        else:
            (data) = self.update_mac_set_with_http_info(mac_set_id, mac_set, **kwargs)  # noqa: E501
            return data

    def update_mac_set_with_http_info(self, mac_set_id, mac_set, **kwargs):  # noqa: E501
        """Update MACSet  # noqa: E501

        Updates the specified MACSet. Modifiable parameters include the description, display_name and mac_addresses.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_mac_set_with_http_info(mac_set_id, mac_set, async=True)
        >>> result = thread.get()

        :param async bool
        :param str mac_set_id: MACSet Id (required)
        :param MACSet mac_set: (required)
        :return: MACSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mac_set_id', 'mac_set']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_mac_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mac_set_id' is set
        if ('mac_set_id' not in params or
                params['mac_set_id'] is None):
            raise ValueError("Missing the required parameter `mac_set_id` when calling `update_mac_set`")  # noqa: E501
        # verify the required parameter 'mac_set' is set
        if ('mac_set' not in params or
                params['mac_set'] is None):
            raise ValueError("Missing the required parameter `mac_set` when calling `update_mac_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mac_set_id' in params:
            path_params['mac-set-id'] = params['mac_set_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'mac_set' in params:
            body_params = params['mac_set']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/mac-sets/{mac-set-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MACSet',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ns_group(self, ns_group_id, ns_group, **kwargs):  # noqa: E501
        """Update NSGroup  # noqa: E501

        Updates the specified NSGroup. Modifiable parameters include the description, display_name and members.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_ns_group(ns_group_id, ns_group, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_group_id: NSGroup Id (required)
        :param NSGroup ns_group: (required)
        :return: NSGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_ns_group_with_http_info(ns_group_id, ns_group, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ns_group_with_http_info(ns_group_id, ns_group, **kwargs)  # noqa: E501
            return data

    def update_ns_group_with_http_info(self, ns_group_id, ns_group, **kwargs):  # noqa: E501
        """Update NSGroup  # noqa: E501

        Updates the specified NSGroup. Modifiable parameters include the description, display_name and members.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_ns_group_with_http_info(ns_group_id, ns_group, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_group_id: NSGroup Id (required)
        :param NSGroup ns_group: (required)
        :return: NSGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_group_id', 'ns_group']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ns_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_group_id' is set
        if ('ns_group_id' not in params or
                params['ns_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_group_id` when calling `update_ns_group`")  # noqa: E501
        # verify the required parameter 'ns_group' is set
        if ('ns_group' not in params or
                params['ns_group'] is None):
            raise ValueError("Missing the required parameter `ns_group` when calling `update_ns_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_group_id' in params:
            path_params['ns-group-id'] = params['ns_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ns_group' in params:
            body_params = params['ns_group']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-groups/{ns-group-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NSGroup',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ns_service(self, ns_service_id, ns_service, **kwargs):  # noqa: E501
        """Update NSService  # noqa: E501

        Updates the specified NSService. Modifiable parameters include the description, display_name and the NSService element. The system defined NSServices can't be modified   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_ns_service(ns_service_id, ns_service, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_service_id: NSService Id (required)
        :param NSService ns_service: (required)
        :return: NSService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_ns_service_with_http_info(ns_service_id, ns_service, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ns_service_with_http_info(ns_service_id, ns_service, **kwargs)  # noqa: E501
            return data

    def update_ns_service_with_http_info(self, ns_service_id, ns_service, **kwargs):  # noqa: E501
        """Update NSService  # noqa: E501

        Updates the specified NSService. Modifiable parameters include the description, display_name and the NSService element. The system defined NSServices can't be modified   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_ns_service_with_http_info(ns_service_id, ns_service, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_service_id: NSService Id (required)
        :param NSService ns_service: (required)
        :return: NSService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_service_id', 'ns_service']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ns_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_service_id' is set
        if ('ns_service_id' not in params or
                params['ns_service_id'] is None):
            raise ValueError("Missing the required parameter `ns_service_id` when calling `update_ns_service`")  # noqa: E501
        # verify the required parameter 'ns_service' is set
        if ('ns_service' not in params or
                params['ns_service'] is None):
            raise ValueError("Missing the required parameter `ns_service` when calling `update_ns_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_service_id' in params:
            path_params['ns-service-id'] = params['ns_service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ns_service' in params:
            body_params = params['ns_service']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-services/{ns-service-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NSService',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ns_service_group(self, ns_service_group_id, ns_service_group, **kwargs):  # noqa: E501
        """Update NSServiceGroup  # noqa: E501

        Updates the specified NSService. Modifiable parameters include the description, display_name and members.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_ns_service_group(ns_service_group_id, ns_service_group, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_service_group_id: NSServiceGroup Id (required)
        :param NSServiceGroup ns_service_group: (required)
        :return: NSServiceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_ns_service_group_with_http_info(ns_service_group_id, ns_service_group, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ns_service_group_with_http_info(ns_service_group_id, ns_service_group, **kwargs)  # noqa: E501
            return data

    def update_ns_service_group_with_http_info(self, ns_service_group_id, ns_service_group, **kwargs):  # noqa: E501
        """Update NSServiceGroup  # noqa: E501

        Updates the specified NSService. Modifiable parameters include the description, display_name and members.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_ns_service_group_with_http_info(ns_service_group_id, ns_service_group, async=True)
        >>> result = thread.get()

        :param async bool
        :param str ns_service_group_id: NSServiceGroup Id (required)
        :param NSServiceGroup ns_service_group: (required)
        :return: NSServiceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ns_service_group_id', 'ns_service_group']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ns_service_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ns_service_group_id' is set
        if ('ns_service_group_id' not in params or
                params['ns_service_group_id'] is None):
            raise ValueError("Missing the required parameter `ns_service_group_id` when calling `update_ns_service_group`")  # noqa: E501
        # verify the required parameter 'ns_service_group' is set
        if ('ns_service_group' not in params or
                params['ns_service_group'] is None):
            raise ValueError("Missing the required parameter `ns_service_group` when calling `update_ns_service_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ns_service_group_id' in params:
            path_params['ns-service-group-id'] = params['ns_service_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ns_service_group' in params:
            body_params = params['ns_service_group']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ns-service-groups/{ns-service-group-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NSServiceGroup',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
