# coding: utf-8

"""
    NSX API

    VMware NSX REST API  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class NetworkTransportApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_bridge_cluster(self, bridge_cluster, **kwargs):  # noqa: E501
        """Create a Bridge Cluster  # noqa: E501

        Creates a bridge cluster. It is collection of transport nodes that will do the bridging for overlay network to vlan networks. Bridge cluster may have one or more transport nodes   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_bridge_cluster(bridge_cluster, async=True)
        >>> result = thread.get()

        :param async bool
        :param BridgeCluster bridge_cluster: (required)
        :return: BridgeCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_bridge_cluster_with_http_info(bridge_cluster, **kwargs)  # noqa: E501
        else:
            (data) = self.create_bridge_cluster_with_http_info(bridge_cluster, **kwargs)  # noqa: E501
            return data

    def create_bridge_cluster_with_http_info(self, bridge_cluster, **kwargs):  # noqa: E501
        """Create a Bridge Cluster  # noqa: E501

        Creates a bridge cluster. It is collection of transport nodes that will do the bridging for overlay network to vlan networks. Bridge cluster may have one or more transport nodes   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_bridge_cluster_with_http_info(bridge_cluster, async=True)
        >>> result = thread.get()

        :param async bool
        :param BridgeCluster bridge_cluster: (required)
        :return: BridgeCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bridge_cluster']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_bridge_cluster" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bridge_cluster' is set
        if ('bridge_cluster' not in params or
                params['bridge_cluster'] is None):
            raise ValueError("Missing the required parameter `bridge_cluster` when calling `create_bridge_cluster`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bridge_cluster' in params:
            body_params = params['bridge_cluster']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/bridge-clusters', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BridgeCluster',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_bridge_endpoint(self, bridge_endpoint, **kwargs):  # noqa: E501
        """Create a Bridge Endpoint  # noqa: E501

        Creates a Bridge Endpoint. It describes the physical attributes of the bridge like vlan. A logical port can be attached to a vif providing bridging functionality from the logical overlay network to the physical vlan network   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_bridge_endpoint(bridge_endpoint, async=True)
        >>> result = thread.get()

        :param async bool
        :param BridgeEndpoint bridge_endpoint: (required)
        :return: BridgeEndpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_bridge_endpoint_with_http_info(bridge_endpoint, **kwargs)  # noqa: E501
        else:
            (data) = self.create_bridge_endpoint_with_http_info(bridge_endpoint, **kwargs)  # noqa: E501
            return data

    def create_bridge_endpoint_with_http_info(self, bridge_endpoint, **kwargs):  # noqa: E501
        """Create a Bridge Endpoint  # noqa: E501

        Creates a Bridge Endpoint. It describes the physical attributes of the bridge like vlan. A logical port can be attached to a vif providing bridging functionality from the logical overlay network to the physical vlan network   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_bridge_endpoint_with_http_info(bridge_endpoint, async=True)
        >>> result = thread.get()

        :param async bool
        :param BridgeEndpoint bridge_endpoint: (required)
        :return: BridgeEndpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bridge_endpoint']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_bridge_endpoint" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bridge_endpoint' is set
        if ('bridge_endpoint' not in params or
                params['bridge_endpoint'] is None):
            raise ValueError("Missing the required parameter `bridge_endpoint` when calling `create_bridge_endpoint`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bridge_endpoint' in params:
            body_params = params['bridge_endpoint']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/bridge-endpoints', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BridgeEndpoint',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cluster_profile(self, cluster_profile, **kwargs):  # noqa: E501
        """Create a Cluster Profile  # noqa: E501

        Create a cluster profile. The resource_type is required.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_cluster_profile(cluster_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param ClusterProfile cluster_profile: (required)
        :return: ClusterProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_cluster_profile_with_http_info(cluster_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.create_cluster_profile_with_http_info(cluster_profile, **kwargs)  # noqa: E501
            return data

    def create_cluster_profile_with_http_info(self, cluster_profile, **kwargs):  # noqa: E501
        """Create a Cluster Profile  # noqa: E501

        Create a cluster profile. The resource_type is required.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_cluster_profile_with_http_info(cluster_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param ClusterProfile cluster_profile: (required)
        :return: ClusterProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cluster_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_profile' is set
        if ('cluster_profile' not in params or
                params['cluster_profile'] is None):
            raise ValueError("Missing the required parameter `cluster_profile` when calling `create_cluster_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_profile' in params:
            body_params = params['cluster_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_compute_collection_transport_node_template(self, compute_collection_transport_node_template, **kwargs):  # noqa: E501
        """Create transport node template for compute collection.  # noqa: E501

        If automated transport node creation is configured on compute collection, this template will serve as the default setting for transport node creation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_compute_collection_transport_node_template(compute_collection_transport_node_template, async=True)
        >>> result = thread.get()

        :param async bool
        :param ComputeCollectionTransportNodeTemplate compute_collection_transport_node_template: (required)
        :return: ComputeCollectionTransportNodeTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_compute_collection_transport_node_template_with_http_info(compute_collection_transport_node_template, **kwargs)  # noqa: E501
        else:
            (data) = self.create_compute_collection_transport_node_template_with_http_info(compute_collection_transport_node_template, **kwargs)  # noqa: E501
            return data

    def create_compute_collection_transport_node_template_with_http_info(self, compute_collection_transport_node_template, **kwargs):  # noqa: E501
        """Create transport node template for compute collection.  # noqa: E501

        If automated transport node creation is configured on compute collection, this template will serve as the default setting for transport node creation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_compute_collection_transport_node_template_with_http_info(compute_collection_transport_node_template, async=True)
        >>> result = thread.get()

        :param async bool
        :param ComputeCollectionTransportNodeTemplate compute_collection_transport_node_template: (required)
        :return: ComputeCollectionTransportNodeTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['compute_collection_transport_node_template']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_compute_collection_transport_node_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'compute_collection_transport_node_template' is set
        if ('compute_collection_transport_node_template' not in params or
                params['compute_collection_transport_node_template'] is None):
            raise ValueError("Missing the required parameter `compute_collection_transport_node_template` when calling `create_compute_collection_transport_node_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'compute_collection_transport_node_template' in params:
            body_params = params['compute_collection_transport_node_template']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/compute-collection-transport-node-templates', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComputeCollectionTransportNodeTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_edge_cluster(self, edge_cluster, **kwargs):  # noqa: E501
        """Create Edge Cluster  # noqa: E501

        Creates a new edge cluster. It only supports homogeneous members. The TransportNodes backed by EdgeNode are only allowed in cluster members. DeploymentType (VIRTUAL_MACHINE|PHYSICAL_MACHINE) of these EdgeNodes should be same.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_edge_cluster(edge_cluster, async=True)
        >>> result = thread.get()

        :param async bool
        :param EdgeCluster edge_cluster: (required)
        :return: EdgeCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_edge_cluster_with_http_info(edge_cluster, **kwargs)  # noqa: E501
        else:
            (data) = self.create_edge_cluster_with_http_info(edge_cluster, **kwargs)  # noqa: E501
            return data

    def create_edge_cluster_with_http_info(self, edge_cluster, **kwargs):  # noqa: E501
        """Create Edge Cluster  # noqa: E501

        Creates a new edge cluster. It only supports homogeneous members. The TransportNodes backed by EdgeNode are only allowed in cluster members. DeploymentType (VIRTUAL_MACHINE|PHYSICAL_MACHINE) of these EdgeNodes should be same.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_edge_cluster_with_http_info(edge_cluster, async=True)
        >>> result = thread.get()

        :param async bool
        :param EdgeCluster edge_cluster: (required)
        :return: EdgeCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['edge_cluster']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_edge_cluster" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'edge_cluster' is set
        if ('edge_cluster' not in params or
                params['edge_cluster'] is None):
            raise ValueError("Missing the required parameter `edge_cluster` when calling `create_edge_cluster`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'edge_cluster' in params:
            body_params = params['edge_cluster']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/edge-clusters', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EdgeCluster',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_host_switch_profile(self, base_host_switch_profile, **kwargs):  # noqa: E501
        """Create a Hostswitch Profile  # noqa: E501

        Creates a hostswitch profile. The resource_type is required. For uplink profiles, the teaming and policy parameters are required. By default, the mtu is 1600 and the transport_vlan is 0. The supported MTU range is 1280 through 9000.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_host_switch_profile(base_host_switch_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param BaseHostSwitchProfile base_host_switch_profile: (required)
        :return: BaseHostSwitchProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_host_switch_profile_with_http_info(base_host_switch_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.create_host_switch_profile_with_http_info(base_host_switch_profile, **kwargs)  # noqa: E501
            return data

    def create_host_switch_profile_with_http_info(self, base_host_switch_profile, **kwargs):  # noqa: E501
        """Create a Hostswitch Profile  # noqa: E501

        Creates a hostswitch profile. The resource_type is required. For uplink profiles, the teaming and policy parameters are required. By default, the mtu is 1600 and the transport_vlan is 0. The supported MTU range is 1280 through 9000.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_host_switch_profile_with_http_info(base_host_switch_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param BaseHostSwitchProfile base_host_switch_profile: (required)
        :return: BaseHostSwitchProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['base_host_switch_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_host_switch_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'base_host_switch_profile' is set
        if ('base_host_switch_profile' not in params or
                params['base_host_switch_profile'] is None):
            raise ValueError("Missing the required parameter `base_host_switch_profile` when calling `create_host_switch_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'base_host_switch_profile' in params:
            body_params = params['base_host_switch_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/host-switch-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseHostSwitchProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_transport_node(self, transport_node, **kwargs):  # noqa: E501
        """Create a Transport Node  # noqa: E501

        Enables a fabric node to act as a transport node.  Additional documentation on creating a transport node can be found in the NSX-T Installation Guide.  Transport nodes are hypervisor hosts and NSX Edges that will participate in an NSX-T overlay. For a hypervisor host, this means that it hosts VMs that will communicate over NSX-T logical switches. For NSX Edges, this means that it will have logical router uplinks and downlinks.  When creating a transport node, you must provide the node id of an existing fabric node (hypervisor host or NSX Edge node) in the node_id property of the payload. This property is required.  Additionally, in order for the transport node to forward packets, the host_switch_spec property must be specified.  Host switches (called bridges in OVS on KVM hypervisors) are the individual switches within the host virtual switch. Virtual machines are connected to the host switches.  When creating a transport node, you need to specify if the host switches are already manually preconfigured on the node, or if NSX should create and manage the host switches. You specify this choice by the type of host switches you pass in the host_switch_spec property of the TransportNode request payload.  For a KVM host, you can preconfigure the host switch, or you can have NSX Manager perform the configuration. For an ESXi host or NSX Edge node, NSX Manager always configures the host switch.  To preconfigure the host switches on a KVM host, pass an array of PreconfiguredHostSwitchSpec objects that describes those host switches. In the current NSX-T release, only one prefonfigured host switch can be specified.  See the PreconfiguredHostSwitchSpec schema definition for documentation on the properties that must be provided. Preconfigured host switches are only supported on KVM hosts, not on ESXi hosts or NSX Edge nodes.  To allow NSX to manage the host switch configuration on KVM hosts, ESXi hosts, or NSX Edge nodes, pass an array of StandardHostSwitchSpec objects in the host_switch_spec property, and NSX will automatically create host switches with the properties you provide. In the current NSX-T release, up to 5 host switches can be automatically managed. See the StandardHostSwitchSpec schema definition for documentation on the properties that must be provided.  Note: previous versions of NSX-T used a property named host_switches to specify the host switch configuration on the transport node. That property is deprecated, but still functions. You should configure new host switches using the host_switch_spec property.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_transport_node(transport_node, async=True)
        >>> result = thread.get()

        :param async bool
        :param TransportNode transport_node: (required)
        :return: TransportNode
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_transport_node_with_http_info(transport_node, **kwargs)  # noqa: E501
        else:
            (data) = self.create_transport_node_with_http_info(transport_node, **kwargs)  # noqa: E501
            return data

    def create_transport_node_with_http_info(self, transport_node, **kwargs):  # noqa: E501
        """Create a Transport Node  # noqa: E501

        Enables a fabric node to act as a transport node.  Additional documentation on creating a transport node can be found in the NSX-T Installation Guide.  Transport nodes are hypervisor hosts and NSX Edges that will participate in an NSX-T overlay. For a hypervisor host, this means that it hosts VMs that will communicate over NSX-T logical switches. For NSX Edges, this means that it will have logical router uplinks and downlinks.  When creating a transport node, you must provide the node id of an existing fabric node (hypervisor host or NSX Edge node) in the node_id property of the payload. This property is required.  Additionally, in order for the transport node to forward packets, the host_switch_spec property must be specified.  Host switches (called bridges in OVS on KVM hypervisors) are the individual switches within the host virtual switch. Virtual machines are connected to the host switches.  When creating a transport node, you need to specify if the host switches are already manually preconfigured on the node, or if NSX should create and manage the host switches. You specify this choice by the type of host switches you pass in the host_switch_spec property of the TransportNode request payload.  For a KVM host, you can preconfigure the host switch, or you can have NSX Manager perform the configuration. For an ESXi host or NSX Edge node, NSX Manager always configures the host switch.  To preconfigure the host switches on a KVM host, pass an array of PreconfiguredHostSwitchSpec objects that describes those host switches. In the current NSX-T release, only one prefonfigured host switch can be specified.  See the PreconfiguredHostSwitchSpec schema definition for documentation on the properties that must be provided. Preconfigured host switches are only supported on KVM hosts, not on ESXi hosts or NSX Edge nodes.  To allow NSX to manage the host switch configuration on KVM hosts, ESXi hosts, or NSX Edge nodes, pass an array of StandardHostSwitchSpec objects in the host_switch_spec property, and NSX will automatically create host switches with the properties you provide. In the current NSX-T release, up to 5 host switches can be automatically managed. See the StandardHostSwitchSpec schema definition for documentation on the properties that must be provided.  Note: previous versions of NSX-T used a property named host_switches to specify the host switch configuration on the transport node. That property is deprecated, but still functions. You should configure new host switches using the host_switch_spec property.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_transport_node_with_http_info(transport_node, async=True)
        >>> result = thread.get()

        :param async bool
        :param TransportNode transport_node: (required)
        :return: TransportNode
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transport_node']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_transport_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transport_node' is set
        if ('transport_node' not in params or
                params['transport_node'] is None):
            raise ValueError("Missing the required parameter `transport_node` when calling `create_transport_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transport_node' in params:
            body_params = params['transport_node']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNode',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_transport_zone(self, transport_zone, **kwargs):  # noqa: E501
        """Create a Transport Zone  # noqa: E501

        Creates a new transport zone. The required parameters are host_switch_name and transport_type (OVERLAY or VLAN). The optional parameters are description and display_name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_transport_zone(transport_zone, async=True)
        >>> result = thread.get()

        :param async bool
        :param TransportZone transport_zone: (required)
        :return: TransportZone
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_transport_zone_with_http_info(transport_zone, **kwargs)  # noqa: E501
        else:
            (data) = self.create_transport_zone_with_http_info(transport_zone, **kwargs)  # noqa: E501
            return data

    def create_transport_zone_with_http_info(self, transport_zone, **kwargs):  # noqa: E501
        """Create a Transport Zone  # noqa: E501

        Creates a new transport zone. The required parameters are host_switch_name and transport_type (OVERLAY or VLAN). The optional parameters are description and display_name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_transport_zone_with_http_info(transport_zone, async=True)
        >>> result = thread.get()

        :param async bool
        :param TransportZone transport_zone: (required)
        :return: TransportZone
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transport_zone']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_transport_zone" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transport_zone' is set
        if ('transport_zone' not in params or
                params['transport_zone'] is None):
            raise ValueError("Missing the required parameter `transport_zone` when calling `create_transport_zone`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transport_zone' in params:
            body_params = params['transport_zone']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-zones', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportZone',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_transport_zone_profile(self, transport_zone_profile, **kwargs):  # noqa: E501
        """Create a transport zone Profile  # noqa: E501

        Creates a transport zone profile. The resource_type is required.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_transport_zone_profile(transport_zone_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param TransportZoneProfile transport_zone_profile: (required)
        :return: TransportZoneProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_transport_zone_profile_with_http_info(transport_zone_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.create_transport_zone_profile_with_http_info(transport_zone_profile, **kwargs)  # noqa: E501
            return data

    def create_transport_zone_profile_with_http_info(self, transport_zone_profile, **kwargs):  # noqa: E501
        """Create a transport zone Profile  # noqa: E501

        Creates a transport zone profile. The resource_type is required.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_transport_zone_profile_with_http_info(transport_zone_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param TransportZoneProfile transport_zone_profile: (required)
        :return: TransportZoneProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transport_zone_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_transport_zone_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transport_zone_profile' is set
        if ('transport_zone_profile' not in params or
                params['transport_zone_profile'] is None):
            raise ValueError("Missing the required parameter `transport_zone_profile` when calling `create_transport_zone_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transport_zone_profile' in params:
            body_params = params['transport_zone_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transportzone-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportZoneProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_bridge_cluster(self, bridgecluster_id, **kwargs):  # noqa: E501
        """Delete a Bridge Cluster  # noqa: E501

        Removes the specified Bridge Cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_bridge_cluster(bridgecluster_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str bridgecluster_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_bridge_cluster_with_http_info(bridgecluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_bridge_cluster_with_http_info(bridgecluster_id, **kwargs)  # noqa: E501
            return data

    def delete_bridge_cluster_with_http_info(self, bridgecluster_id, **kwargs):  # noqa: E501
        """Delete a Bridge Cluster  # noqa: E501

        Removes the specified Bridge Cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_bridge_cluster_with_http_info(bridgecluster_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str bridgecluster_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bridgecluster_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_bridge_cluster" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bridgecluster_id' is set
        if ('bridgecluster_id' not in params or
                params['bridgecluster_id'] is None):
            raise ValueError("Missing the required parameter `bridgecluster_id` when calling `delete_bridge_cluster`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bridgecluster_id' in params:
            path_params['bridgecluster-id'] = params['bridgecluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/bridge-clusters/{bridgecluster-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_bridge_endpoint(self, bridgeendpoint_id, **kwargs):  # noqa: E501
        """Delete a Bridge Endpoint  # noqa: E501

        Deletes the specified Bridge Endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_bridge_endpoint(bridgeendpoint_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str bridgeendpoint_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_bridge_endpoint_with_http_info(bridgeendpoint_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_bridge_endpoint_with_http_info(bridgeendpoint_id, **kwargs)  # noqa: E501
            return data

    def delete_bridge_endpoint_with_http_info(self, bridgeendpoint_id, **kwargs):  # noqa: E501
        """Delete a Bridge Endpoint  # noqa: E501

        Deletes the specified Bridge Endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_bridge_endpoint_with_http_info(bridgeendpoint_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str bridgeendpoint_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bridgeendpoint_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_bridge_endpoint" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bridgeendpoint_id' is set
        if ('bridgeendpoint_id' not in params or
                params['bridgeendpoint_id'] is None):
            raise ValueError("Missing the required parameter `bridgeendpoint_id` when calling `delete_bridge_endpoint`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bridgeendpoint_id' in params:
            path_params['bridgeendpoint-id'] = params['bridgeendpoint_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/bridge-endpoints/{bridgeendpoint-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_cluster_profile(self, cluster_profile_id, **kwargs):  # noqa: E501
        """Delete a cluster profile  # noqa: E501

        Delete a specified cluster profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_cluster_profile(cluster_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str cluster_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_cluster_profile_with_http_info(cluster_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_cluster_profile_with_http_info(cluster_profile_id, **kwargs)  # noqa: E501
            return data

    def delete_cluster_profile_with_http_info(self, cluster_profile_id, **kwargs):  # noqa: E501
        """Delete a cluster profile  # noqa: E501

        Delete a specified cluster profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_cluster_profile_with_http_info(cluster_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str cluster_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_cluster_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_profile_id' is set
        if ('cluster_profile_id' not in params or
                params['cluster_profile_id'] is None):
            raise ValueError("Missing the required parameter `cluster_profile_id` when calling `delete_cluster_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_profile_id' in params:
            path_params['cluster-profile-id'] = params['cluster_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster-profiles/{cluster-profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_compute_collection_transport_node_template(self, template_id, **kwargs):  # noqa: E501
        """Delete a compute collection transport node template  # noqa: E501

        Delete the specified compute collection transport node template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_compute_collection_transport_node_template(template_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str template_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_compute_collection_transport_node_template_with_http_info(template_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_compute_collection_transport_node_template_with_http_info(template_id, **kwargs)  # noqa: E501
            return data

    def delete_compute_collection_transport_node_template_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """Delete a compute collection transport node template  # noqa: E501

        Delete the specified compute collection transport node template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_compute_collection_transport_node_template_with_http_info(template_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str template_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['template_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_compute_collection_transport_node_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'template_id' is set
        if ('template_id' not in params or
                params['template_id'] is None):
            raise ValueError("Missing the required parameter `template_id` when calling `delete_compute_collection_transport_node_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in params:
            path_params['template-id'] = params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/compute-collection-transport-node-templates/{template-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_edge_cluster(self, edge_cluster_id, **kwargs):  # noqa: E501
        """Delete Edge Cluster  # noqa: E501

        Deletes the specified edge cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_edge_cluster(edge_cluster_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str edge_cluster_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_edge_cluster_with_http_info(edge_cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_edge_cluster_with_http_info(edge_cluster_id, **kwargs)  # noqa: E501
            return data

    def delete_edge_cluster_with_http_info(self, edge_cluster_id, **kwargs):  # noqa: E501
        """Delete Edge Cluster  # noqa: E501

        Deletes the specified edge cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_edge_cluster_with_http_info(edge_cluster_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str edge_cluster_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['edge_cluster_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_edge_cluster" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'edge_cluster_id' is set
        if ('edge_cluster_id' not in params or
                params['edge_cluster_id'] is None):
            raise ValueError("Missing the required parameter `edge_cluster_id` when calling `delete_edge_cluster`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'edge_cluster_id' in params:
            path_params['edge-cluster-id'] = params['edge_cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/edge-clusters/{edge-cluster-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_host_switch_profile(self, host_switch_profile_id, **kwargs):  # noqa: E501
        """Delete a Hostswitch Profile  # noqa: E501

        Deletes a specified hostswitch profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_host_switch_profile(host_switch_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str host_switch_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_host_switch_profile_with_http_info(host_switch_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_host_switch_profile_with_http_info(host_switch_profile_id, **kwargs)  # noqa: E501
            return data

    def delete_host_switch_profile_with_http_info(self, host_switch_profile_id, **kwargs):  # noqa: E501
        """Delete a Hostswitch Profile  # noqa: E501

        Deletes a specified hostswitch profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_host_switch_profile_with_http_info(host_switch_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str host_switch_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['host_switch_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_host_switch_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'host_switch_profile_id' is set
        if ('host_switch_profile_id' not in params or
                params['host_switch_profile_id'] is None):
            raise ValueError("Missing the required parameter `host_switch_profile_id` when calling `delete_host_switch_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'host_switch_profile_id' in params:
            path_params['host-switch-profile-id'] = params['host_switch_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/host-switch-profiles/{host-switch-profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_transport_node(self, transportnode_id, **kwargs):  # noqa: E501
        """Delete a Transport Node  # noqa: E501

        Deletes the specified transport node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_transport_node(transportnode_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str transportnode_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_transport_node_with_http_info(transportnode_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_transport_node_with_http_info(transportnode_id, **kwargs)  # noqa: E501
            return data

    def delete_transport_node_with_http_info(self, transportnode_id, **kwargs):  # noqa: E501
        """Delete a Transport Node  # noqa: E501

        Deletes the specified transport node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_transport_node_with_http_info(transportnode_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str transportnode_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transportnode_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_transport_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transportnode_id' is set
        if ('transportnode_id' not in params or
                params['transportnode_id'] is None):
            raise ValueError("Missing the required parameter `transportnode_id` when calling `delete_transport_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transportnode_id' in params:
            path_params['transportnode-id'] = params['transportnode_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transportnode-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_transport_zone(self, zone_id, **kwargs):  # noqa: E501
        """Delete a Transport Zone  # noqa: E501

        Deletes an existing transport zone.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_transport_zone(zone_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str zone_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_transport_zone_with_http_info(zone_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_transport_zone_with_http_info(zone_id, **kwargs)  # noqa: E501
            return data

    def delete_transport_zone_with_http_info(self, zone_id, **kwargs):  # noqa: E501
        """Delete a Transport Zone  # noqa: E501

        Deletes an existing transport zone.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_transport_zone_with_http_info(zone_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str zone_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['zone_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_transport_zone" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'zone_id' is set
        if ('zone_id' not in params or
                params['zone_id'] is None):
            raise ValueError("Missing the required parameter `zone_id` when calling `delete_transport_zone`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'zone_id' in params:
            path_params['zone-id'] = params['zone_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-zones/{zone-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_transport_zone_profile(self, transportzone_profile_id, **kwargs):  # noqa: E501
        """Delete a transport zone Profile  # noqa: E501

        Deletes a specified transport zone profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_transport_zone_profile(transportzone_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str transportzone_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_transport_zone_profile_with_http_info(transportzone_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_transport_zone_profile_with_http_info(transportzone_profile_id, **kwargs)  # noqa: E501
            return data

    def delete_transport_zone_profile_with_http_info(self, transportzone_profile_id, **kwargs):  # noqa: E501
        """Delete a transport zone Profile  # noqa: E501

        Deletes a specified transport zone profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_transport_zone_profile_with_http_info(transportzone_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str transportzone_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transportzone_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_transport_zone_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transportzone_profile_id' is set
        if ('transportzone_profile_id' not in params or
                params['transportzone_profile_id'] is None):
            raise ValueError("Missing the required parameter `transportzone_profile_id` when calling `delete_transport_zone_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transportzone_profile_id' in params:
            path_params['transportzone-profile-id'] = params['transportzone_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transportzone-profiles/{transportzone-profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bridge_cluster(self, bridgecluster_id, **kwargs):  # noqa: E501
        """Get Information about a bridge cluster  # noqa: E501

        Returns information about a specified bridge cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_bridge_cluster(bridgecluster_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str bridgecluster_id: (required)
        :return: BridgeCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_bridge_cluster_with_http_info(bridgecluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bridge_cluster_with_http_info(bridgecluster_id, **kwargs)  # noqa: E501
            return data

    def get_bridge_cluster_with_http_info(self, bridgecluster_id, **kwargs):  # noqa: E501
        """Get Information about a bridge cluster  # noqa: E501

        Returns information about a specified bridge cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_bridge_cluster_with_http_info(bridgecluster_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str bridgecluster_id: (required)
        :return: BridgeCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bridgecluster_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bridge_cluster" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bridgecluster_id' is set
        if ('bridgecluster_id' not in params or
                params['bridgecluster_id'] is None):
            raise ValueError("Missing the required parameter `bridgecluster_id` when calling `get_bridge_cluster`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bridgecluster_id' in params:
            path_params['bridgecluster-id'] = params['bridgecluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/bridge-clusters/{bridgecluster-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BridgeCluster',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bridge_cluster_status(self, cluster_id, **kwargs):  # noqa: E501
        """Returns status of a specified Bridge Cluster  # noqa: E501

        Get the status for the Bridge Cluster of the given cluster id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_bridge_cluster_status(cluster_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str cluster_id: (required)
        :param str source: Data source type.
        :return: BridgeClusterStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_bridge_cluster_status_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bridge_cluster_status_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_bridge_cluster_status_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Returns status of a specified Bridge Cluster  # noqa: E501

        Get the status for the Bridge Cluster of the given cluster id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_bridge_cluster_status_with_http_info(cluster_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str cluster_id: (required)
        :param str source: Data source type.
        :return: BridgeClusterStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bridge_cluster_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_bridge_cluster_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster-id'] = params['cluster_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/bridge-clusters/{cluster-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BridgeClusterStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bridge_endpoint(self, bridgeendpoint_id, **kwargs):  # noqa: E501
        """Get Information about a bridge endpoint  # noqa: E501

        Returns information about a specified bridge endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_bridge_endpoint(bridgeendpoint_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str bridgeendpoint_id: (required)
        :return: BridgeEndpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_bridge_endpoint_with_http_info(bridgeendpoint_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bridge_endpoint_with_http_info(bridgeendpoint_id, **kwargs)  # noqa: E501
            return data

    def get_bridge_endpoint_with_http_info(self, bridgeendpoint_id, **kwargs):  # noqa: E501
        """Get Information about a bridge endpoint  # noqa: E501

        Returns information about a specified bridge endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_bridge_endpoint_with_http_info(bridgeendpoint_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str bridgeendpoint_id: (required)
        :return: BridgeEndpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bridgeendpoint_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bridge_endpoint" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bridgeendpoint_id' is set
        if ('bridgeendpoint_id' not in params or
                params['bridgeendpoint_id'] is None):
            raise ValueError("Missing the required parameter `bridgeendpoint_id` when calling `get_bridge_endpoint`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bridgeendpoint_id' in params:
            path_params['bridgeendpoint-id'] = params['bridgeendpoint_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/bridge-endpoints/{bridgeendpoint-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BridgeEndpoint',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bridge_endpoint_statistics(self, endpoint_id, **kwargs):  # noqa: E501
        """Returns statistics of a specified Bridge Endpoint  # noqa: E501

        Get the statistics for the Bridge Endpoint of the given Endpoint id (endpoint-id)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_bridge_endpoint_statistics(endpoint_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str endpoint_id: (required)
        :param str source: Data source type.
        :return: BridgeEndpointStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_bridge_endpoint_statistics_with_http_info(endpoint_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bridge_endpoint_statistics_with_http_info(endpoint_id, **kwargs)  # noqa: E501
            return data

    def get_bridge_endpoint_statistics_with_http_info(self, endpoint_id, **kwargs):  # noqa: E501
        """Returns statistics of a specified Bridge Endpoint  # noqa: E501

        Get the statistics for the Bridge Endpoint of the given Endpoint id (endpoint-id)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_bridge_endpoint_statistics_with_http_info(endpoint_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str endpoint_id: (required)
        :param str source: Data source type.
        :return: BridgeEndpointStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['endpoint_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bridge_endpoint_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'endpoint_id' is set
        if ('endpoint_id' not in params or
                params['endpoint_id'] is None):
            raise ValueError("Missing the required parameter `endpoint_id` when calling `get_bridge_endpoint_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'endpoint_id' in params:
            path_params['endpoint-id'] = params['endpoint_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/bridge-endpoints/{endpoint-id}/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BridgeEndpointStatistics',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bridge_endpoint_status(self, endpoint_id, **kwargs):  # noqa: E501
        """Returns status of a specified Bridge Endpoint  # noqa: E501

        Get the status for the Bridge Endpoint of the given Endpoint id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_bridge_endpoint_status(endpoint_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str endpoint_id: (required)
        :param str source: Data source type.
        :return: BridgeEndpointStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_bridge_endpoint_status_with_http_info(endpoint_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bridge_endpoint_status_with_http_info(endpoint_id, **kwargs)  # noqa: E501
            return data

    def get_bridge_endpoint_status_with_http_info(self, endpoint_id, **kwargs):  # noqa: E501
        """Returns status of a specified Bridge Endpoint  # noqa: E501

        Get the status for the Bridge Endpoint of the given Endpoint id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_bridge_endpoint_status_with_http_info(endpoint_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str endpoint_id: (required)
        :param str source: Data source type.
        :return: BridgeEndpointStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['endpoint_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bridge_endpoint_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'endpoint_id' is set
        if ('endpoint_id' not in params or
                params['endpoint_id'] is None):
            raise ValueError("Missing the required parameter `endpoint_id` when calling `get_bridge_endpoint_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'endpoint_id' in params:
            path_params['endpoint-id'] = params['endpoint_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/bridge-endpoints/{endpoint-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BridgeEndpointStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cluster_profile(self, cluster_profile_id, **kwargs):  # noqa: E501
        """Get cluster profile by Id  # noqa: E501

        Returns information about a specified cluster profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_cluster_profile(cluster_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str cluster_profile_id: (required)
        :return: ClusterProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_cluster_profile_with_http_info(cluster_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_cluster_profile_with_http_info(cluster_profile_id, **kwargs)  # noqa: E501
            return data

    def get_cluster_profile_with_http_info(self, cluster_profile_id, **kwargs):  # noqa: E501
        """Get cluster profile by Id  # noqa: E501

        Returns information about a specified cluster profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_cluster_profile_with_http_info(cluster_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str cluster_profile_id: (required)
        :return: ClusterProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_profile_id' is set
        if ('cluster_profile_id' not in params or
                params['cluster_profile_id'] is None):
            raise ValueError("Missing the required parameter `cluster_profile_id` when calling `get_cluster_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_profile_id' in params:
            path_params['cluster-profile-id'] = params['cluster_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster-profiles/{cluster-profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_compute_collection_transport_node_template(self, template_id, **kwargs):  # noqa: E501
        """Get compute collection transportnode template by id  # noqa: E501

        Returns compute collection transportnode template by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_compute_collection_transport_node_template(template_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str template_id: (required)
        :return: ComputeCollectionTransportNodeTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_compute_collection_transport_node_template_with_http_info(template_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_compute_collection_transport_node_template_with_http_info(template_id, **kwargs)  # noqa: E501
            return data

    def get_compute_collection_transport_node_template_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """Get compute collection transportnode template by id  # noqa: E501

        Returns compute collection transportnode template by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_compute_collection_transport_node_template_with_http_info(template_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str template_id: (required)
        :return: ComputeCollectionTransportNodeTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['template_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_compute_collection_transport_node_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'template_id' is set
        if ('template_id' not in params or
                params['template_id'] is None):
            raise ValueError("Missing the required parameter `template_id` when calling `get_compute_collection_transport_node_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in params:
            path_params['template-id'] = params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/compute-collection-transport-node-templates/{template-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComputeCollectionTransportNodeTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_compute_collection_transport_node_template_state(self, template_id, **kwargs):  # noqa: E501
        """Get compute collection transportnode template application states  # noqa: E501

        Returns detailed transport node states for this compute collection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_compute_collection_transport_node_template_state(template_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str template_id: (required)
        :param str compute_collection_id: Compute collection id
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ComputeCollectionTransportNodeTemplateStateList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_compute_collection_transport_node_template_state_with_http_info(template_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_compute_collection_transport_node_template_state_with_http_info(template_id, **kwargs)  # noqa: E501
            return data

    def get_compute_collection_transport_node_template_state_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """Get compute collection transportnode template application states  # noqa: E501

        Returns detailed transport node states for this compute collection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_compute_collection_transport_node_template_state_with_http_info(template_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str template_id: (required)
        :param str compute_collection_id: Compute collection id
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ComputeCollectionTransportNodeTemplateStateList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['template_id', 'compute_collection_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_compute_collection_transport_node_template_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'template_id' is set
        if ('template_id' not in params or
                params['template_id'] is None):
            raise ValueError("Missing the required parameter `template_id` when calling `get_compute_collection_transport_node_template_state`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_compute_collection_transport_node_template_state`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_compute_collection_transport_node_template_state`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'template_id' in params:
            path_params['template-id'] = params['template_id']  # noqa: E501

        query_params = []
        if 'compute_collection_id' in params:
            query_params.append(('compute_collection_id', params['compute_collection_id']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/compute-collection-transport-node-templates/{template-id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComputeCollectionTransportNodeTemplateStateList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_host_switch_profile(self, host_switch_profile_id, **kwargs):  # noqa: E501
        """Get a Hostswitch Profile by ID  # noqa: E501

        Returns information about a specified hostswitch profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_host_switch_profile(host_switch_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str host_switch_profile_id: (required)
        :return: BaseHostSwitchProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_host_switch_profile_with_http_info(host_switch_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_host_switch_profile_with_http_info(host_switch_profile_id, **kwargs)  # noqa: E501
            return data

    def get_host_switch_profile_with_http_info(self, host_switch_profile_id, **kwargs):  # noqa: E501
        """Get a Hostswitch Profile by ID  # noqa: E501

        Returns information about a specified hostswitch profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_host_switch_profile_with_http_info(host_switch_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str host_switch_profile_id: (required)
        :return: BaseHostSwitchProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['host_switch_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_host_switch_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'host_switch_profile_id' is set
        if ('host_switch_profile_id' not in params or
                params['host_switch_profile_id'] is None):
            raise ValueError("Missing the required parameter `host_switch_profile_id` when calling `get_host_switch_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'host_switch_profile_id' in params:
            path_params['host-switch-profile-id'] = params['host_switch_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/host-switch-profiles/{host-switch-profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseHostSwitchProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transport_node(self, transportnode_id, **kwargs):  # noqa: E501
        """Get a Transport Node  # noqa: E501

        Returns information about a specified transport node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transport_node(transportnode_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str transportnode_id: (required)
        :return: TransportNode
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_transport_node_with_http_info(transportnode_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transport_node_with_http_info(transportnode_id, **kwargs)  # noqa: E501
            return data

    def get_transport_node_with_http_info(self, transportnode_id, **kwargs):  # noqa: E501
        """Get a Transport Node  # noqa: E501

        Returns information about a specified transport node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transport_node_with_http_info(transportnode_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str transportnode_id: (required)
        :return: TransportNode
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transportnode_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transport_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transportnode_id' is set
        if ('transportnode_id' not in params or
                params['transportnode_id'] is None):
            raise ValueError("Missing the required parameter `transportnode_id` when calling `get_transport_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transportnode_id' in params:
            path_params['transportnode-id'] = params['transportnode_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transportnode-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNode',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transport_node_state(self, transportnode_id, **kwargs):  # noqa: E501
        """Get a Transport Node&#39;s State  # noqa: E501

        Returns information about the current state of the transport node configuration and information about the associated hostswitch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transport_node_state(transportnode_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str transportnode_id: (required)
        :return: TransportNodeState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_transport_node_state_with_http_info(transportnode_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transport_node_state_with_http_info(transportnode_id, **kwargs)  # noqa: E501
            return data

    def get_transport_node_state_with_http_info(self, transportnode_id, **kwargs):  # noqa: E501
        """Get a Transport Node&#39;s State  # noqa: E501

        Returns information about the current state of the transport node configuration and information about the associated hostswitch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transport_node_state_with_http_info(transportnode_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str transportnode_id: (required)
        :return: TransportNodeState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transportnode_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transport_node_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transportnode_id' is set
        if ('transportnode_id' not in params or
                params['transportnode_id'] is None):
            raise ValueError("Missing the required parameter `transportnode_id` when calling `get_transport_node_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transportnode_id' in params:
            path_params['transportnode-id'] = params['transportnode_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transportnode-id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNodeState',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transport_zone(self, zone_id, **kwargs):  # noqa: E501
        """Get a Transport Zone  # noqa: E501

        Returns information about a single transport zone.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transport_zone(zone_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str zone_id: (required)
        :return: TransportZone
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_transport_zone_with_http_info(zone_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transport_zone_with_http_info(zone_id, **kwargs)  # noqa: E501
            return data

    def get_transport_zone_with_http_info(self, zone_id, **kwargs):  # noqa: E501
        """Get a Transport Zone  # noqa: E501

        Returns information about a single transport zone.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transport_zone_with_http_info(zone_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str zone_id: (required)
        :return: TransportZone
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['zone_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transport_zone" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'zone_id' is set
        if ('zone_id' not in params or
                params['zone_id'] is None):
            raise ValueError("Missing the required parameter `zone_id` when calling `get_transport_zone`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'zone_id' in params:
            path_params['zone-id'] = params['zone_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-zones/{zone-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportZone',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transport_zone_profile(self, transportzone_profile_id, **kwargs):  # noqa: E501
        """Get transport zone profile by identifier  # noqa: E501

        Returns information about a specified transport zone profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transport_zone_profile(transportzone_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str transportzone_profile_id: (required)
        :return: TransportZoneProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_transport_zone_profile_with_http_info(transportzone_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transport_zone_profile_with_http_info(transportzone_profile_id, **kwargs)  # noqa: E501
            return data

    def get_transport_zone_profile_with_http_info(self, transportzone_profile_id, **kwargs):  # noqa: E501
        """Get transport zone profile by identifier  # noqa: E501

        Returns information about a specified transport zone profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transport_zone_profile_with_http_info(transportzone_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str transportzone_profile_id: (required)
        :return: TransportZoneProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transportzone_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transport_zone_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transportzone_profile_id' is set
        if ('transportzone_profile_id' not in params or
                params['transportzone_profile_id'] is None):
            raise ValueError("Missing the required parameter `transportzone_profile_id` when calling `get_transport_zone_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transportzone_profile_id' in params:
            path_params['transportzone-profile-id'] = params['transportzone_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transportzone-profiles/{transportzone-profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportZoneProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_transport_zone_status(self, zone_id, **kwargs):  # noqa: E501
        """Get a Transport Zone&#39;s Current Runtime Status Information  # noqa: E501

        Returns information about a specified transport zone, including the number of logical switches in the transport zone, number of logical spitch ports assigned to the transport zone, and number of transport nodes in the transport zone.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transport_zone_status(zone_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str zone_id: (required)
        :return: TransportZoneStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_transport_zone_status_with_http_info(zone_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_transport_zone_status_with_http_info(zone_id, **kwargs)  # noqa: E501
            return data

    def get_transport_zone_status_with_http_info(self, zone_id, **kwargs):  # noqa: E501
        """Get a Transport Zone&#39;s Current Runtime Status Information  # noqa: E501

        Returns information about a specified transport zone, including the number of logical switches in the transport zone, number of logical spitch ports assigned to the transport zone, and number of transport nodes in the transport zone.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_transport_zone_status_with_http_info(zone_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str zone_id: (required)
        :return: TransportZoneStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['zone_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transport_zone_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'zone_id' is set
        if ('zone_id' not in params or
                params['zone_id'] is None):
            raise ValueError("Missing the required parameter `zone_id` when calling `get_transport_zone_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'zone_id' in params:
            path_params['zone-id'] = params['zone_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-zones/{zone-id}/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportZoneStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_bridge_clusters(self, **kwargs):  # noqa: E501
        """List All Bridge Clusters  # noqa: E501

        Returns information about all configured bridge clusters   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_bridge_clusters(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: BridgeClusterListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_bridge_clusters_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_bridge_clusters_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_bridge_clusters_with_http_info(self, **kwargs):  # noqa: E501
        """List All Bridge Clusters  # noqa: E501

        Returns information about all configured bridge clusters   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_bridge_clusters_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: BridgeClusterListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_bridge_clusters" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_bridge_clusters`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_bridge_clusters`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/bridge-clusters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BridgeClusterListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_bridge_endpoints(self, **kwargs):  # noqa: E501
        """List All Bridge Endpoints  # noqa: E501

        Returns information about all configured bridge endoints   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_bridge_endpoints(async=True)
        >>> result = thread.get()

        :param async bool
        :param str bridge_cluster_id: Bridge Cluster Identifier
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str logical_switch_id: Logical Switch Identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: BridgeEndpointListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_bridge_endpoints_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_bridge_endpoints_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_bridge_endpoints_with_http_info(self, **kwargs):  # noqa: E501
        """List All Bridge Endpoints  # noqa: E501

        Returns information about all configured bridge endoints   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_bridge_endpoints_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str bridge_cluster_id: Bridge Cluster Identifier
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str logical_switch_id: Logical Switch Identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: BridgeEndpointListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bridge_cluster_id', 'cursor', 'included_fields', 'logical_switch_id', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_bridge_endpoints" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_bridge_endpoints`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_bridge_endpoints`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'bridge_cluster_id' in params:
            query_params.append(('bridge_cluster_id', params['bridge_cluster_id']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'logical_switch_id' in params:
            query_params.append(('logical_switch_id', params['logical_switch_id']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/bridge-endpoints', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BridgeEndpointListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_cluster_profiles(self, **kwargs):  # noqa: E501
        """List Cluster Profiles  # noqa: E501

        Returns paginated list of cluster profiles Cluster profiles define policies for edge cluster and bridge cluster.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_cluster_profiles(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool include_system_owned: Whether the list result contains system resources
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str resource_type: Supported cluster profiles.
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ClusterProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_cluster_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_cluster_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_cluster_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """List Cluster Profiles  # noqa: E501

        Returns paginated list of cluster profiles Cluster profiles define policies for edge cluster and bridge cluster.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_cluster_profiles_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool include_system_owned: Whether the list result contains system resources
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str resource_type: Supported cluster profiles.
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ClusterProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'include_system_owned', 'included_fields', 'page_size', 'resource_type', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_cluster_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_cluster_profiles`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_cluster_profiles`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'include_system_owned' in params:
            query_params.append(('include_system_owned', params['include_system_owned']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'resource_type' in params:
            query_params.append(('resource_type', params['resource_type']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterProfileListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_compute_collection_transport_node_templates(self, **kwargs):  # noqa: E501
        """List compute collection transportnode templates  # noqa: E501

        Returns all eligible compute collection transportnode templates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_compute_collection_transport_node_templates(async=True)
        >>> result = thread.get()

        :param async bool
        :param str compute_collection_id: Compute collection id
        :return: TransportNodeTemplateListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_compute_collection_transport_node_templates_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_compute_collection_transport_node_templates_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_compute_collection_transport_node_templates_with_http_info(self, **kwargs):  # noqa: E501
        """List compute collection transportnode templates  # noqa: E501

        Returns all eligible compute collection transportnode templates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_compute_collection_transport_node_templates_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str compute_collection_id: Compute collection id
        :return: TransportNodeTemplateListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['compute_collection_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_compute_collection_transport_node_templates" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'compute_collection_id' in params:
            query_params.append(('compute_collection_id', params['compute_collection_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/compute-collection-transport-node-templates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNodeTemplateListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_edge_clusters(self, **kwargs):  # noqa: E501
        """List Edge Clusters  # noqa: E501

        Returns information about the configured edge clusters, which enable you to group together transport nodes of the type EdgeNode and apply fabric profiles to all members of the edge cluster. Each edge node can participate in only one edge cluster.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_edge_clusters(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EdgeClusterListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_edge_clusters_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_edge_clusters_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_edge_clusters_with_http_info(self, **kwargs):  # noqa: E501
        """List Edge Clusters  # noqa: E501

        Returns information about the configured edge clusters, which enable you to group together transport nodes of the type EdgeNode and apply fabric profiles to all members of the edge cluster. Each edge node can participate in only one edge cluster.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_edge_clusters_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EdgeClusterListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_edge_clusters" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_edge_clusters`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_edge_clusters`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/edge-clusters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EdgeClusterListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_host_switch_profiles(self, **kwargs):  # noqa: E501
        """List Hostswitch Profiles  # noqa: E501

        Returns information about the configured hostswitch profiles. Hostswitch profiles define networking policies for hostswitches (sometimes referred to as bridges in OVS). Currently, only uplink teaming is supported. Uplink teaming allows NSX to load balance traffic across different physical NICs (PNICs) on the hypervisor hosts. Multiple teaming policies are supported, including LACP active, LACP passive, load balancing based on source ID, and failover order.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_host_switch_profiles(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str hostswitch_profile_type: Supported HostSwitch profiles.
        :param bool include_system_owned: Whether the list result contains system resources
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: HostSwitchProfilesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_host_switch_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_host_switch_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_host_switch_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """List Hostswitch Profiles  # noqa: E501

        Returns information about the configured hostswitch profiles. Hostswitch profiles define networking policies for hostswitches (sometimes referred to as bridges in OVS). Currently, only uplink teaming is supported. Uplink teaming allows NSX to load balance traffic across different physical NICs (PNICs) on the hypervisor hosts. Multiple teaming policies are supported, including LACP active, LACP passive, load balancing based on source ID, and failover order.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_host_switch_profiles_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str hostswitch_profile_type: Supported HostSwitch profiles.
        :param bool include_system_owned: Whether the list result contains system resources
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: HostSwitchProfilesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'hostswitch_profile_type', 'include_system_owned', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_host_switch_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_host_switch_profiles`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_host_switch_profiles`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'hostswitch_profile_type' in params:
            query_params.append(('hostswitch_profile_type', params['hostswitch_profile_type']))  # noqa: E501
        if 'include_system_owned' in params:
            query_params.append(('include_system_owned', params['include_system_owned']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/host-switch-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HostSwitchProfilesListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_neighbor_properties(self, node_id, **kwargs):  # noqa: E501
        """List LLDP Neighbor Properties  # noqa: E501

        List LLDP Neighbor Properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_neighbor_properties(node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: ID of transport node (required)
        :return: InterfaceNeighborPropertyListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_neighbor_properties_with_http_info(node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_neighbor_properties_with_http_info(node_id, **kwargs)  # noqa: E501
            return data

    def list_neighbor_properties_with_http_info(self, node_id, **kwargs):  # noqa: E501
        """List LLDP Neighbor Properties  # noqa: E501

        List LLDP Neighbor Properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_neighbor_properties_with_http_info(node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: ID of transport node (required)
        :return: InterfaceNeighborPropertyListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_neighbor_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `list_neighbor_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/lldp/transport-nodes/{node-id}/interfaces', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InterfaceNeighborPropertyListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_transport_nodes(self, **kwargs):  # noqa: E501
        """List Transport Nodes  # noqa: E501

        Returns information about all transport nodes. A transport node is a fabric node (host or edge) that contains hostswitches. A hostswitch can have virtual machines connected to them.  Because each transport node has HostSwitches, transport nodes can also have virtual tunnel endpoints, which means that they can be part of the overlay.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_transport_nodes(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool in_maintenance_mode: maintenance mode flag
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str node_id: node identifier
        :param str node_ip: Fabric node IP address
        :param str node_types: a list of fabric node types separated by comma or a single type
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str transport_zone_id: Transport zone identifier
        :return: TransportNodeListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_transport_nodes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_transport_nodes_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_transport_nodes_with_http_info(self, **kwargs):  # noqa: E501
        """List Transport Nodes  # noqa: E501

        Returns information about all transport nodes. A transport node is a fabric node (host or edge) that contains hostswitches. A hostswitch can have virtual machines connected to them.  Because each transport node has HostSwitches, transport nodes can also have virtual tunnel endpoints, which means that they can be part of the overlay.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_transport_nodes_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool in_maintenance_mode: maintenance mode flag
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str node_id: node identifier
        :param str node_ip: Fabric node IP address
        :param str node_types: a list of fabric node types separated by comma or a single type
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str transport_zone_id: Transport zone identifier
        :return: TransportNodeListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'in_maintenance_mode', 'included_fields', 'node_id', 'node_ip', 'node_types', 'page_size', 'sort_ascending', 'sort_by', 'transport_zone_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_transport_nodes" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_transport_nodes`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_transport_nodes`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'in_maintenance_mode' in params:
            query_params.append(('in_maintenance_mode', params['in_maintenance_mode']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'node_id' in params:
            query_params.append(('node_id', params['node_id']))  # noqa: E501
        if 'node_ip' in params:
            query_params.append(('node_ip', params['node_ip']))  # noqa: E501
        if 'node_types' in params:
            query_params.append(('node_types', params['node_types']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'transport_zone_id' in params:
            query_params.append(('transport_zone_id', params['transport_zone_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNodeListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_transport_nodes_by_state(self, **kwargs):  # noqa: E501
        """List transport nodes by realized state  # noqa: E501

        Returns a list of transport node states that have realized state as provided as query parameter   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_transport_nodes_by_state(async=True)
        >>> result = thread.get()

        :param async bool
        :param str mm_state: maintenance mode state
        :param str status: Realized state of transport nodes
        :param str vtep_ip: Virtual tunnel endpoint ip address of transport node
        :return: TransportNodeStateListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_transport_nodes_by_state_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_transport_nodes_by_state_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_transport_nodes_by_state_with_http_info(self, **kwargs):  # noqa: E501
        """List transport nodes by realized state  # noqa: E501

        Returns a list of transport node states that have realized state as provided as query parameter   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_transport_nodes_by_state_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str mm_state: maintenance mode state
        :param str status: Realized state of transport nodes
        :param str vtep_ip: Virtual tunnel endpoint ip address of transport node
        :return: TransportNodeStateListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mm_state', 'status', 'vtep_ip']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_transport_nodes_by_state" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'mm_state' in params:
            query_params.append(('mm_state', params['mm_state']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'vtep_ip' in params:
            query_params.append(('vtep_ip', params['vtep_ip']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNodeStateListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_transport_zone_profiles(self, **kwargs):  # noqa: E501
        """List transport zone profiles  # noqa: E501

        Returns information about the configured transport zone profiles. Transport zone profiles define networking policies for transport zones and transport zone endpoints.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_transport_zone_profiles(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool include_system_owned: Whether the list result contains system resources
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str resource_type: comma-separated list of transport zone profile types, e.g. ?resource_type=BfdHealthMonitoringProfile
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: TransportZoneProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_transport_zone_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_transport_zone_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_transport_zone_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """List transport zone profiles  # noqa: E501

        Returns information about the configured transport zone profiles. Transport zone profiles define networking policies for transport zones and transport zone endpoints.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_transport_zone_profiles_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool include_system_owned: Whether the list result contains system resources
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str resource_type: comma-separated list of transport zone profile types, e.g. ?resource_type=BfdHealthMonitoringProfile
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: TransportZoneProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'include_system_owned', 'included_fields', 'page_size', 'resource_type', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_transport_zone_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_transport_zone_profiles`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_transport_zone_profiles`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'include_system_owned' in params:
            query_params.append(('include_system_owned', params['include_system_owned']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'resource_type' in params:
            query_params.append(('resource_type', params['resource_type']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transportzone-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportZoneProfileListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_transport_zones(self, **kwargs):  # noqa: E501
        """List Transport Zones  # noqa: E501

        Returns information about configured transport zones. NSX requires at least one transport zone. NSX uses transport zones to provide connectivity based on the topology of the underlying network, trust zones, or organizational separations. For example, you might have hypervisors that use one network for management traffic and a different network for VM traffic. This architecture would require two transport zones. The combination of transport zones plus transport connectors enables NSX to form tunnels between hypervisors. Transport zones define which interfaces on the hypervisors can communicate with which other interfaces on other hypervisors to establish overlay tunnels or provide connectivity to a VLAN. A logical switch can be in one (and only one) transport zone. This means that all of a switch's interfaces must be in the same transport zone. However, each hypervisor virtual switch (OVS or VDS) has multiple interfaces (connectors), and each connector can be attached to a different logical switch. For example, on a single hypervisor with two connectors, connector A can be attached to logical switch 1 in transport zone A, while connector B is attached to logical switch 2 in transport zone B. In this way, a single hypervisor can participate in multiple transport zones. The API for creating a transport zone requires that a single host switch be specified for each transport zone, and multiple transport zones can share the same host switch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_transport_zones(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: TransportZoneListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_transport_zones_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_transport_zones_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_transport_zones_with_http_info(self, **kwargs):  # noqa: E501
        """List Transport Zones  # noqa: E501

        Returns information about configured transport zones. NSX requires at least one transport zone. NSX uses transport zones to provide connectivity based on the topology of the underlying network, trust zones, or organizational separations. For example, you might have hypervisors that use one network for management traffic and a different network for VM traffic. This architecture would require two transport zones. The combination of transport zones plus transport connectors enables NSX to form tunnels between hypervisors. Transport zones define which interfaces on the hypervisors can communicate with which other interfaces on other hypervisors to establish overlay tunnels or provide connectivity to a VLAN. A logical switch can be in one (and only one) transport zone. This means that all of a switch's interfaces must be in the same transport zone. However, each hypervisor virtual switch (OVS or VDS) has multiple interfaces (connectors), and each connector can be attached to a different logical switch. For example, on a single hypervisor with two connectors, connector A can be attached to logical switch 1 in transport zone A, while connector B is attached to logical switch 2 in transport zone B. In this way, a single hypervisor can participate in multiple transport zones. The API for creating a transport zone requires that a single host switch be specified for each transport zone, and multiple transport zones can share the same host switch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_transport_zones_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: TransportZoneListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_transport_zones" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_transport_zones`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_transport_zones`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-zones', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportZoneListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_edge_cluster(self, edge_cluster_id, **kwargs):  # noqa: E501
        """Read Edge Cluster  # noqa: E501

        Returns information about the specified edge cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_edge_cluster(edge_cluster_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str edge_cluster_id: (required)
        :return: EdgeCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_edge_cluster_with_http_info(edge_cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_edge_cluster_with_http_info(edge_cluster_id, **kwargs)  # noqa: E501
            return data

    def read_edge_cluster_with_http_info(self, edge_cluster_id, **kwargs):  # noqa: E501
        """Read Edge Cluster  # noqa: E501

        Returns information about the specified edge cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_edge_cluster_with_http_info(edge_cluster_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str edge_cluster_id: (required)
        :return: EdgeCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['edge_cluster_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_edge_cluster" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'edge_cluster_id' is set
        if ('edge_cluster_id' not in params or
                params['edge_cluster_id'] is None):
            raise ValueError("Missing the required parameter `edge_cluster_id` when calling `read_edge_cluster`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'edge_cluster_id' in params:
            path_params['edge-cluster-id'] = params['edge_cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/edge-clusters/{edge-cluster-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EdgeCluster',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_neighbor_properties(self, node_id, interface_name, **kwargs):  # noqa: E501
        """Read LLDP Neighbor Properties  # noqa: E501

        Read LLDP Neighbor Properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_neighbor_properties(node_id, interface_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: ID of transport node (required)
        :param str interface_name: Interface name to read (required)
        :return: InterfaceNeighborProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_neighbor_properties_with_http_info(node_id, interface_name, **kwargs)  # noqa: E501
        else:
            (data) = self.read_neighbor_properties_with_http_info(node_id, interface_name, **kwargs)  # noqa: E501
            return data

    def read_neighbor_properties_with_http_info(self, node_id, interface_name, **kwargs):  # noqa: E501
        """Read LLDP Neighbor Properties  # noqa: E501

        Read LLDP Neighbor Properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_neighbor_properties_with_http_info(node_id, interface_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: ID of transport node (required)
        :param str interface_name: Interface name to read (required)
        :return: InterfaceNeighborProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id', 'interface_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_neighbor_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `read_neighbor_properties`")  # noqa: E501
        # verify the required parameter 'interface_name' is set
        if ('interface_name' not in params or
                params['interface_name'] is None):
            raise ValueError("Missing the required parameter `interface_name` when calling `read_neighbor_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501
        if 'interface_name' in params:
            path_params['interface-name'] = params['interface_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/lldp/transport-nodes/{node-id}/interfaces/{interface-name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InterfaceNeighborProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replace_edge_cluster_member_transport_node_replace_transport_node(self, edge_cluster_id, edge_cluster_member_transport_node, **kwargs):  # noqa: E501
        """Replace the transport node in the specified member of the edge-cluster  # noqa: E501

        Replace the transport node in the specified member of the edge-cluster. This is a disruptive action. This will move all the LogicalRouterPorts(uplink and routerLink) host on the old transport_node to the new transport_node. The transportNode cannot be present in another member of any edgeClusters.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.replace_edge_cluster_member_transport_node_replace_transport_node(edge_cluster_id, edge_cluster_member_transport_node, async=True)
        >>> result = thread.get()

        :param async bool
        :param str edge_cluster_id: (required)
        :param EdgeClusterMemberTransportNode edge_cluster_member_transport_node: (required)
        :return: EdgeCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.replace_edge_cluster_member_transport_node_replace_transport_node_with_http_info(edge_cluster_id, edge_cluster_member_transport_node, **kwargs)  # noqa: E501
        else:
            (data) = self.replace_edge_cluster_member_transport_node_replace_transport_node_with_http_info(edge_cluster_id, edge_cluster_member_transport_node, **kwargs)  # noqa: E501
            return data

    def replace_edge_cluster_member_transport_node_replace_transport_node_with_http_info(self, edge_cluster_id, edge_cluster_member_transport_node, **kwargs):  # noqa: E501
        """Replace the transport node in the specified member of the edge-cluster  # noqa: E501

        Replace the transport node in the specified member of the edge-cluster. This is a disruptive action. This will move all the LogicalRouterPorts(uplink and routerLink) host on the old transport_node to the new transport_node. The transportNode cannot be present in another member of any edgeClusters.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.replace_edge_cluster_member_transport_node_replace_transport_node_with_http_info(edge_cluster_id, edge_cluster_member_transport_node, async=True)
        >>> result = thread.get()

        :param async bool
        :param str edge_cluster_id: (required)
        :param EdgeClusterMemberTransportNode edge_cluster_member_transport_node: (required)
        :return: EdgeCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['edge_cluster_id', 'edge_cluster_member_transport_node']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_edge_cluster_member_transport_node_replace_transport_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'edge_cluster_id' is set
        if ('edge_cluster_id' not in params or
                params['edge_cluster_id'] is None):
            raise ValueError("Missing the required parameter `edge_cluster_id` when calling `replace_edge_cluster_member_transport_node_replace_transport_node`")  # noqa: E501
        # verify the required parameter 'edge_cluster_member_transport_node' is set
        if ('edge_cluster_member_transport_node' not in params or
                params['edge_cluster_member_transport_node'] is None):
            raise ValueError("Missing the required parameter `edge_cluster_member_transport_node` when calling `replace_edge_cluster_member_transport_node_replace_transport_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'edge_cluster_id' in params:
            path_params['edge-cluster-id'] = params['edge_cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'edge_cluster_member_transport_node' in params:
            body_params = params['edge_cluster_member_transport_node']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/edge-clusters/{edge-cluster-id}?action=replace_transport_node', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EdgeCluster',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def resync_transport_node_resync_host_config(self, transportnode_id, **kwargs):  # noqa: E501
        """Resync a Transport Node  # noqa: E501

        Resync the TransportNode configuration on a host. It is similar to updating the TransportNode with existing configuration, but force synce these configurations to the host (no backend optimizations).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.resync_transport_node_resync_host_config(transportnode_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str transportnode_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.resync_transport_node_resync_host_config_with_http_info(transportnode_id, **kwargs)  # noqa: E501
        else:
            (data) = self.resync_transport_node_resync_host_config_with_http_info(transportnode_id, **kwargs)  # noqa: E501
            return data

    def resync_transport_node_resync_host_config_with_http_info(self, transportnode_id, **kwargs):  # noqa: E501
        """Resync a Transport Node  # noqa: E501

        Resync the TransportNode configuration on a host. It is similar to updating the TransportNode with existing configuration, but force synce these configurations to the host (no backend optimizations).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.resync_transport_node_resync_host_config_with_http_info(transportnode_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str transportnode_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transportnode_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resync_transport_node_resync_host_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transportnode_id' is set
        if ('transportnode_id' not in params or
                params['transportnode_id'] is None):
            raise ValueError("Missing the required parameter `transportnode_id` when calling `resync_transport_node_resync_host_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transportnode_id' in params:
            path_params['transportnode-id'] = params['transportnode_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transportnode-id}?action=resync_host_config', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_bridge_cluster(self, bridgecluster_id, bridge_cluster, **kwargs):  # noqa: E501
        """Update a Bridge Cluster  # noqa: E501

        Modifies a existing bridge cluster. One of more transport nodes can be added or removed from the bridge cluster using this API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_bridge_cluster(bridgecluster_id, bridge_cluster, async=True)
        >>> result = thread.get()

        :param async bool
        :param str bridgecluster_id: (required)
        :param BridgeCluster bridge_cluster: (required)
        :return: BridgeCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_bridge_cluster_with_http_info(bridgecluster_id, bridge_cluster, **kwargs)  # noqa: E501
        else:
            (data) = self.update_bridge_cluster_with_http_info(bridgecluster_id, bridge_cluster, **kwargs)  # noqa: E501
            return data

    def update_bridge_cluster_with_http_info(self, bridgecluster_id, bridge_cluster, **kwargs):  # noqa: E501
        """Update a Bridge Cluster  # noqa: E501

        Modifies a existing bridge cluster. One of more transport nodes can be added or removed from the bridge cluster using this API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_bridge_cluster_with_http_info(bridgecluster_id, bridge_cluster, async=True)
        >>> result = thread.get()

        :param async bool
        :param str bridgecluster_id: (required)
        :param BridgeCluster bridge_cluster: (required)
        :return: BridgeCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bridgecluster_id', 'bridge_cluster']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_bridge_cluster" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bridgecluster_id' is set
        if ('bridgecluster_id' not in params or
                params['bridgecluster_id'] is None):
            raise ValueError("Missing the required parameter `bridgecluster_id` when calling `update_bridge_cluster`")  # noqa: E501
        # verify the required parameter 'bridge_cluster' is set
        if ('bridge_cluster' not in params or
                params['bridge_cluster'] is None):
            raise ValueError("Missing the required parameter `bridge_cluster` when calling `update_bridge_cluster`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bridgecluster_id' in params:
            path_params['bridgecluster-id'] = params['bridgecluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bridge_cluster' in params:
            body_params = params['bridge_cluster']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/bridge-clusters/{bridgecluster-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BridgeCluster',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_bridge_endpoint(self, bridgeendpoint_id, bridge_endpoint, **kwargs):  # noqa: E501
        """Update a Bridge Endpoint  # noqa: E501

        Modifies a existing bridge endpoint.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_bridge_endpoint(bridgeendpoint_id, bridge_endpoint, async=True)
        >>> result = thread.get()

        :param async bool
        :param str bridgeendpoint_id: (required)
        :param BridgeEndpoint bridge_endpoint: (required)
        :return: BridgeEndpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_bridge_endpoint_with_http_info(bridgeendpoint_id, bridge_endpoint, **kwargs)  # noqa: E501
        else:
            (data) = self.update_bridge_endpoint_with_http_info(bridgeendpoint_id, bridge_endpoint, **kwargs)  # noqa: E501
            return data

    def update_bridge_endpoint_with_http_info(self, bridgeendpoint_id, bridge_endpoint, **kwargs):  # noqa: E501
        """Update a Bridge Endpoint  # noqa: E501

        Modifies a existing bridge endpoint.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_bridge_endpoint_with_http_info(bridgeendpoint_id, bridge_endpoint, async=True)
        >>> result = thread.get()

        :param async bool
        :param str bridgeendpoint_id: (required)
        :param BridgeEndpoint bridge_endpoint: (required)
        :return: BridgeEndpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bridgeendpoint_id', 'bridge_endpoint']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_bridge_endpoint" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bridgeendpoint_id' is set
        if ('bridgeendpoint_id' not in params or
                params['bridgeendpoint_id'] is None):
            raise ValueError("Missing the required parameter `bridgeendpoint_id` when calling `update_bridge_endpoint`")  # noqa: E501
        # verify the required parameter 'bridge_endpoint' is set
        if ('bridge_endpoint' not in params or
                params['bridge_endpoint'] is None):
            raise ValueError("Missing the required parameter `bridge_endpoint` when calling `update_bridge_endpoint`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bridgeendpoint_id' in params:
            path_params['bridgeendpoint-id'] = params['bridgeendpoint_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bridge_endpoint' in params:
            body_params = params['bridge_endpoint']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/bridge-endpoints/{bridgeendpoint-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BridgeEndpoint',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cluster_profile(self, cluster_profile_id, cluster_profile, **kwargs):  # noqa: E501
        """Update a cluster profile  # noqa: E501

        Modifie a specified cluster profile. The body of the PUT request must include the resource_type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_cluster_profile(cluster_profile_id, cluster_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str cluster_profile_id: (required)
        :param ClusterProfile cluster_profile: (required)
        :return: ClusterProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_cluster_profile_with_http_info(cluster_profile_id, cluster_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.update_cluster_profile_with_http_info(cluster_profile_id, cluster_profile, **kwargs)  # noqa: E501
            return data

    def update_cluster_profile_with_http_info(self, cluster_profile_id, cluster_profile, **kwargs):  # noqa: E501
        """Update a cluster profile  # noqa: E501

        Modifie a specified cluster profile. The body of the PUT request must include the resource_type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_cluster_profile_with_http_info(cluster_profile_id, cluster_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str cluster_profile_id: (required)
        :param ClusterProfile cluster_profile: (required)
        :return: ClusterProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_profile_id', 'cluster_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cluster_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_profile_id' is set
        if ('cluster_profile_id' not in params or
                params['cluster_profile_id'] is None):
            raise ValueError("Missing the required parameter `cluster_profile_id` when calling `update_cluster_profile`")  # noqa: E501
        # verify the required parameter 'cluster_profile' is set
        if ('cluster_profile' not in params or
                params['cluster_profile'] is None):
            raise ValueError("Missing the required parameter `cluster_profile` when calling `update_cluster_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_profile_id' in params:
            path_params['cluster-profile-id'] = params['cluster_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_profile' in params:
            body_params = params['cluster_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster-profiles/{cluster-profile-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_compute_collection_transport_node_template(self, template_id, compute_collection_transport_node_template, **kwargs):  # noqa: E501
        """Update compute collection transportnode template  # noqa: E501

        Update configuration of compute collection transportnode template. Compute_collection_id isn't allowed to be changed since it represents the association between ComputeCollection and this template. This is determined when ComputeCollectionTransportNodeTemplate got created.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_compute_collection_transport_node_template(template_id, compute_collection_transport_node_template, async=True)
        >>> result = thread.get()

        :param async bool
        :param str template_id: (required)
        :param ComputeCollectionTransportNodeTemplate compute_collection_transport_node_template: (required)
        :return: ComputeCollectionTransportNodeTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_compute_collection_transport_node_template_with_http_info(template_id, compute_collection_transport_node_template, **kwargs)  # noqa: E501
        else:
            (data) = self.update_compute_collection_transport_node_template_with_http_info(template_id, compute_collection_transport_node_template, **kwargs)  # noqa: E501
            return data

    def update_compute_collection_transport_node_template_with_http_info(self, template_id, compute_collection_transport_node_template, **kwargs):  # noqa: E501
        """Update compute collection transportnode template  # noqa: E501

        Update configuration of compute collection transportnode template. Compute_collection_id isn't allowed to be changed since it represents the association between ComputeCollection and this template. This is determined when ComputeCollectionTransportNodeTemplate got created.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_compute_collection_transport_node_template_with_http_info(template_id, compute_collection_transport_node_template, async=True)
        >>> result = thread.get()

        :param async bool
        :param str template_id: (required)
        :param ComputeCollectionTransportNodeTemplate compute_collection_transport_node_template: (required)
        :return: ComputeCollectionTransportNodeTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['template_id', 'compute_collection_transport_node_template']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_compute_collection_transport_node_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'template_id' is set
        if ('template_id' not in params or
                params['template_id'] is None):
            raise ValueError("Missing the required parameter `template_id` when calling `update_compute_collection_transport_node_template`")  # noqa: E501
        # verify the required parameter 'compute_collection_transport_node_template' is set
        if ('compute_collection_transport_node_template' not in params or
                params['compute_collection_transport_node_template'] is None):
            raise ValueError("Missing the required parameter `compute_collection_transport_node_template` when calling `update_compute_collection_transport_node_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in params:
            path_params['template-id'] = params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'compute_collection_transport_node_template' in params:
            body_params = params['compute_collection_transport_node_template']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/compute-collection-transport-node-templates/{template-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComputeCollectionTransportNodeTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_edge_cluster(self, edge_cluster_id, edge_cluster, **kwargs):  # noqa: E501
        """Update Edge Cluster  # noqa: E501

        Modifies the specified edge cluster. Modifiable parameters include the description, display_name, transport-node-id. If the optional fabric_profile_binding is included, resource_type and profile_id are required. User should do a GET on the edge-cluster and obtain the payload and retain the member_index of the existing members as returning in the GET output. For new member additions, the member_index cannot be defined by the user, user can read the system allocated index to the new member in the output of this API call or by doing a GET call. User cannot use this PUT api to replace the transport_node of an existing member because this is a disruption action, we have exposed a explicit API for doing so, refer to \"ReplaceEdgeClusterMemberTransportNode\" EdgeCluster only supports homogeneous members. The TransportNodes backed by EdgeNode are only allowed in cluster members. DeploymentType (VIRTUAL_MACHINE|PHYSICAL_MACHINE) of these EdgeNodes should be same.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_edge_cluster(edge_cluster_id, edge_cluster, async=True)
        >>> result = thread.get()

        :param async bool
        :param str edge_cluster_id: (required)
        :param EdgeCluster edge_cluster: (required)
        :return: EdgeCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_edge_cluster_with_http_info(edge_cluster_id, edge_cluster, **kwargs)  # noqa: E501
        else:
            (data) = self.update_edge_cluster_with_http_info(edge_cluster_id, edge_cluster, **kwargs)  # noqa: E501
            return data

    def update_edge_cluster_with_http_info(self, edge_cluster_id, edge_cluster, **kwargs):  # noqa: E501
        """Update Edge Cluster  # noqa: E501

        Modifies the specified edge cluster. Modifiable parameters include the description, display_name, transport-node-id. If the optional fabric_profile_binding is included, resource_type and profile_id are required. User should do a GET on the edge-cluster and obtain the payload and retain the member_index of the existing members as returning in the GET output. For new member additions, the member_index cannot be defined by the user, user can read the system allocated index to the new member in the output of this API call or by doing a GET call. User cannot use this PUT api to replace the transport_node of an existing member because this is a disruption action, we have exposed a explicit API for doing so, refer to \"ReplaceEdgeClusterMemberTransportNode\" EdgeCluster only supports homogeneous members. The TransportNodes backed by EdgeNode are only allowed in cluster members. DeploymentType (VIRTUAL_MACHINE|PHYSICAL_MACHINE) of these EdgeNodes should be same.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_edge_cluster_with_http_info(edge_cluster_id, edge_cluster, async=True)
        >>> result = thread.get()

        :param async bool
        :param str edge_cluster_id: (required)
        :param EdgeCluster edge_cluster: (required)
        :return: EdgeCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['edge_cluster_id', 'edge_cluster']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_edge_cluster" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'edge_cluster_id' is set
        if ('edge_cluster_id' not in params or
                params['edge_cluster_id'] is None):
            raise ValueError("Missing the required parameter `edge_cluster_id` when calling `update_edge_cluster`")  # noqa: E501
        # verify the required parameter 'edge_cluster' is set
        if ('edge_cluster' not in params or
                params['edge_cluster'] is None):
            raise ValueError("Missing the required parameter `edge_cluster` when calling `update_edge_cluster`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'edge_cluster_id' in params:
            path_params['edge-cluster-id'] = params['edge_cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'edge_cluster' in params:
            body_params = params['edge_cluster']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/edge-clusters/{edge-cluster-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EdgeCluster',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_host_switch_profile(self, host_switch_profile_id, base_host_switch_profile, **kwargs):  # noqa: E501
        """Update a Hostswitch Profile  # noqa: E501

        Modifies a specified hostswitch profile. The body of the PUT request must include the resource_type. For uplink profiles, the put request must also include teaming parameters. Modifiable attributes include display_name, mtu, and transport_vlan. For uplink teaming policies, uplink_name and policy are also modifiable.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_host_switch_profile(host_switch_profile_id, base_host_switch_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str host_switch_profile_id: (required)
        :param BaseHostSwitchProfile base_host_switch_profile: (required)
        :return: BaseHostSwitchProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_host_switch_profile_with_http_info(host_switch_profile_id, base_host_switch_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.update_host_switch_profile_with_http_info(host_switch_profile_id, base_host_switch_profile, **kwargs)  # noqa: E501
            return data

    def update_host_switch_profile_with_http_info(self, host_switch_profile_id, base_host_switch_profile, **kwargs):  # noqa: E501
        """Update a Hostswitch Profile  # noqa: E501

        Modifies a specified hostswitch profile. The body of the PUT request must include the resource_type. For uplink profiles, the put request must also include teaming parameters. Modifiable attributes include display_name, mtu, and transport_vlan. For uplink teaming policies, uplink_name and policy are also modifiable.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_host_switch_profile_with_http_info(host_switch_profile_id, base_host_switch_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str host_switch_profile_id: (required)
        :param BaseHostSwitchProfile base_host_switch_profile: (required)
        :return: BaseHostSwitchProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['host_switch_profile_id', 'base_host_switch_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_host_switch_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'host_switch_profile_id' is set
        if ('host_switch_profile_id' not in params or
                params['host_switch_profile_id'] is None):
            raise ValueError("Missing the required parameter `host_switch_profile_id` when calling `update_host_switch_profile`")  # noqa: E501
        # verify the required parameter 'base_host_switch_profile' is set
        if ('base_host_switch_profile' not in params or
                params['base_host_switch_profile'] is None):
            raise ValueError("Missing the required parameter `base_host_switch_profile` when calling `update_host_switch_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'host_switch_profile_id' in params:
            path_params['host-switch-profile-id'] = params['host_switch_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'base_host_switch_profile' in params:
            body_params = params['base_host_switch_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/host-switch-profiles/{host-switch-profile-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BaseHostSwitchProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_transport_node(self, transportnode_id, transport_node, **kwargs):  # noqa: E501
        """Update a Transport Node  # noqa: E501

        Modifies the transport node information. Modifiable parameters include the host_switch_spec and transport_zone_endpoints. The host_switch_name field must match the host_switch_name value specified in the transport zone (API: transport-zones). You must create the associated uplink profile (API: host-switch-profiles) before you can specify an uplink_name here. If the host is an ESX and has only one physical NIC being used by a vSphere standard switch, TransportNodeUpdateParameters should be used to migrate the management interface and the physical NIC into a logical switch that is in a transport zone this transport node will join or has already joined. If the migration is already done, TransportNodeUpdateParameters can also be used to migrate the management interface and the physical NIC back to a vSphere standard switch. In other cases, the TransportNodeUpdateParameters should NOT be used. When updating transport node user should follow pattern where he should fetch the existing transport node and then only modify the required properties keeping other properties as is. For API backward compatibility, property host_switches will be still returned in response and will contain the configuration matching the one in host_switch_spec. In update call user should only modify configuration in either host_switch_spec or host_switches, but not both. Property host_switch_spec should be preferred over deprecated host_switches property when creating or updating transport nodes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transport_node(transportnode_id, transport_node, async=True)
        >>> result = thread.get()

        :param async bool
        :param str transportnode_id: (required)
        :param TransportNode transport_node: (required)
        :param str esx_mgmt_if_migration_dest: The ID of the network to which the management interface on ESX will be migrated. Only logical switch UUID or vSphere Standard Switch portgroup name is supported.
        :param str if_id: The ID (for example, vmk0) of the management interface on ESX to migrate.
        :return: TransportNode
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_transport_node_with_http_info(transportnode_id, transport_node, **kwargs)  # noqa: E501
        else:
            (data) = self.update_transport_node_with_http_info(transportnode_id, transport_node, **kwargs)  # noqa: E501
            return data

    def update_transport_node_with_http_info(self, transportnode_id, transport_node, **kwargs):  # noqa: E501
        """Update a Transport Node  # noqa: E501

        Modifies the transport node information. Modifiable parameters include the host_switch_spec and transport_zone_endpoints. The host_switch_name field must match the host_switch_name value specified in the transport zone (API: transport-zones). You must create the associated uplink profile (API: host-switch-profiles) before you can specify an uplink_name here. If the host is an ESX and has only one physical NIC being used by a vSphere standard switch, TransportNodeUpdateParameters should be used to migrate the management interface and the physical NIC into a logical switch that is in a transport zone this transport node will join or has already joined. If the migration is already done, TransportNodeUpdateParameters can also be used to migrate the management interface and the physical NIC back to a vSphere standard switch. In other cases, the TransportNodeUpdateParameters should NOT be used. When updating transport node user should follow pattern where he should fetch the existing transport node and then only modify the required properties keeping other properties as is. For API backward compatibility, property host_switches will be still returned in response and will contain the configuration matching the one in host_switch_spec. In update call user should only modify configuration in either host_switch_spec or host_switches, but not both. Property host_switch_spec should be preferred over deprecated host_switches property when creating or updating transport nodes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transport_node_with_http_info(transportnode_id, transport_node, async=True)
        >>> result = thread.get()

        :param async bool
        :param str transportnode_id: (required)
        :param TransportNode transport_node: (required)
        :param str esx_mgmt_if_migration_dest: The ID of the network to which the management interface on ESX will be migrated. Only logical switch UUID or vSphere Standard Switch portgroup name is supported.
        :param str if_id: The ID (for example, vmk0) of the management interface on ESX to migrate.
        :return: TransportNode
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transportnode_id', 'transport_node', 'esx_mgmt_if_migration_dest', 'if_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_transport_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transportnode_id' is set
        if ('transportnode_id' not in params or
                params['transportnode_id'] is None):
            raise ValueError("Missing the required parameter `transportnode_id` when calling `update_transport_node`")  # noqa: E501
        # verify the required parameter 'transport_node' is set
        if ('transport_node' not in params or
                params['transport_node'] is None):
            raise ValueError("Missing the required parameter `transport_node` when calling `update_transport_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transportnode_id' in params:
            path_params['transportnode-id'] = params['transportnode_id']  # noqa: E501

        query_params = []
        if 'esx_mgmt_if_migration_dest' in params:
            query_params.append(('esx_mgmt_if_migration_dest', params['esx_mgmt_if_migration_dest']))  # noqa: E501
        if 'if_id' in params:
            query_params.append(('if_id', params['if_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transport_node' in params:
            body_params = params['transport_node']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transportnode-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportNode',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_transport_node_maintenance_mode(self, transportnode_id, **kwargs):  # noqa: E501
        """Update transport node maintenance mode  # noqa: E501

        Put transport node into maintenance mode or exit from maintenance mode.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transport_node_maintenance_mode(transportnode_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str transportnode_id: (required)
        :param str action:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_transport_node_maintenance_mode_with_http_info(transportnode_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_transport_node_maintenance_mode_with_http_info(transportnode_id, **kwargs)  # noqa: E501
            return data

    def update_transport_node_maintenance_mode_with_http_info(self, transportnode_id, **kwargs):  # noqa: E501
        """Update transport node maintenance mode  # noqa: E501

        Put transport node into maintenance mode or exit from maintenance mode.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transport_node_maintenance_mode_with_http_info(transportnode_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str transportnode_id: (required)
        :param str action:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transportnode_id', 'action']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_transport_node_maintenance_mode" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transportnode_id' is set
        if ('transportnode_id' not in params or
                params['transportnode_id'] is None):
            raise ValueError("Missing the required parameter `transportnode_id` when calling `update_transport_node_maintenance_mode`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transportnode_id' in params:
            path_params['transportnode-id'] = params['transportnode_id']  # noqa: E501

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-nodes/{transportnode-id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_transport_zone(self, zone_id, transport_zone, **kwargs):  # noqa: E501
        """Update a Transport Zone  # noqa: E501

        Updates an existing transport zone. Modifiable parameters are transport_type (VLAN or OVERLAY), description, and display_name. The request must include the existing host_switch_name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transport_zone(zone_id, transport_zone, async=True)
        >>> result = thread.get()

        :param async bool
        :param str zone_id: (required)
        :param TransportZone transport_zone: (required)
        :return: TransportZone
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_transport_zone_with_http_info(zone_id, transport_zone, **kwargs)  # noqa: E501
        else:
            (data) = self.update_transport_zone_with_http_info(zone_id, transport_zone, **kwargs)  # noqa: E501
            return data

    def update_transport_zone_with_http_info(self, zone_id, transport_zone, **kwargs):  # noqa: E501
        """Update a Transport Zone  # noqa: E501

        Updates an existing transport zone. Modifiable parameters are transport_type (VLAN or OVERLAY), description, and display_name. The request must include the existing host_switch_name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transport_zone_with_http_info(zone_id, transport_zone, async=True)
        >>> result = thread.get()

        :param async bool
        :param str zone_id: (required)
        :param TransportZone transport_zone: (required)
        :return: TransportZone
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['zone_id', 'transport_zone']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_transport_zone" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'zone_id' is set
        if ('zone_id' not in params or
                params['zone_id'] is None):
            raise ValueError("Missing the required parameter `zone_id` when calling `update_transport_zone`")  # noqa: E501
        # verify the required parameter 'transport_zone' is set
        if ('transport_zone' not in params or
                params['transport_zone'] is None):
            raise ValueError("Missing the required parameter `transport_zone` when calling `update_transport_zone`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'zone_id' in params:
            path_params['zone-id'] = params['zone_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transport_zone' in params:
            body_params = params['transport_zone']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transport-zones/{zone-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportZone',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_transport_zone_profile(self, transportzone_profile_id, transport_zone_profile, **kwargs):  # noqa: E501
        """Update a transport zone profile  # noqa: E501

        Modifies a specified transport zone profile. The body of the PUT request must include the resource_type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transport_zone_profile(transportzone_profile_id, transport_zone_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str transportzone_profile_id: (required)
        :param TransportZoneProfile transport_zone_profile: (required)
        :return: TransportZoneProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_transport_zone_profile_with_http_info(transportzone_profile_id, transport_zone_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.update_transport_zone_profile_with_http_info(transportzone_profile_id, transport_zone_profile, **kwargs)  # noqa: E501
            return data

    def update_transport_zone_profile_with_http_info(self, transportzone_profile_id, transport_zone_profile, **kwargs):  # noqa: E501
        """Update a transport zone profile  # noqa: E501

        Modifies a specified transport zone profile. The body of the PUT request must include the resource_type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transport_zone_profile_with_http_info(transportzone_profile_id, transport_zone_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str transportzone_profile_id: (required)
        :param TransportZoneProfile transport_zone_profile: (required)
        :return: TransportZoneProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transportzone_profile_id', 'transport_zone_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_transport_zone_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transportzone_profile_id' is set
        if ('transportzone_profile_id' not in params or
                params['transportzone_profile_id'] is None):
            raise ValueError("Missing the required parameter `transportzone_profile_id` when calling `update_transport_zone_profile`")  # noqa: E501
        # verify the required parameter 'transport_zone_profile' is set
        if ('transport_zone_profile' not in params or
                params['transport_zone_profile'] is None):
            raise ValueError("Missing the required parameter `transport_zone_profile` when calling `update_transport_zone_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transportzone_profile_id' in params:
            path_params['transportzone-profile-id'] = params['transportzone_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transport_zone_profile' in params:
            body_params = params['transport_zone_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/transportzone-profiles/{transportzone-profile-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransportZoneProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
