# coding: utf-8

"""
    NSX API

    VMware NSX REST API  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class PolicyApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_or_update_domain_deployment_map_for_infra(self, domain_id, domain_deployment_map_id, domain_deployment_map, **kwargs):  # noqa: E501
        """Create a new Domain Deployment Map under infra  # noqa: E501

        If the passed Domain Deployment Map does not already exist, create a new Domain Deployment Map. If it already exist, replace it.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_or_update_domain_deployment_map_for_infra(domain_id, domain_deployment_map_id, domain_deployment_map, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str domain_deployment_map_id: Domain Deployment Map ID (required)
        :param DomainDeploymentMap domain_deployment_map: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_or_update_domain_deployment_map_for_infra_with_http_info(domain_id, domain_deployment_map_id, domain_deployment_map, **kwargs)  # noqa: E501
        else:
            (data) = self.create_or_update_domain_deployment_map_for_infra_with_http_info(domain_id, domain_deployment_map_id, domain_deployment_map, **kwargs)  # noqa: E501
            return data

    def create_or_update_domain_deployment_map_for_infra_with_http_info(self, domain_id, domain_deployment_map_id, domain_deployment_map, **kwargs):  # noqa: E501
        """Create a new Domain Deployment Map under infra  # noqa: E501

        If the passed Domain Deployment Map does not already exist, create a new Domain Deployment Map. If it already exist, replace it.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_or_update_domain_deployment_map_for_infra_with_http_info(domain_id, domain_deployment_map_id, domain_deployment_map, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str domain_deployment_map_id: Domain Deployment Map ID (required)
        :param DomainDeploymentMap domain_deployment_map: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_id', 'domain_deployment_map_id', 'domain_deployment_map']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_or_update_domain_deployment_map_for_infra" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_id' is set
        if ('domain_id' not in params or
                params['domain_id'] is None):
            raise ValueError("Missing the required parameter `domain_id` when calling `create_or_update_domain_deployment_map_for_infra`")  # noqa: E501
        # verify the required parameter 'domain_deployment_map_id' is set
        if ('domain_deployment_map_id' not in params or
                params['domain_deployment_map_id'] is None):
            raise ValueError("Missing the required parameter `domain_deployment_map_id` when calling `create_or_update_domain_deployment_map_for_infra`")  # noqa: E501
        # verify the required parameter 'domain_deployment_map' is set
        if ('domain_deployment_map' not in params or
                params['domain_deployment_map'] is None):
            raise ValueError("Missing the required parameter `domain_deployment_map` when calling `create_or_update_domain_deployment_map_for_infra`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_id' in params:
            path_params['domain-id'] = params['domain_id']  # noqa: E501
        if 'domain_deployment_map_id' in params:
            path_params['domain-deployment-map-id'] = params['domain_deployment_map_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'domain_deployment_map' in params:
            body_params = params['domain_deployment_map']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/domains/{domain-id}/domain-deployment-maps/{domain-deployment-map-id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_or_update_enforcement_point_for_infra(self, deployment_zone_id, enforcementpoint_id, enforcement_point, **kwargs):  # noqa: E501
        """Create/update a new Enforcement Point under infra  # noqa: E501

        If the passed Enforcement Point does not already exist, create a new Enforcement Point. If it already exists, replace it.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_or_update_enforcement_point_for_infra(deployment_zone_id, enforcementpoint_id, enforcement_point, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_zone_id: Deployment zone id (required)
        :param str enforcementpoint_id: EnforcementPoint id (required)
        :param EnforcementPoint enforcement_point: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_or_update_enforcement_point_for_infra_with_http_info(deployment_zone_id, enforcementpoint_id, enforcement_point, **kwargs)  # noqa: E501
        else:
            (data) = self.create_or_update_enforcement_point_for_infra_with_http_info(deployment_zone_id, enforcementpoint_id, enforcement_point, **kwargs)  # noqa: E501
            return data

    def create_or_update_enforcement_point_for_infra_with_http_info(self, deployment_zone_id, enforcementpoint_id, enforcement_point, **kwargs):  # noqa: E501
        """Create/update a new Enforcement Point under infra  # noqa: E501

        If the passed Enforcement Point does not already exist, create a new Enforcement Point. If it already exists, replace it.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_or_update_enforcement_point_for_infra_with_http_info(deployment_zone_id, enforcementpoint_id, enforcement_point, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_zone_id: Deployment zone id (required)
        :param str enforcementpoint_id: EnforcementPoint id (required)
        :param EnforcementPoint enforcement_point: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_zone_id', 'enforcementpoint_id', 'enforcement_point']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_or_update_enforcement_point_for_infra" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_zone_id' is set
        if ('deployment_zone_id' not in params or
                params['deployment_zone_id'] is None):
            raise ValueError("Missing the required parameter `deployment_zone_id` when calling `create_or_update_enforcement_point_for_infra`")  # noqa: E501
        # verify the required parameter 'enforcementpoint_id' is set
        if ('enforcementpoint_id' not in params or
                params['enforcementpoint_id'] is None):
            raise ValueError("Missing the required parameter `enforcementpoint_id` when calling `create_or_update_enforcement_point_for_infra`")  # noqa: E501
        # verify the required parameter 'enforcement_point' is set
        if ('enforcement_point' not in params or
                params['enforcement_point'] is None):
            raise ValueError("Missing the required parameter `enforcement_point` when calling `create_or_update_enforcement_point_for_infra`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_zone_id' in params:
            path_params['deployment-zone-id'] = params['deployment_zone_id']  # noqa: E501
        if 'enforcementpoint_id' in params:
            path_params['enforcementpoint-id'] = params['enforcementpoint_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'enforcement_point' in params:
            body_params = params['enforcement_point']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/deployment-zones/{deployment-zone-id}/enforcement-points/{enforcementpoint-id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_or_update_template(self, template_id, policy_template, **kwargs):  # noqa: E501
        """Create or update a template.  # noqa: E501

        Create a new template if the specified template id does not correspond to an existing template. Update the template if otherwise.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_or_update_template(template_id, policy_template, async=True)
        >>> result = thread.get()

        :param async bool
        :param str template_id: Template identifier (required)
        :param PolicyTemplate policy_template: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_or_update_template_with_http_info(template_id, policy_template, **kwargs)  # noqa: E501
        else:
            (data) = self.create_or_update_template_with_http_info(template_id, policy_template, **kwargs)  # noqa: E501
            return data

    def create_or_update_template_with_http_info(self, template_id, policy_template, **kwargs):  # noqa: E501
        """Create or update a template.  # noqa: E501

        Create a new template if the specified template id does not correspond to an existing template. Update the template if otherwise.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_or_update_template_with_http_info(template_id, policy_template, async=True)
        >>> result = thread.get()

        :param async bool
        :param str template_id: Template identifier (required)
        :param PolicyTemplate policy_template: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['template_id', 'policy_template']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_or_update_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'template_id' is set
        if ('template_id' not in params or
                params['template_id'] is None):
            raise ValueError("Missing the required parameter `template_id` when calling `create_or_update_template`")  # noqa: E501
        # verify the required parameter 'policy_template' is set
        if ('policy_template' not in params or
                params['policy_template'] is None):
            raise ValueError("Missing the required parameter `policy_template` when calling `create_or_update_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in params:
            path_params['template-id'] = params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'policy_template' in params:
            body_params = params['policy_template']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/templates/{template-id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_communication_entry(self, domain_id, communication_entry_id, **kwargs):  # noqa: E501
        """Delete CommunicationEntry  # noqa: E501

        Delete CommunicationEntry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_communication_entry(domain_id, communication_entry_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str communication_entry_id: CommunicationEntry ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_communication_entry_with_http_info(domain_id, communication_entry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_communication_entry_with_http_info(domain_id, communication_entry_id, **kwargs)  # noqa: E501
            return data

    def delete_communication_entry_with_http_info(self, domain_id, communication_entry_id, **kwargs):  # noqa: E501
        """Delete CommunicationEntry  # noqa: E501

        Delete CommunicationEntry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_communication_entry_with_http_info(domain_id, communication_entry_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str communication_entry_id: CommunicationEntry ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_id', 'communication_entry_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_communication_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_id' is set
        if ('domain_id' not in params or
                params['domain_id'] is None):
            raise ValueError("Missing the required parameter `domain_id` when calling `delete_communication_entry`")  # noqa: E501
        # verify the required parameter 'communication_entry_id' is set
        if ('communication_entry_id' not in params or
                params['communication_entry_id'] is None):
            raise ValueError("Missing the required parameter `communication_entry_id` when calling `delete_communication_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_id' in params:
            path_params['domain-id'] = params['domain_id']  # noqa: E501
        if 'communication_entry_id' in params:
            path_params['communication-entry-id'] = params['communication_entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/domains/{domain-id}/communication-map/communication-entries/{communication-entry-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_communication_profile(self, communication_profile_id, **kwargs):  # noqa: E501
        """Delete CommunicationProfile  # noqa: E501

        Delete CommunicationProfile  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_communication_profile(communication_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str communication_profile_id: CommunicationProfile ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_communication_profile_with_http_info(communication_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_communication_profile_with_http_info(communication_profile_id, **kwargs)  # noqa: E501
            return data

    def delete_communication_profile_with_http_info(self, communication_profile_id, **kwargs):  # noqa: E501
        """Delete CommunicationProfile  # noqa: E501

        Delete CommunicationProfile  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_communication_profile_with_http_info(communication_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str communication_profile_id: CommunicationProfile ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['communication_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_communication_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'communication_profile_id' is set
        if ('communication_profile_id' not in params or
                params['communication_profile_id'] is None):
            raise ValueError("Missing the required parameter `communication_profile_id` when calling `delete_communication_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'communication_profile_id' in params:
            path_params['communication-profile-id'] = params['communication_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/communication-profiles/{communication-profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_communication_profile_entry(self, communication_profile_id, communication_profile_entry_id, **kwargs):  # noqa: E501
        """Delete CommunicationProfileEntry  # noqa: E501

        Delete CommunicationProfileEntry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_communication_profile_entry(communication_profile_id, communication_profile_entry_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str communication_profile_id: CommunicationProfile ID (required)
        :param str communication_profile_entry_id: CommunicationProfileEntry ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_communication_profile_entry_with_http_info(communication_profile_id, communication_profile_entry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_communication_profile_entry_with_http_info(communication_profile_id, communication_profile_entry_id, **kwargs)  # noqa: E501
            return data

    def delete_communication_profile_entry_with_http_info(self, communication_profile_id, communication_profile_entry_id, **kwargs):  # noqa: E501
        """Delete CommunicationProfileEntry  # noqa: E501

        Delete CommunicationProfileEntry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_communication_profile_entry_with_http_info(communication_profile_id, communication_profile_entry_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str communication_profile_id: CommunicationProfile ID (required)
        :param str communication_profile_entry_id: CommunicationProfileEntry ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['communication_profile_id', 'communication_profile_entry_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_communication_profile_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'communication_profile_id' is set
        if ('communication_profile_id' not in params or
                params['communication_profile_id'] is None):
            raise ValueError("Missing the required parameter `communication_profile_id` when calling `delete_communication_profile_entry`")  # noqa: E501
        # verify the required parameter 'communication_profile_entry_id' is set
        if ('communication_profile_entry_id' not in params or
                params['communication_profile_entry_id'] is None):
            raise ValueError("Missing the required parameter `communication_profile_entry_id` when calling `delete_communication_profile_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'communication_profile_id' in params:
            path_params['communication-profile-id'] = params['communication_profile_id']  # noqa: E501
        if 'communication_profile_entry_id' in params:
            path_params['communication-profile-entry-id'] = params['communication_profile_entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/communication-profiles/{communication-profile-id}/communication-profile-entries/{communication-profile-entry-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_domain(self, domain_id, **kwargs):  # noqa: E501
        """Delete Domain and all the entities contained by this domain  # noqa: E501

        Delete the domain along with all the entities contained by this domain. The groups that are a part of this domain are also deleted along with the domain.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_domain(domain_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_domain_with_http_info(domain_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_domain_with_http_info(domain_id, **kwargs)  # noqa: E501
            return data

    def delete_domain_with_http_info(self, domain_id, **kwargs):  # noqa: E501
        """Delete Domain and all the entities contained by this domain  # noqa: E501

        Delete the domain along with all the entities contained by this domain. The groups that are a part of this domain are also deleted along with the domain.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_domain_with_http_info(domain_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_domain" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_id' is set
        if ('domain_id' not in params or
                params['domain_id'] is None):
            raise ValueError("Missing the required parameter `domain_id` when calling `delete_domain`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_id' in params:
            path_params['domain-id'] = params['domain_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/domains/{domain-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_domain_deployment_map(self, domain_id, domain_deployment_map_id, **kwargs):  # noqa: E501
        """Delete Domain Deployment Map  # noqa: E501

        Delete Domain Deployment Map  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_domain_deployment_map(domain_id, domain_deployment_map_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str domain_deployment_map_id: domain-deployment-map-id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_domain_deployment_map_with_http_info(domain_id, domain_deployment_map_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_domain_deployment_map_with_http_info(domain_id, domain_deployment_map_id, **kwargs)  # noqa: E501
            return data

    def delete_domain_deployment_map_with_http_info(self, domain_id, domain_deployment_map_id, **kwargs):  # noqa: E501
        """Delete Domain Deployment Map  # noqa: E501

        Delete Domain Deployment Map  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_domain_deployment_map_with_http_info(domain_id, domain_deployment_map_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str domain_deployment_map_id: domain-deployment-map-id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_id', 'domain_deployment_map_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_domain_deployment_map" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_id' is set
        if ('domain_id' not in params or
                params['domain_id'] is None):
            raise ValueError("Missing the required parameter `domain_id` when calling `delete_domain_deployment_map`")  # noqa: E501
        # verify the required parameter 'domain_deployment_map_id' is set
        if ('domain_deployment_map_id' not in params or
                params['domain_deployment_map_id'] is None):
            raise ValueError("Missing the required parameter `domain_deployment_map_id` when calling `delete_domain_deployment_map`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_id' in params:
            path_params['domain-id'] = params['domain_id']  # noqa: E501
        if 'domain_deployment_map_id' in params:
            path_params['domain-deployment-map-id'] = params['domain_deployment_map_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/domains/{domain-id}/domain-deployment-maps/{domain-deployment-map-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_enforcement_point(self, deployment_zone_id, enforcementpoint_id, **kwargs):  # noqa: E501
        """Delete EnforcementPoint  # noqa: E501

        Delete EnforcementPoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_enforcement_point(deployment_zone_id, enforcementpoint_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_zone_id: Deployment zone id (required)
        :param str enforcementpoint_id: enforcementpoint-id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_enforcement_point_with_http_info(deployment_zone_id, enforcementpoint_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_enforcement_point_with_http_info(deployment_zone_id, enforcementpoint_id, **kwargs)  # noqa: E501
            return data

    def delete_enforcement_point_with_http_info(self, deployment_zone_id, enforcementpoint_id, **kwargs):  # noqa: E501
        """Delete EnforcementPoint  # noqa: E501

        Delete EnforcementPoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_enforcement_point_with_http_info(deployment_zone_id, enforcementpoint_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_zone_id: Deployment zone id (required)
        :param str enforcementpoint_id: enforcementpoint-id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_zone_id', 'enforcementpoint_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_enforcement_point" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_zone_id' is set
        if ('deployment_zone_id' not in params or
                params['deployment_zone_id'] is None):
            raise ValueError("Missing the required parameter `deployment_zone_id` when calling `delete_enforcement_point`")  # noqa: E501
        # verify the required parameter 'enforcementpoint_id' is set
        if ('enforcementpoint_id' not in params or
                params['enforcementpoint_id'] is None):
            raise ValueError("Missing the required parameter `enforcementpoint_id` when calling `delete_enforcement_point`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_zone_id' in params:
            path_params['deployment-zone-id'] = params['deployment_zone_id']  # noqa: E501
        if 'enforcementpoint_id' in params:
            path_params['enforcementpoint-id'] = params['enforcementpoint_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/deployment-zones/{deployment-zone-id}/enforcement-points/{enforcementpoint-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_group(self, domain_id, group_id, **kwargs):  # noqa: E501
        """Delete Group  # noqa: E501

        Delete Group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_group(domain_id, group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str group_id: Group ID (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_group_with_http_info(domain_id, group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_group_with_http_info(domain_id, group_id, **kwargs)  # noqa: E501
            return data

    def delete_group_with_http_info(self, domain_id, group_id, **kwargs):  # noqa: E501
        """Delete Group  # noqa: E501

        Delete Group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_group_with_http_info(domain_id, group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str group_id: Group ID (required)
        :param bool force: Force delete the resource even if it is being used somewhere 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_id', 'group_id', 'force']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_id' is set
        if ('domain_id' not in params or
                params['domain_id'] is None):
            raise ValueError("Missing the required parameter `domain_id` when calling `delete_group`")  # noqa: E501
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params or
                params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `delete_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_id' in params:
            path_params['domain-id'] = params['domain_id']  # noqa: E501
        if 'group_id' in params:
            path_params['group-id'] = params['group_id']  # noqa: E501

        query_params = []
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/domains/{domain-id}/groups/{group-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_service_entry(self, service_id, service_entry_id, **kwargs):  # noqa: E501
        """Delete Service entry  # noqa: E501

        Delete Service entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_service_entry(service_id, service_entry_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: Service ID (required)
        :param str service_entry_id: Service entry ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_service_entry_with_http_info(service_id, service_entry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_service_entry_with_http_info(service_id, service_entry_id, **kwargs)  # noqa: E501
            return data

    def delete_service_entry_with_http_info(self, service_id, service_entry_id, **kwargs):  # noqa: E501
        """Delete Service entry  # noqa: E501

        Delete Service entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_service_entry_with_http_info(service_id, service_entry_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: Service ID (required)
        :param str service_entry_id: Service entry ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_entry_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_service_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `delete_service_entry`")  # noqa: E501
        # verify the required parameter 'service_entry_id' is set
        if ('service_entry_id' not in params or
                params['service_entry_id'] is None):
            raise ValueError("Missing the required parameter `service_entry_id` when calling `delete_service_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_entry_id' in params:
            path_params['service-entry-id'] = params['service_entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/services/{service-id}/service-entries/{service-entry-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_service_for_tenant(self, service_id, **kwargs):  # noqa: E501
        """Delete Service  # noqa: E501

        Delete Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_service_for_tenant(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: Service ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_service_for_tenant_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_service_for_tenant_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def delete_service_for_tenant_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Delete Service  # noqa: E501

        Delete Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_service_for_tenant_with_http_info(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: Service ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_service_for_tenant" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `delete_service_for_tenant`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/services/{service-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_template(self, template_id, **kwargs):  # noqa: E501
        """Delete template.  # noqa: E501

        Delete a template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_template(template_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str template_id: Template identifier (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_template_with_http_info(template_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_template_with_http_info(template_id, **kwargs)  # noqa: E501
            return data

    def delete_template_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """Delete template.  # noqa: E501

        Delete a template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_template_with_http_info(template_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str template_id: Template identifier (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['template_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'template_id' is set
        if ('template_id' not in params or
                params['template_id'] is None):
            raise ValueError("Missing the required parameter `template_id` when calling `delete_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in params:
            path_params['template-id'] = params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/templates/{template-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def deploy_template_deploy(self, template_id, policy_template_parameters, **kwargs):  # noqa: E501
        """Deploy template.  # noqa: E501

        Read a template, populate the placeholders' fields with the parameters' values, and deploy the template body by creating or updating all the nested policy objects inside the AbstractSpace object.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.deploy_template_deploy(template_id, policy_template_parameters, async=True)
        >>> result = thread.get()

        :param async bool
        :param str template_id: Template identifier (required)
        :param PolicyTemplateParameters policy_template_parameters: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.deploy_template_deploy_with_http_info(template_id, policy_template_parameters, **kwargs)  # noqa: E501
        else:
            (data) = self.deploy_template_deploy_with_http_info(template_id, policy_template_parameters, **kwargs)  # noqa: E501
            return data

    def deploy_template_deploy_with_http_info(self, template_id, policy_template_parameters, **kwargs):  # noqa: E501
        """Deploy template.  # noqa: E501

        Read a template, populate the placeholders' fields with the parameters' values, and deploy the template body by creating or updating all the nested policy objects inside the AbstractSpace object.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.deploy_template_deploy_with_http_info(template_id, policy_template_parameters, async=True)
        >>> result = thread.get()

        :param async bool
        :param str template_id: Template identifier (required)
        :param PolicyTemplateParameters policy_template_parameters: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['template_id', 'policy_template_parameters']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deploy_template_deploy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'template_id' is set
        if ('template_id' not in params or
                params['template_id'] is None):
            raise ValueError("Missing the required parameter `template_id` when calling `deploy_template_deploy`")  # noqa: E501
        # verify the required parameter 'policy_template_parameters' is set
        if ('policy_template_parameters' not in params or
                params['policy_template_parameters'] is None):
            raise ValueError("Missing the required parameter `policy_template_parameters` when calling `deploy_template_deploy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in params:
            path_params['template-id'] = params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'policy_template_parameters' in params:
            body_params = params['policy_template_parameters']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/templates/{template-id}?action=deploy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_communication_entry(self, domain_id, **kwargs):  # noqa: E501
        """List CommunicationEntries  # noqa: E501

        List CommunicationEntries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_communication_entry(domain_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: CommunicationEntryListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_communication_entry_with_http_info(domain_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_communication_entry_with_http_info(domain_id, **kwargs)  # noqa: E501
            return data

    def list_communication_entry_with_http_info(self, domain_id, **kwargs):  # noqa: E501
        """List CommunicationEntries  # noqa: E501

        List CommunicationEntries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_communication_entry_with_http_info(domain_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: CommunicationEntryListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_communication_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_id' is set
        if ('domain_id' not in params or
                params['domain_id'] is None):
            raise ValueError("Missing the required parameter `domain_id` when calling `list_communication_entry`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_communication_entry`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_communication_entry`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'domain_id' in params:
            path_params['domain-id'] = params['domain_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/domains/{domain-id}/communication-map/communication-entries', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommunicationEntryListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_communication_profile_entries(self, communication_profile_id, **kwargs):  # noqa: E501
        """List CommunicationProfileEntries for CommunicationProfile  # noqa: E501

        Paginated list of CommunicationProfileEntries for the given CommunicationProfile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_communication_profile_entries(communication_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str communication_profile_id: CommunicationProfile ID (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: CommunicationProfileEntryListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_communication_profile_entries_with_http_info(communication_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_communication_profile_entries_with_http_info(communication_profile_id, **kwargs)  # noqa: E501
            return data

    def list_communication_profile_entries_with_http_info(self, communication_profile_id, **kwargs):  # noqa: E501
        """List CommunicationProfileEntries for CommunicationProfile  # noqa: E501

        Paginated list of CommunicationProfileEntries for the given CommunicationProfile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_communication_profile_entries_with_http_info(communication_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str communication_profile_id: CommunicationProfile ID (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: CommunicationProfileEntryListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['communication_profile_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_communication_profile_entries" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'communication_profile_id' is set
        if ('communication_profile_id' not in params or
                params['communication_profile_id'] is None):
            raise ValueError("Missing the required parameter `communication_profile_id` when calling `list_communication_profile_entries`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_communication_profile_entries`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_communication_profile_entries`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'communication_profile_id' in params:
            path_params['communication-profile-id'] = params['communication_profile_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/communication-profiles/{communication-profile-id}/communication-profile-entries', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommunicationProfileEntryListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_communication_profiles(self, **kwargs):  # noqa: E501
        """List CommunicationProfiles  # noqa: E501

        Paginated list of CommunicationProfiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_communication_profiles(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: CommunicationProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_communication_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_communication_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_communication_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """List CommunicationProfiles  # noqa: E501

        Paginated list of CommunicationProfiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_communication_profiles_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: CommunicationProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_communication_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_communication_profiles`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_communication_profiles`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/communication-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommunicationProfileListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_deployment_zones_for_infra(self, **kwargs):  # noqa: E501
        """List Deployment Zones for infra  # noqa: E501

        Paginated list of all Deployment zones for infra.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_deployment_zones_for_infra(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DeploymentZoneListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_deployment_zones_for_infra_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_deployment_zones_for_infra_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_deployment_zones_for_infra_with_http_info(self, **kwargs):  # noqa: E501
        """List Deployment Zones for infra  # noqa: E501

        Paginated list of all Deployment zones for infra.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_deployment_zones_for_infra_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DeploymentZoneListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_deployment_zones_for_infra" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_deployment_zones_for_infra`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_deployment_zones_for_infra`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/deployment-zones', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeploymentZoneListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_domain_deployment_maps_for_infra(self, domain_id, **kwargs):  # noqa: E501
        """List Domain Deployment maps for infra  # noqa: E501

        Paginated list of all Domain Deployment Entries for infra.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_domain_deployment_maps_for_infra(domain_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DomainDeploymentMapListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_domain_deployment_maps_for_infra_with_http_info(domain_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_domain_deployment_maps_for_infra_with_http_info(domain_id, **kwargs)  # noqa: E501
            return data

    def list_domain_deployment_maps_for_infra_with_http_info(self, domain_id, **kwargs):  # noqa: E501
        """List Domain Deployment maps for infra  # noqa: E501

        Paginated list of all Domain Deployment Entries for infra.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_domain_deployment_maps_for_infra_with_http_info(domain_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DomainDeploymentMapListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_domain_deployment_maps_for_infra" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_id' is set
        if ('domain_id' not in params or
                params['domain_id'] is None):
            raise ValueError("Missing the required parameter `domain_id` when calling `list_domain_deployment_maps_for_infra`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_domain_deployment_maps_for_infra`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_domain_deployment_maps_for_infra`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'domain_id' in params:
            path_params['domain-id'] = params['domain_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/domains/{domain-id}/domain-deployment-maps', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DomainDeploymentMapListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_domain_for_infra(self, **kwargs):  # noqa: E501
        """List domains for infra  # noqa: E501

        Paginated list of all domains for infra.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_domain_for_infra(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DomainListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_domain_for_infra_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_domain_for_infra_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_domain_for_infra_with_http_info(self, **kwargs):  # noqa: E501
        """List domains for infra  # noqa: E501

        Paginated list of all domains for infra.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_domain_for_infra_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DomainListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_domain_for_infra" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_domain_for_infra`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_domain_for_infra`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/domains', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DomainListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_enforcement_point_for_infra(self, deployment_zone_id, **kwargs):  # noqa: E501
        """List enforcementpoints for infra  # noqa: E501

        Paginated list of all enforcementpoints for infra.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_enforcement_point_for_infra(deployment_zone_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_zone_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EnforcementPointListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_enforcement_point_for_infra_with_http_info(deployment_zone_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_enforcement_point_for_infra_with_http_info(deployment_zone_id, **kwargs)  # noqa: E501
            return data

    def list_enforcement_point_for_infra_with_http_info(self, deployment_zone_id, **kwargs):  # noqa: E501
        """List enforcementpoints for infra  # noqa: E501

        Paginated list of all enforcementpoints for infra.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_enforcement_point_for_infra_with_http_info(deployment_zone_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_zone_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: EnforcementPointListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_zone_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_enforcement_point_for_infra" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_zone_id' is set
        if ('deployment_zone_id' not in params or
                params['deployment_zone_id'] is None):
            raise ValueError("Missing the required parameter `deployment_zone_id` when calling `list_enforcement_point_for_infra`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_enforcement_point_for_infra`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_enforcement_point_for_infra`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'deployment_zone_id' in params:
            path_params['deployment-zone-id'] = params['deployment_zone_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/deployment-zones/{deployment-zone-id}/enforcement-points', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EnforcementPointListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_enforcement_point_realized_states(self, **kwargs):  # noqa: E501
        """List Enforcement Points  # noqa: E501

        Paginated list of all enforcement points. Returns the populated enforcement points.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_enforcement_point_realized_states(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: RealizedEnforcementPointListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_enforcement_point_realized_states_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_enforcement_point_realized_states_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_enforcement_point_realized_states_with_http_info(self, **kwargs):  # noqa: E501
        """List Enforcement Points  # noqa: E501

        Paginated list of all enforcement points. Returns the populated enforcement points.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_enforcement_point_realized_states_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: RealizedEnforcementPointListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_enforcement_point_realized_states" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_enforcement_point_realized_states`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_enforcement_point_realized_states`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/realized-state/enforcement-points', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RealizedEnforcementPointListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_firewall_section_realized_states(self, enforcement_point_name, **kwargs):  # noqa: E501
        """List Firewall Sections  # noqa: E501

        Paginated list of all Firewalls. Returns populated Firewalls.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_firewall_section_realized_states(enforcement_point_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: RealizedFirewallSectionListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_firewall_section_realized_states_with_http_info(enforcement_point_name, **kwargs)  # noqa: E501
        else:
            (data) = self.list_firewall_section_realized_states_with_http_info(enforcement_point_name, **kwargs)  # noqa: E501
            return data

    def list_firewall_section_realized_states_with_http_info(self, enforcement_point_name, **kwargs):  # noqa: E501
        """List Firewall Sections  # noqa: E501

        Paginated list of all Firewalls. Returns populated Firewalls.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_firewall_section_realized_states_with_http_info(enforcement_point_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: RealizedFirewallSectionListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['enforcement_point_name', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_firewall_section_realized_states" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'enforcement_point_name' is set
        if ('enforcement_point_name' not in params or
                params['enforcement_point_name'] is None):
            raise ValueError("Missing the required parameter `enforcement_point_name` when calling `list_firewall_section_realized_states`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_firewall_section_realized_states`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_firewall_section_realized_states`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'enforcement_point_name' in params:
            path_params['enforcement-point-name'] = params['enforcement_point_name']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/realized-state/enforcement-points/{enforcement-point-name}/firewalls/firewall-sections', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RealizedFirewallSectionListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_group_for_domain(self, domain_id, **kwargs):  # noqa: E501
        """List Groups for a domain  # noqa: E501

        List Groups for a domain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_group_for_domain(domain_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: GroupListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_group_for_domain_with_http_info(domain_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_group_for_domain_with_http_info(domain_id, **kwargs)  # noqa: E501
            return data

    def list_group_for_domain_with_http_info(self, domain_id, **kwargs):  # noqa: E501
        """List Groups for a domain  # noqa: E501

        List Groups for a domain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_group_for_domain_with_http_info(domain_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: GroupListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_group_for_domain" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_id' is set
        if ('domain_id' not in params or
                params['domain_id'] is None):
            raise ValueError("Missing the required parameter `domain_id` when calling `list_group_for_domain`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_group_for_domain`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_group_for_domain`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'domain_id' in params:
            path_params['domain-id'] = params['domain_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/domains/{domain-id}/groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GroupListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_ip_set_realized_states(self, enforcement_point_name, **kwargs):  # noqa: E501
        """List IPSets  # noqa: E501

        Paginated list of all Realized IPSets   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ip_set_realized_states(enforcement_point_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: RealizedIPSetListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_ip_set_realized_states_with_http_info(enforcement_point_name, **kwargs)  # noqa: E501
        else:
            (data) = self.list_ip_set_realized_states_with_http_info(enforcement_point_name, **kwargs)  # noqa: E501
            return data

    def list_ip_set_realized_states_with_http_info(self, enforcement_point_name, **kwargs):  # noqa: E501
        """List IPSets  # noqa: E501

        Paginated list of all Realized IPSets   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ip_set_realized_states_with_http_info(enforcement_point_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: RealizedIPSetListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['enforcement_point_name', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_ip_set_realized_states" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'enforcement_point_name' is set
        if ('enforcement_point_name' not in params or
                params['enforcement_point_name'] is None):
            raise ValueError("Missing the required parameter `enforcement_point_name` when calling `list_ip_set_realized_states`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ip_set_realized_states`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ip_set_realized_states`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'enforcement_point_name' in params:
            path_params['enforcement-point-name'] = params['enforcement_point_name']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/realized-state/enforcement-points/{enforcement-point-name}/ip-sets/ip-sets-nsxt', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RealizedIPSetListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_mac_set_realized_states(self, enforcement_point_name, **kwargs):  # noqa: E501
        """List MACSets  # noqa: E501

        Paginated list of all Realized MACSets   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_mac_set_realized_states(enforcement_point_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: RealizedMACSetListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_mac_set_realized_states_with_http_info(enforcement_point_name, **kwargs)  # noqa: E501
        else:
            (data) = self.list_mac_set_realized_states_with_http_info(enforcement_point_name, **kwargs)  # noqa: E501
            return data

    def list_mac_set_realized_states_with_http_info(self, enforcement_point_name, **kwargs):  # noqa: E501
        """List MACSets  # noqa: E501

        Paginated list of all Realized MACSets   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_mac_set_realized_states_with_http_info(enforcement_point_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: RealizedMACSetListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['enforcement_point_name', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_mac_set_realized_states" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'enforcement_point_name' is set
        if ('enforcement_point_name' not in params or
                params['enforcement_point_name'] is None):
            raise ValueError("Missing the required parameter `enforcement_point_name` when calling `list_mac_set_realized_states`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_mac_set_realized_states`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_mac_set_realized_states`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'enforcement_point_name' in params:
            path_params['enforcement-point-name'] = params['enforcement_point_name']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/realized-state/enforcement-points/{enforcement-point-name}/mac-sets/mac-sets-nsxt', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RealizedMACSetListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_ns_group_realized_states(self, enforcement_point_name, **kwargs):  # noqa: E501
        """List NS Groups  # noqa: E501

        Paginated list of all NSGroups. Returns populated NSGroups.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ns_group_realized_states(enforcement_point_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: RealizedNSGroupListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_ns_group_realized_states_with_http_info(enforcement_point_name, **kwargs)  # noqa: E501
        else:
            (data) = self.list_ns_group_realized_states_with_http_info(enforcement_point_name, **kwargs)  # noqa: E501
            return data

    def list_ns_group_realized_states_with_http_info(self, enforcement_point_name, **kwargs):  # noqa: E501
        """List NS Groups  # noqa: E501

        Paginated list of all NSGroups. Returns populated NSGroups.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ns_group_realized_states_with_http_info(enforcement_point_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: RealizedNSGroupListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['enforcement_point_name', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_ns_group_realized_states" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'enforcement_point_name' is set
        if ('enforcement_point_name' not in params or
                params['enforcement_point_name'] is None):
            raise ValueError("Missing the required parameter `enforcement_point_name` when calling `list_ns_group_realized_states`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ns_group_realized_states`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ns_group_realized_states`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'enforcement_point_name' in params:
            path_params['enforcement-point-name'] = params['enforcement_point_name']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/realized-state/enforcement-points/{enforcement-point-name}/groups/nsgroups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RealizedNSGroupListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_ns_service_realized_states(self, enforcement_point_name, **kwargs):  # noqa: E501
        """List Realized NSServices  # noqa: E501

        Paginated list of all Realized NSService.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ns_service_realized_states(enforcement_point_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: RealizedNSServiceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_ns_service_realized_states_with_http_info(enforcement_point_name, **kwargs)  # noqa: E501
        else:
            (data) = self.list_ns_service_realized_states_with_http_info(enforcement_point_name, **kwargs)  # noqa: E501
            return data

    def list_ns_service_realized_states_with_http_info(self, enforcement_point_name, **kwargs):  # noqa: E501
        """List Realized NSServices  # noqa: E501

        Paginated list of all Realized NSService.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_ns_service_realized_states_with_http_info(enforcement_point_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: RealizedNSServiceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['enforcement_point_name', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_ns_service_realized_states" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'enforcement_point_name' is set
        if ('enforcement_point_name' not in params or
                params['enforcement_point_name'] is None):
            raise ValueError("Missing the required parameter `enforcement_point_name` when calling `list_ns_service_realized_states`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ns_service_realized_states`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_ns_service_realized_states`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'enforcement_point_name' in params:
            path_params['enforcement-point-name'] = params['enforcement_point_name']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/realized-state/enforcement-points/{enforcement-point-name}/services/nsservices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RealizedNSServiceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_security_group_realized_states(self, enforcement_point_name, **kwargs):  # noqa: E501
        """List Security Groups  # noqa: E501

        Paginated list of all Security Groups. Returns populated Security Groups.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_security_group_realized_states(enforcement_point_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: RealizedSecurityGroupListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_security_group_realized_states_with_http_info(enforcement_point_name, **kwargs)  # noqa: E501
        else:
            (data) = self.list_security_group_realized_states_with_http_info(enforcement_point_name, **kwargs)  # noqa: E501
            return data

    def list_security_group_realized_states_with_http_info(self, enforcement_point_name, **kwargs):  # noqa: E501
        """List Security Groups  # noqa: E501

        Paginated list of all Security Groups. Returns populated Security Groups.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_security_group_realized_states_with_http_info(enforcement_point_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: RealizedSecurityGroupListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['enforcement_point_name', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_security_group_realized_states" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'enforcement_point_name' is set
        if ('enforcement_point_name' not in params or
                params['enforcement_point_name'] is None):
            raise ValueError("Missing the required parameter `enforcement_point_name` when calling `list_security_group_realized_states`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_security_group_realized_states`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_security_group_realized_states`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'enforcement_point_name' in params:
            path_params['enforcement-point-name'] = params['enforcement_point_name']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/realized-state/enforcement-points/{enforcement-point-name}/groups/securitygroups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RealizedSecurityGroupListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_service_entries(self, service_id, **kwargs):  # noqa: E501
        """List Service entries for the given service  # noqa: E501

        Paginated list of Service entries for the given service   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_service_entries(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: Service ID (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ServiceEntryListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_service_entries_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_service_entries_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def list_service_entries_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """List Service entries for the given service  # noqa: E501

        Paginated list of Service entries for the given service   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_service_entries_with_http_info(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: Service ID (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ServiceEntryListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_service_entries" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `list_service_entries`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_service_entries`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_service_entries`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/services/{service-id}/service-entries', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceEntryListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_services_for_tenant(self, **kwargs):  # noqa: E501
        """List Services for infra  # noqa: E501

        Paginated list of Services for infra.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_services_for_tenant(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ServiceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_services_for_tenant_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_services_for_tenant_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_services_for_tenant_with_http_info(self, **kwargs):  # noqa: E501
        """List Services for infra  # noqa: E501

        Paginated list of Services for infra.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_services_for_tenant_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ServiceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_services_for_tenant" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_services_for_tenant`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_services_for_tenant`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/services', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_templates(self, **kwargs):  # noqa: E501
        """List Policy Templates  # noqa: E501

        List Policy Templates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_templates(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: PolicyTemplateListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_templates_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_templates_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_templates_with_http_info(self, **kwargs):  # noqa: E501
        """List Policy Templates  # noqa: E501

        List Policy Templates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_templates_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: PolicyTemplateListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_templates" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_templates`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_templates`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/templates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PolicyTemplateListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_communication_entry(self, domain_id, communication_entry_id, **kwargs):  # noqa: E501
        """Read CommunicationEntry  # noqa: E501

        Read CommunicationEntry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_communication_entry(domain_id, communication_entry_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str communication_entry_id: CommunicationEntry ID (required)
        :return: CommunicationEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_communication_entry_with_http_info(domain_id, communication_entry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_communication_entry_with_http_info(domain_id, communication_entry_id, **kwargs)  # noqa: E501
            return data

    def read_communication_entry_with_http_info(self, domain_id, communication_entry_id, **kwargs):  # noqa: E501
        """Read CommunicationEntry  # noqa: E501

        Read CommunicationEntry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_communication_entry_with_http_info(domain_id, communication_entry_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str communication_entry_id: CommunicationEntry ID (required)
        :return: CommunicationEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_id', 'communication_entry_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_communication_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_id' is set
        if ('domain_id' not in params or
                params['domain_id'] is None):
            raise ValueError("Missing the required parameter `domain_id` when calling `read_communication_entry`")  # noqa: E501
        # verify the required parameter 'communication_entry_id' is set
        if ('communication_entry_id' not in params or
                params['communication_entry_id'] is None):
            raise ValueError("Missing the required parameter `communication_entry_id` when calling `read_communication_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_id' in params:
            path_params['domain-id'] = params['domain_id']  # noqa: E501
        if 'communication_entry_id' in params:
            path_params['communication-entry-id'] = params['communication_entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/domains/{domain-id}/communication-map/communication-entries/{communication-entry-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommunicationEntry',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_communication_map_for_domain(self, domain_id, **kwargs):  # noqa: E501
        """Read communication-map  # noqa: E501

        Read communication-map for a domain.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_communication_map_for_domain(domain_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :return: CommunicationMap
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_communication_map_for_domain_with_http_info(domain_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_communication_map_for_domain_with_http_info(domain_id, **kwargs)  # noqa: E501
            return data

    def read_communication_map_for_domain_with_http_info(self, domain_id, **kwargs):  # noqa: E501
        """Read communication-map  # noqa: E501

        Read communication-map for a domain.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_communication_map_for_domain_with_http_info(domain_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :return: CommunicationMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_communication_map_for_domain" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_id' is set
        if ('domain_id' not in params or
                params['domain_id'] is None):
            raise ValueError("Missing the required parameter `domain_id` when calling `read_communication_map_for_domain`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_id' in params:
            path_params['domain-id'] = params['domain_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/domains/{domain-id}/communication-map', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommunicationMap',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_communication_profile(self, communication_profile_id, **kwargs):  # noqa: E501
        """Read CommunicationProfile  # noqa: E501

        Read a CommunicationProfile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_communication_profile(communication_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str communication_profile_id: CommunicationProfile ID (required)
        :return: CommunicationProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_communication_profile_with_http_info(communication_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_communication_profile_with_http_info(communication_profile_id, **kwargs)  # noqa: E501
            return data

    def read_communication_profile_with_http_info(self, communication_profile_id, **kwargs):  # noqa: E501
        """Read CommunicationProfile  # noqa: E501

        Read a CommunicationProfile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_communication_profile_with_http_info(communication_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str communication_profile_id: CommunicationProfile ID (required)
        :return: CommunicationProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['communication_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_communication_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'communication_profile_id' is set
        if ('communication_profile_id' not in params or
                params['communication_profile_id'] is None):
            raise ValueError("Missing the required parameter `communication_profile_id` when calling `read_communication_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'communication_profile_id' in params:
            path_params['communication-profile-id'] = params['communication_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/communication-profiles/{communication-profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommunicationProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_communication_profile_entry(self, communication_profile_id, communication_profile_entry_id, **kwargs):  # noqa: E501
        """Read CommunicationProfileEntry  # noqa: E501

        Read CommunicationProfileEntry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_communication_profile_entry(communication_profile_id, communication_profile_entry_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str communication_profile_id: CommunicationProfile ID (required)
        :param str communication_profile_entry_id: CommunicationProfileEntry ID (required)
        :return: CommunicationProfileEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_communication_profile_entry_with_http_info(communication_profile_id, communication_profile_entry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_communication_profile_entry_with_http_info(communication_profile_id, communication_profile_entry_id, **kwargs)  # noqa: E501
            return data

    def read_communication_profile_entry_with_http_info(self, communication_profile_id, communication_profile_entry_id, **kwargs):  # noqa: E501
        """Read CommunicationProfileEntry  # noqa: E501

        Read CommunicationProfileEntry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_communication_profile_entry_with_http_info(communication_profile_id, communication_profile_entry_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str communication_profile_id: CommunicationProfile ID (required)
        :param str communication_profile_entry_id: CommunicationProfileEntry ID (required)
        :return: CommunicationProfileEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['communication_profile_id', 'communication_profile_entry_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_communication_profile_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'communication_profile_id' is set
        if ('communication_profile_id' not in params or
                params['communication_profile_id'] is None):
            raise ValueError("Missing the required parameter `communication_profile_id` when calling `read_communication_profile_entry`")  # noqa: E501
        # verify the required parameter 'communication_profile_entry_id' is set
        if ('communication_profile_entry_id' not in params or
                params['communication_profile_entry_id'] is None):
            raise ValueError("Missing the required parameter `communication_profile_entry_id` when calling `read_communication_profile_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'communication_profile_id' in params:
            path_params['communication-profile-id'] = params['communication_profile_id']  # noqa: E501
        if 'communication_profile_entry_id' in params:
            path_params['communication-profile-entry-id'] = params['communication_profile_entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/communication-profiles/{communication-profile-id}/communication-profile-entries/{communication-profile-entry-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommunicationProfileEntry',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_deployment_zone_infra(self, deployment_zone_id, **kwargs):  # noqa: E501
        """Read a DeploymentZone  # noqa: E501

        Read a Deployment Zone   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_deployment_zone_infra(deployment_zone_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_zone_id: Deployment Zone id (required)
        :return: DeploymentZone
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_deployment_zone_infra_with_http_info(deployment_zone_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_deployment_zone_infra_with_http_info(deployment_zone_id, **kwargs)  # noqa: E501
            return data

    def read_deployment_zone_infra_with_http_info(self, deployment_zone_id, **kwargs):  # noqa: E501
        """Read a DeploymentZone  # noqa: E501

        Read a Deployment Zone   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_deployment_zone_infra_with_http_info(deployment_zone_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_zone_id: Deployment Zone id (required)
        :return: DeploymentZone
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_zone_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_deployment_zone_infra" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_zone_id' is set
        if ('deployment_zone_id' not in params or
                params['deployment_zone_id'] is None):
            raise ValueError("Missing the required parameter `deployment_zone_id` when calling `read_deployment_zone_infra`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_zone_id' in params:
            path_params['deployment-zone-id'] = params['deployment_zone_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/deployment-zones/{deployment-zone-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeploymentZone',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_domain_deployment_map_for_infra(self, domain_id, domain_deployment_map_id, **kwargs):  # noqa: E501
        """Read a DomainDeploymentMap  # noqa: E501

        Read a Domain Deployment Map   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_domain_deployment_map_for_infra(domain_id, domain_deployment_map_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str domain_deployment_map_id: Domain Deployment Map id (required)
        :return: DomainDeploymentMap
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_domain_deployment_map_for_infra_with_http_info(domain_id, domain_deployment_map_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_domain_deployment_map_for_infra_with_http_info(domain_id, domain_deployment_map_id, **kwargs)  # noqa: E501
            return data

    def read_domain_deployment_map_for_infra_with_http_info(self, domain_id, domain_deployment_map_id, **kwargs):  # noqa: E501
        """Read a DomainDeploymentMap  # noqa: E501

        Read a Domain Deployment Map   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_domain_deployment_map_for_infra_with_http_info(domain_id, domain_deployment_map_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str domain_deployment_map_id: Domain Deployment Map id (required)
        :return: DomainDeploymentMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_id', 'domain_deployment_map_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_domain_deployment_map_for_infra" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_id' is set
        if ('domain_id' not in params or
                params['domain_id'] is None):
            raise ValueError("Missing the required parameter `domain_id` when calling `read_domain_deployment_map_for_infra`")  # noqa: E501
        # verify the required parameter 'domain_deployment_map_id' is set
        if ('domain_deployment_map_id' not in params or
                params['domain_deployment_map_id'] is None):
            raise ValueError("Missing the required parameter `domain_deployment_map_id` when calling `read_domain_deployment_map_for_infra`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_id' in params:
            path_params['domain-id'] = params['domain_id']  # noqa: E501
        if 'domain_deployment_map_id' in params:
            path_params['domain-deployment-map-id'] = params['domain_deployment_map_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/domains/{domain-id}/domain-deployment-maps/{domain-deployment-map-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DomainDeploymentMap',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_domain_for_infra(self, domain_id, **kwargs):  # noqa: E501
        """Read domain  # noqa: E501

        Read a domain.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_domain_for_infra(domain_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :return: Domain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_domain_for_infra_with_http_info(domain_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_domain_for_infra_with_http_info(domain_id, **kwargs)  # noqa: E501
            return data

    def read_domain_for_infra_with_http_info(self, domain_id, **kwargs):  # noqa: E501
        """Read domain  # noqa: E501

        Read a domain.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_domain_for_infra_with_http_info(domain_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :return: Domain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_domain_for_infra" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_id' is set
        if ('domain_id' not in params or
                params['domain_id'] is None):
            raise ValueError("Missing the required parameter `domain_id` when calling `read_domain_for_infra`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_id' in params:
            path_params['domain-id'] = params['domain_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/domains/{domain-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Domain',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_enforcement_point_for_infra(self, deployment_zone_id, enforcementpoint_id, **kwargs):  # noqa: E501
        """Read an Enforcement Point  # noqa: E501

        Read an Enforcement Point   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_enforcement_point_for_infra(deployment_zone_id, enforcementpoint_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_zone_id: Deployment zone id (required)
        :param str enforcementpoint_id: EnforcementPoint id (required)
        :return: EnforcementPoint
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_enforcement_point_for_infra_with_http_info(deployment_zone_id, enforcementpoint_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_enforcement_point_for_infra_with_http_info(deployment_zone_id, enforcementpoint_id, **kwargs)  # noqa: E501
            return data

    def read_enforcement_point_for_infra_with_http_info(self, deployment_zone_id, enforcementpoint_id, **kwargs):  # noqa: E501
        """Read an Enforcement Point  # noqa: E501

        Read an Enforcement Point   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_enforcement_point_for_infra_with_http_info(deployment_zone_id, enforcementpoint_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str deployment_zone_id: Deployment zone id (required)
        :param str enforcementpoint_id: EnforcementPoint id (required)
        :return: EnforcementPoint
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deployment_zone_id', 'enforcementpoint_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_enforcement_point_for_infra" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deployment_zone_id' is set
        if ('deployment_zone_id' not in params or
                params['deployment_zone_id'] is None):
            raise ValueError("Missing the required parameter `deployment_zone_id` when calling `read_enforcement_point_for_infra`")  # noqa: E501
        # verify the required parameter 'enforcementpoint_id' is set
        if ('enforcementpoint_id' not in params or
                params['enforcementpoint_id'] is None):
            raise ValueError("Missing the required parameter `enforcementpoint_id` when calling `read_enforcement_point_for_infra`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_zone_id' in params:
            path_params['deployment-zone-id'] = params['deployment_zone_id']  # noqa: E501
        if 'enforcementpoint_id' in params:
            path_params['enforcementpoint-id'] = params['enforcementpoint_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/deployment-zones/{deployment-zone-id}/enforcement-points/{enforcementpoint-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EnforcementPoint',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_enforcement_point_realized_state(self, enforcement_point_name, **kwargs):  # noqa: E501
        """Read Enforcement Point  # noqa: E501

        Read a Enforcement Point and the complete tree underneath. Returns the populated enforcement point object.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_enforcement_point_realized_state(enforcement_point_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :return: RealizedEnforcementPoint
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_enforcement_point_realized_state_with_http_info(enforcement_point_name, **kwargs)  # noqa: E501
        else:
            (data) = self.read_enforcement_point_realized_state_with_http_info(enforcement_point_name, **kwargs)  # noqa: E501
            return data

    def read_enforcement_point_realized_state_with_http_info(self, enforcement_point_name, **kwargs):  # noqa: E501
        """Read Enforcement Point  # noqa: E501

        Read a Enforcement Point and the complete tree underneath. Returns the populated enforcement point object.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_enforcement_point_realized_state_with_http_info(enforcement_point_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :return: RealizedEnforcementPoint
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['enforcement_point_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_enforcement_point_realized_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'enforcement_point_name' is set
        if ('enforcement_point_name' not in params or
                params['enforcement_point_name'] is None):
            raise ValueError("Missing the required parameter `enforcement_point_name` when calling `read_enforcement_point_realized_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'enforcement_point_name' in params:
            path_params['enforcement-point-name'] = params['enforcement_point_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/realized-state/enforcement-points/{enforcement-point-name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RealizedEnforcementPoint',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_firewall_section_realized_state(self, enforcement_point_name, firewall_section_id, **kwargs):  # noqa: E501
        """Read Firewall  # noqa: E501

        Read a Firewall and the complete tree underneath. Returns the populated Firewall object.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_firewall_section_realized_state(enforcement_point_name, firewall_section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str firewall_section_id: Firewall Section Id (required)
        :return: RealizedFirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_firewall_section_realized_state_with_http_info(enforcement_point_name, firewall_section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_firewall_section_realized_state_with_http_info(enforcement_point_name, firewall_section_id, **kwargs)  # noqa: E501
            return data

    def read_firewall_section_realized_state_with_http_info(self, enforcement_point_name, firewall_section_id, **kwargs):  # noqa: E501
        """Read Firewall  # noqa: E501

        Read a Firewall and the complete tree underneath. Returns the populated Firewall object.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_firewall_section_realized_state_with_http_info(enforcement_point_name, firewall_section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str firewall_section_id: Firewall Section Id (required)
        :return: RealizedFirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['enforcement_point_name', 'firewall_section_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_firewall_section_realized_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'enforcement_point_name' is set
        if ('enforcement_point_name' not in params or
                params['enforcement_point_name'] is None):
            raise ValueError("Missing the required parameter `enforcement_point_name` when calling `read_firewall_section_realized_state`")  # noqa: E501
        # verify the required parameter 'firewall_section_id' is set
        if ('firewall_section_id' not in params or
                params['firewall_section_id'] is None):
            raise ValueError("Missing the required parameter `firewall_section_id` when calling `read_firewall_section_realized_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'enforcement_point_name' in params:
            path_params['enforcement-point-name'] = params['enforcement_point_name']  # noqa: E501
        if 'firewall_section_id' in params:
            path_params['firewall-section-id'] = params['firewall_section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/realized-state/enforcement-points/{enforcement-point-name}/firewalls/firewall-sections/{firewall-section-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RealizedFirewallSection',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_group_for_domain(self, domain_id, group_id, **kwargs):  # noqa: E501
        """Read group  # noqa: E501

        Read group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_group_for_domain(domain_id, group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str group_id: Group ID (required)
        :return: Group
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_group_for_domain_with_http_info(domain_id, group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_group_for_domain_with_http_info(domain_id, group_id, **kwargs)  # noqa: E501
            return data

    def read_group_for_domain_with_http_info(self, domain_id, group_id, **kwargs):  # noqa: E501
        """Read group  # noqa: E501

        Read group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_group_for_domain_with_http_info(domain_id, group_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str group_id: Group ID (required)
        :return: Group
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_id', 'group_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_group_for_domain" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_id' is set
        if ('domain_id' not in params or
                params['domain_id'] is None):
            raise ValueError("Missing the required parameter `domain_id` when calling `read_group_for_domain`")  # noqa: E501
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params or
                params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `read_group_for_domain`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_id' in params:
            path_params['domain-id'] = params['domain_id']  # noqa: E501
        if 'group_id' in params:
            path_params['group-id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/domains/{domain-id}/groups/{group-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Group',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_infra(self, **kwargs):  # noqa: E501
        """Read infra  # noqa: E501

        Read infra. Returns only the infra related properties. Inner object are not populated.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_infra(async=True)
        >>> result = thread.get()

        :param async bool
        :return: Infra
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_infra_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_infra_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_infra_with_http_info(self, **kwargs):  # noqa: E501
        """Read infra  # noqa: E501

        Read infra. Returns only the infra related properties. Inner object are not populated.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_infra_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: Infra
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_infra" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Infra',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_ip_set_realized_state(self, enforcement_point_name, ip_set_name, **kwargs):  # noqa: E501
        """Read IPSet Realized state  # noqa: E501

        Read an IPSet   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ip_set_realized_state(enforcement_point_name, ip_set_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str ip_set_name: IPSet name (required)
        :return: RealizedIPSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_ip_set_realized_state_with_http_info(enforcement_point_name, ip_set_name, **kwargs)  # noqa: E501
        else:
            (data) = self.read_ip_set_realized_state_with_http_info(enforcement_point_name, ip_set_name, **kwargs)  # noqa: E501
            return data

    def read_ip_set_realized_state_with_http_info(self, enforcement_point_name, ip_set_name, **kwargs):  # noqa: E501
        """Read IPSet Realized state  # noqa: E501

        Read an IPSet   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ip_set_realized_state_with_http_info(enforcement_point_name, ip_set_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str ip_set_name: IPSet name (required)
        :return: RealizedIPSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['enforcement_point_name', 'ip_set_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_ip_set_realized_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'enforcement_point_name' is set
        if ('enforcement_point_name' not in params or
                params['enforcement_point_name'] is None):
            raise ValueError("Missing the required parameter `enforcement_point_name` when calling `read_ip_set_realized_state`")  # noqa: E501
        # verify the required parameter 'ip_set_name' is set
        if ('ip_set_name' not in params or
                params['ip_set_name'] is None):
            raise ValueError("Missing the required parameter `ip_set_name` when calling `read_ip_set_realized_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'enforcement_point_name' in params:
            path_params['enforcement-point-name'] = params['enforcement_point_name']  # noqa: E501
        if 'ip_set_name' in params:
            path_params['ip-set-name'] = params['ip_set_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/realized-state/enforcement-points/{enforcement-point-name}/ip-sets/ip-sets-nsxt/{ip-set-name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RealizedIPSet',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_mac_set_realized_state(self, enforcement_point_name, mac_set_name, **kwargs):  # noqa: E501
        """Read MACSet Realized state  # noqa: E501

        Read an MACSet   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_mac_set_realized_state(enforcement_point_name, mac_set_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str mac_set_name: MACSet name (required)
        :return: RealizedMACSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_mac_set_realized_state_with_http_info(enforcement_point_name, mac_set_name, **kwargs)  # noqa: E501
        else:
            (data) = self.read_mac_set_realized_state_with_http_info(enforcement_point_name, mac_set_name, **kwargs)  # noqa: E501
            return data

    def read_mac_set_realized_state_with_http_info(self, enforcement_point_name, mac_set_name, **kwargs):  # noqa: E501
        """Read MACSet Realized state  # noqa: E501

        Read an MACSet   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_mac_set_realized_state_with_http_info(enforcement_point_name, mac_set_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str mac_set_name: MACSet name (required)
        :return: RealizedMACSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['enforcement_point_name', 'mac_set_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_mac_set_realized_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'enforcement_point_name' is set
        if ('enforcement_point_name' not in params or
                params['enforcement_point_name'] is None):
            raise ValueError("Missing the required parameter `enforcement_point_name` when calling `read_mac_set_realized_state`")  # noqa: E501
        # verify the required parameter 'mac_set_name' is set
        if ('mac_set_name' not in params or
                params['mac_set_name'] is None):
            raise ValueError("Missing the required parameter `mac_set_name` when calling `read_mac_set_realized_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'enforcement_point_name' in params:
            path_params['enforcement-point-name'] = params['enforcement_point_name']  # noqa: E501
        if 'mac_set_name' in params:
            path_params['mac-set-name'] = params['mac_set_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/realized-state/enforcement-points/{enforcement-point-name}/mac-sets/mac-sets-nsxt/{mac-set-name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RealizedMACSet',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_ns_group_realized_state(self, enforcement_point_name, nsgroup_name, **kwargs):  # noqa: E501
        """Read Group  # noqa: E501

        Read a NSGroup and the complete tree underneath. Returns the populated NSgroup object.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ns_group_realized_state(enforcement_point_name, nsgroup_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str nsgroup_name: Group Name (required)
        :return: RealizedNSGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_ns_group_realized_state_with_http_info(enforcement_point_name, nsgroup_name, **kwargs)  # noqa: E501
        else:
            (data) = self.read_ns_group_realized_state_with_http_info(enforcement_point_name, nsgroup_name, **kwargs)  # noqa: E501
            return data

    def read_ns_group_realized_state_with_http_info(self, enforcement_point_name, nsgroup_name, **kwargs):  # noqa: E501
        """Read Group  # noqa: E501

        Read a NSGroup and the complete tree underneath. Returns the populated NSgroup object.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ns_group_realized_state_with_http_info(enforcement_point_name, nsgroup_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str nsgroup_name: Group Name (required)
        :return: RealizedNSGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['enforcement_point_name', 'nsgroup_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_ns_group_realized_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'enforcement_point_name' is set
        if ('enforcement_point_name' not in params or
                params['enforcement_point_name'] is None):
            raise ValueError("Missing the required parameter `enforcement_point_name` when calling `read_ns_group_realized_state`")  # noqa: E501
        # verify the required parameter 'nsgroup_name' is set
        if ('nsgroup_name' not in params or
                params['nsgroup_name'] is None):
            raise ValueError("Missing the required parameter `nsgroup_name` when calling `read_ns_group_realized_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'enforcement_point_name' in params:
            path_params['enforcement-point-name'] = params['enforcement_point_name']  # noqa: E501
        if 'nsgroup_name' in params:
            path_params['nsgroup-name'] = params['nsgroup_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/realized-state/enforcement-points/{enforcement-point-name}/groups/nsgroups/{nsgroup-name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RealizedNSGroup',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_ns_service_realized_state(self, enforcement_point_name, nsservice_name, **kwargs):  # noqa: E501
        """Read NSService  # noqa: E501

        Read a NSService.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ns_service_realized_state(enforcement_point_name, nsservice_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str nsservice_name: NSService Name (required)
        :return: RealizedNSService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_ns_service_realized_state_with_http_info(enforcement_point_name, nsservice_name, **kwargs)  # noqa: E501
        else:
            (data) = self.read_ns_service_realized_state_with_http_info(enforcement_point_name, nsservice_name, **kwargs)  # noqa: E501
            return data

    def read_ns_service_realized_state_with_http_info(self, enforcement_point_name, nsservice_name, **kwargs):  # noqa: E501
        """Read NSService  # noqa: E501

        Read a NSService.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ns_service_realized_state_with_http_info(enforcement_point_name, nsservice_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str nsservice_name: NSService Name (required)
        :return: RealizedNSService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['enforcement_point_name', 'nsservice_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_ns_service_realized_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'enforcement_point_name' is set
        if ('enforcement_point_name' not in params or
                params['enforcement_point_name'] is None):
            raise ValueError("Missing the required parameter `enforcement_point_name` when calling `read_ns_service_realized_state`")  # noqa: E501
        # verify the required parameter 'nsservice_name' is set
        if ('nsservice_name' not in params or
                params['nsservice_name'] is None):
            raise ValueError("Missing the required parameter `nsservice_name` when calling `read_ns_service_realized_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'enforcement_point_name' in params:
            path_params['enforcement-point-name'] = params['enforcement_point_name']  # noqa: E501
        if 'nsservice_name' in params:
            path_params['nsservice-name'] = params['nsservice_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/realized-state/enforcement-points/{enforcement-point-name}/services/nsservices/{nsservice-name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RealizedNSService',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_security_group_realized_state(self, enforcement_point_name, securitygroup_name, **kwargs):  # noqa: E501
        """Read Group  # noqa: E501

        Read a Security Group and the complete tree underneath. Returns the populated Security Group object.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_security_group_realized_state(enforcement_point_name, securitygroup_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str securitygroup_name: Group Name (required)
        :return: RealizedSecurityGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_security_group_realized_state_with_http_info(enforcement_point_name, securitygroup_name, **kwargs)  # noqa: E501
        else:
            (data) = self.read_security_group_realized_state_with_http_info(enforcement_point_name, securitygroup_name, **kwargs)  # noqa: E501
            return data

    def read_security_group_realized_state_with_http_info(self, enforcement_point_name, securitygroup_name, **kwargs):  # noqa: E501
        """Read Group  # noqa: E501

        Read a Security Group and the complete tree underneath. Returns the populated Security Group object.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_security_group_realized_state_with_http_info(enforcement_point_name, securitygroup_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str enforcement_point_name: Enforcement Point Name (required)
        :param str securitygroup_name: Group Name (required)
        :return: RealizedSecurityGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['enforcement_point_name', 'securitygroup_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_security_group_realized_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'enforcement_point_name' is set
        if ('enforcement_point_name' not in params or
                params['enforcement_point_name'] is None):
            raise ValueError("Missing the required parameter `enforcement_point_name` when calling `read_security_group_realized_state`")  # noqa: E501
        # verify the required parameter 'securitygroup_name' is set
        if ('securitygroup_name' not in params or
                params['securitygroup_name'] is None):
            raise ValueError("Missing the required parameter `securitygroup_name` when calling `read_security_group_realized_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'enforcement_point_name' in params:
            path_params['enforcement-point-name'] = params['enforcement_point_name']  # noqa: E501
        if 'securitygroup_name' in params:
            path_params['securitygroup-name'] = params['securitygroup_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/realized-state/enforcement-points/{enforcement-point-name}/groups/securitygroups/{securitygroup-name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RealizedSecurityGroup',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_service_entry(self, service_id, service_entry_id, **kwargs):  # noqa: E501
        """Service entry  # noqa: E501

        Service entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_service_entry(service_id, service_entry_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: Service ID (required)
        :param str service_entry_id: Service entry ID (required)
        :return: ServiceEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_service_entry_with_http_info(service_id, service_entry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_service_entry_with_http_info(service_id, service_entry_id, **kwargs)  # noqa: E501
            return data

    def read_service_entry_with_http_info(self, service_id, service_entry_id, **kwargs):  # noqa: E501
        """Service entry  # noqa: E501

        Service entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_service_entry_with_http_info(service_id, service_entry_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: Service ID (required)
        :param str service_entry_id: Service entry ID (required)
        :return: ServiceEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_entry_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_service_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `read_service_entry`")  # noqa: E501
        # verify the required parameter 'service_entry_id' is set
        if ('service_entry_id' not in params or
                params['service_entry_id'] is None):
            raise ValueError("Missing the required parameter `service_entry_id` when calling `read_service_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_entry_id' in params:
            path_params['service-entry-id'] = params['service_entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/services/{service-id}/service-entries/{service-entry-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceEntry',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_service_for_tenant(self, service_id, **kwargs):  # noqa: E501
        """Read a service  # noqa: E501

        Read a service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_service_for_tenant(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: Service ID (required)
        :return: Service
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_service_for_tenant_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_service_for_tenant_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def read_service_for_tenant_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Read a service  # noqa: E501

        Read a service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_service_for_tenant_with_http_info(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: Service ID (required)
        :return: Service
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_service_for_tenant" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `read_service_for_tenant`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/services/{service-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Service',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_template(self, template_id, **kwargs):  # noqa: E501
        """Read template.  # noqa: E501

        Read a template and returns the template properties for a given template identifier.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_template(template_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str template_id: Template identifier (required)
        :return: PolicyTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_template_with_http_info(template_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_template_with_http_info(template_id, **kwargs)  # noqa: E501
            return data

    def read_template_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """Read template.  # noqa: E501

        Read a template and returns the template properties for a given template identifier.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_template_with_http_info(template_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str template_id: Template identifier (required)
        :return: PolicyTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['template_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'template_id' is set
        if ('template_id' not in params or
                params['template_id'] is None):
            raise ValueError("Missing the required parameter `template_id` when calling `read_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in params:
            path_params['template-id'] = params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/templates/{template-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PolicyTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revise_communication_maps_revise(self, domain_id, communication_map, **kwargs):  # noqa: E501
        """Revise the positioninng of communication maps  # noqa: E501

        This is used to set a precedence of a communication map w.r.t others.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.revise_communication_maps_revise(domain_id, communication_map, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: (required)
        :param CommunicationMap communication_map: (required)
        :param str anchor_path: The communication map path if operation is 'insert_after' or insert_before 
        :param str operation: Operation
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.revise_communication_maps_revise_with_http_info(domain_id, communication_map, **kwargs)  # noqa: E501
        else:
            (data) = self.revise_communication_maps_revise_with_http_info(domain_id, communication_map, **kwargs)  # noqa: E501
            return data

    def revise_communication_maps_revise_with_http_info(self, domain_id, communication_map, **kwargs):  # noqa: E501
        """Revise the positioninng of communication maps  # noqa: E501

        This is used to set a precedence of a communication map w.r.t others.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.revise_communication_maps_revise_with_http_info(domain_id, communication_map, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: (required)
        :param CommunicationMap communication_map: (required)
        :param str anchor_path: The communication map path if operation is 'insert_after' or insert_before 
        :param str operation: Operation
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_id', 'communication_map', 'anchor_path', 'operation']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revise_communication_maps_revise" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_id' is set
        if ('domain_id' not in params or
                params['domain_id'] is None):
            raise ValueError("Missing the required parameter `domain_id` when calling `revise_communication_maps_revise`")  # noqa: E501
        # verify the required parameter 'communication_map' is set
        if ('communication_map' not in params or
                params['communication_map'] is None):
            raise ValueError("Missing the required parameter `communication_map` when calling `revise_communication_maps_revise`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_id' in params:
            path_params['domain-id'] = params['domain_id']  # noqa: E501

        query_params = []
        if 'anchor_path' in params:
            query_params.append(('anchor_path', params['anchor_path']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'communication_map' in params:
            body_params = params['communication_map']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/domains/{domain-id}/communication-map?action=revise', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_communication_entry(self, domain_id, communication_entry_id, communication_entry, **kwargs):  # noqa: E501
        """Create or update a CommunicationEntry  # noqa: E501

        Update the CommunicationEntry. If a CommunicationEntry with the communication-entry-id is not already present, this API fails with a 404. Creation of CommunicationEntries is not allowed using this API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_communication_entry(domain_id, communication_entry_id, communication_entry, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str communication_entry_id: CommunicationEntry ID (required)
        :param CommunicationEntry communication_entry: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_communication_entry_with_http_info(domain_id, communication_entry_id, communication_entry, **kwargs)  # noqa: E501
        else:
            (data) = self.update_communication_entry_with_http_info(domain_id, communication_entry_id, communication_entry, **kwargs)  # noqa: E501
            return data

    def update_communication_entry_with_http_info(self, domain_id, communication_entry_id, communication_entry, **kwargs):  # noqa: E501
        """Create or update a CommunicationEntry  # noqa: E501

        Update the CommunicationEntry. If a CommunicationEntry with the communication-entry-id is not already present, this API fails with a 404. Creation of CommunicationEntries is not allowed using this API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_communication_entry_with_http_info(domain_id, communication_entry_id, communication_entry, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str communication_entry_id: CommunicationEntry ID (required)
        :param CommunicationEntry communication_entry: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_id', 'communication_entry_id', 'communication_entry']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_communication_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_id' is set
        if ('domain_id' not in params or
                params['domain_id'] is None):
            raise ValueError("Missing the required parameter `domain_id` when calling `update_communication_entry`")  # noqa: E501
        # verify the required parameter 'communication_entry_id' is set
        if ('communication_entry_id' not in params or
                params['communication_entry_id'] is None):
            raise ValueError("Missing the required parameter `communication_entry_id` when calling `update_communication_entry`")  # noqa: E501
        # verify the required parameter 'communication_entry' is set
        if ('communication_entry' not in params or
                params['communication_entry'] is None):
            raise ValueError("Missing the required parameter `communication_entry` when calling `update_communication_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_id' in params:
            path_params['domain-id'] = params['domain_id']  # noqa: E501
        if 'communication_entry_id' in params:
            path_params['communication-entry-id'] = params['communication_entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'communication_entry' in params:
            body_params = params['communication_entry']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/domains/{domain-id}/communication-map/communication-entries/{communication-entry-id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_communication_map_for_domain(self, domain_id, communication_map, **kwargs):  # noqa: E501
        """Update communication map  # noqa: E501

        Update the communication map for a domain. This is a full replace. All the CommunicationEntries are replaced.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_communication_map_for_domain(domain_id, communication_map, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param CommunicationMap communication_map: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_communication_map_for_domain_with_http_info(domain_id, communication_map, **kwargs)  # noqa: E501
        else:
            (data) = self.update_communication_map_for_domain_with_http_info(domain_id, communication_map, **kwargs)  # noqa: E501
            return data

    def update_communication_map_for_domain_with_http_info(self, domain_id, communication_map, **kwargs):  # noqa: E501
        """Update communication map  # noqa: E501

        Update the communication map for a domain. This is a full replace. All the CommunicationEntries are replaced.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_communication_map_for_domain_with_http_info(domain_id, communication_map, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param CommunicationMap communication_map: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_id', 'communication_map']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_communication_map_for_domain" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_id' is set
        if ('domain_id' not in params or
                params['domain_id'] is None):
            raise ValueError("Missing the required parameter `domain_id` when calling `update_communication_map_for_domain`")  # noqa: E501
        # verify the required parameter 'communication_map' is set
        if ('communication_map' not in params or
                params['communication_map'] is None):
            raise ValueError("Missing the required parameter `communication_map` when calling `update_communication_map_for_domain`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_id' in params:
            path_params['domain-id'] = params['domain_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'communication_map' in params:
            body_params = params['communication_map']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/domains/{domain-id}/communication-map', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_communication_profile(self, communication_profile_id, communication_profile, **kwargs):  # noqa: E501
        """Create or update a CommunicationProfile  # noqa: E501

        Create a new CommunicationProfile if a CommunicationProfile with the given ID does not already exist. Creates new CommunicationProfileEntries if populated in the CommunicationProfile. If a CommunicationProfile with the given ID already exists, update the CommunicationProfile including the nested CommunicationProfileEntries. This is a full replace. This is the ONLY way to create CommunicationProfileEntries and to add them to a CommunicationProfile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_communication_profile(communication_profile_id, communication_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str communication_profile_id: CommunicationProfile ID (required)
        :param CommunicationProfile communication_profile: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_communication_profile_with_http_info(communication_profile_id, communication_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.update_communication_profile_with_http_info(communication_profile_id, communication_profile, **kwargs)  # noqa: E501
            return data

    def update_communication_profile_with_http_info(self, communication_profile_id, communication_profile, **kwargs):  # noqa: E501
        """Create or update a CommunicationProfile  # noqa: E501

        Create a new CommunicationProfile if a CommunicationProfile with the given ID does not already exist. Creates new CommunicationProfileEntries if populated in the CommunicationProfile. If a CommunicationProfile with the given ID already exists, update the CommunicationProfile including the nested CommunicationProfileEntries. This is a full replace. This is the ONLY way to create CommunicationProfileEntries and to add them to a CommunicationProfile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_communication_profile_with_http_info(communication_profile_id, communication_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str communication_profile_id: CommunicationProfile ID (required)
        :param CommunicationProfile communication_profile: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['communication_profile_id', 'communication_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_communication_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'communication_profile_id' is set
        if ('communication_profile_id' not in params or
                params['communication_profile_id'] is None):
            raise ValueError("Missing the required parameter `communication_profile_id` when calling `update_communication_profile`")  # noqa: E501
        # verify the required parameter 'communication_profile' is set
        if ('communication_profile' not in params or
                params['communication_profile'] is None):
            raise ValueError("Missing the required parameter `communication_profile` when calling `update_communication_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'communication_profile_id' in params:
            path_params['communication-profile-id'] = params['communication_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'communication_profile' in params:
            body_params = params['communication_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/communication-profiles/{communication-profile-id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_communication_profile_entry(self, communication_profile_id, communication_profile_entry_id, communication_profile_entry, **kwargs):  # noqa: E501
        """Create or update a CommunicationProfileEntry  # noqa: E501

        Update the CommunicationProfileEntry. If a CommunicationProfileEntry with the communication-profile-entry-id is not already present, this API fails with a 404. Creation of CommunicationProfileEntries is not allowed using this API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_communication_profile_entry(communication_profile_id, communication_profile_entry_id, communication_profile_entry, async=True)
        >>> result = thread.get()

        :param async bool
        :param str communication_profile_id: CommunicationProfile ID (required)
        :param str communication_profile_entry_id: CommunicationProfileEntry ID (required)
        :param CommunicationProfileEntry communication_profile_entry: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_communication_profile_entry_with_http_info(communication_profile_id, communication_profile_entry_id, communication_profile_entry, **kwargs)  # noqa: E501
        else:
            (data) = self.update_communication_profile_entry_with_http_info(communication_profile_id, communication_profile_entry_id, communication_profile_entry, **kwargs)  # noqa: E501
            return data

    def update_communication_profile_entry_with_http_info(self, communication_profile_id, communication_profile_entry_id, communication_profile_entry, **kwargs):  # noqa: E501
        """Create or update a CommunicationProfileEntry  # noqa: E501

        Update the CommunicationProfileEntry. If a CommunicationProfileEntry with the communication-profile-entry-id is not already present, this API fails with a 404. Creation of CommunicationProfileEntries is not allowed using this API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_communication_profile_entry_with_http_info(communication_profile_id, communication_profile_entry_id, communication_profile_entry, async=True)
        >>> result = thread.get()

        :param async bool
        :param str communication_profile_id: CommunicationProfile ID (required)
        :param str communication_profile_entry_id: CommunicationProfileEntry ID (required)
        :param CommunicationProfileEntry communication_profile_entry: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['communication_profile_id', 'communication_profile_entry_id', 'communication_profile_entry']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_communication_profile_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'communication_profile_id' is set
        if ('communication_profile_id' not in params or
                params['communication_profile_id'] is None):
            raise ValueError("Missing the required parameter `communication_profile_id` when calling `update_communication_profile_entry`")  # noqa: E501
        # verify the required parameter 'communication_profile_entry_id' is set
        if ('communication_profile_entry_id' not in params or
                params['communication_profile_entry_id'] is None):
            raise ValueError("Missing the required parameter `communication_profile_entry_id` when calling `update_communication_profile_entry`")  # noqa: E501
        # verify the required parameter 'communication_profile_entry' is set
        if ('communication_profile_entry' not in params or
                params['communication_profile_entry'] is None):
            raise ValueError("Missing the required parameter `communication_profile_entry` when calling `update_communication_profile_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'communication_profile_id' in params:
            path_params['communication-profile-id'] = params['communication_profile_id']  # noqa: E501
        if 'communication_profile_entry_id' in params:
            path_params['communication-profile-entry-id'] = params['communication_profile_entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'communication_profile_entry' in params:
            body_params = params['communication_profile_entry']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/communication-profiles/{communication-profile-id}/communication-profile-entries/{communication-profile-entry-id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_domain_for_infra(self, domain_id, domain, **kwargs):  # noqa: E501
        """Create or update a domain  # noqa: E501

        If a domain with the domain-id is not already present, create a new domain. If it already exists, update the domain including the nested groups. This is a full replace   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_domain_for_infra(domain_id, domain, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param Domain domain: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_domain_for_infra_with_http_info(domain_id, domain, **kwargs)  # noqa: E501
        else:
            (data) = self.update_domain_for_infra_with_http_info(domain_id, domain, **kwargs)  # noqa: E501
            return data

    def update_domain_for_infra_with_http_info(self, domain_id, domain, **kwargs):  # noqa: E501
        """Create or update a domain  # noqa: E501

        If a domain with the domain-id is not already present, create a new domain. If it already exists, update the domain including the nested groups. This is a full replace   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_domain_for_infra_with_http_info(domain_id, domain, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param Domain domain: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_id', 'domain']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_domain_for_infra" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_id' is set
        if ('domain_id' not in params or
                params['domain_id'] is None):
            raise ValueError("Missing the required parameter `domain_id` when calling `update_domain_for_infra`")  # noqa: E501
        # verify the required parameter 'domain' is set
        if ('domain' not in params or
                params['domain'] is None):
            raise ValueError("Missing the required parameter `domain` when calling `update_domain_for_infra`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_id' in params:
            path_params['domain-id'] = params['domain_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'domain' in params:
            body_params = params['domain']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/domains/{domain-id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_group_for_domain(self, domain_id, group_id, group, **kwargs):  # noqa: E501
        """Create or update a group  # noqa: E501

        If a group with the group-id is not already present, create a new group. If it already exists, update the group.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_group_for_domain(domain_id, group_id, group, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str group_id: Group ID (required)
        :param Group group: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_group_for_domain_with_http_info(domain_id, group_id, group, **kwargs)  # noqa: E501
        else:
            (data) = self.update_group_for_domain_with_http_info(domain_id, group_id, group, **kwargs)  # noqa: E501
            return data

    def update_group_for_domain_with_http_info(self, domain_id, group_id, group, **kwargs):  # noqa: E501
        """Create or update a group  # noqa: E501

        If a group with the group-id is not already present, create a new group. If it already exists, update the group.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_group_for_domain_with_http_info(domain_id, group_id, group, async=True)
        >>> result = thread.get()

        :param async bool
        :param str domain_id: Domain ID (required)
        :param str group_id: Group ID (required)
        :param Group group: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_id', 'group_id', 'group']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_group_for_domain" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_id' is set
        if ('domain_id' not in params or
                params['domain_id'] is None):
            raise ValueError("Missing the required parameter `domain_id` when calling `update_group_for_domain`")  # noqa: E501
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params or
                params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `update_group_for_domain`")  # noqa: E501
        # verify the required parameter 'group' is set
        if ('group' not in params or
                params['group'] is None):
            raise ValueError("Missing the required parameter `group` when calling `update_group_for_domain`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_id' in params:
            path_params['domain-id'] = params['domain_id']  # noqa: E501
        if 'group_id' in params:
            path_params['group-id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'group' in params:
            body_params = params['group']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/domains/{domain-id}/groups/{group-id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_infra(self, infra, **kwargs):  # noqa: E501
        """Update the infra including all the nested entities  # noqa: E501

        Update the infra including all the nested entities  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_infra(infra, async=True)
        >>> result = thread.get()

        :param async bool
        :param Infra infra: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_infra_with_http_info(infra, **kwargs)  # noqa: E501
        else:
            (data) = self.update_infra_with_http_info(infra, **kwargs)  # noqa: E501
            return data

    def update_infra_with_http_info(self, infra, **kwargs):  # noqa: E501
        """Update the infra including all the nested entities  # noqa: E501

        Update the infra including all the nested entities  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_infra_with_http_info(infra, async=True)
        >>> result = thread.get()

        :param async bool
        :param Infra infra: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['infra']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_infra" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'infra' is set
        if ('infra' not in params or
                params['infra'] is None):
            raise ValueError("Missing the required parameter `infra` when calling `update_infra`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'infra' in params:
            body_params = params['infra']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_service_entry(self, service_id, service_entry_id, service_entry, **kwargs):  # noqa: E501
        """Create or update a ServiceEntry  # noqa: E501

        If a service entry with the service-entry-id is not already present, create a new service entry. If it already exists, update the service entry.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_service_entry(service_id, service_entry_id, service_entry, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: Service ID (required)
        :param str service_entry_id: Service entry ID (required)
        :param ServiceEntry service_entry: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_service_entry_with_http_info(service_id, service_entry_id, service_entry, **kwargs)  # noqa: E501
        else:
            (data) = self.update_service_entry_with_http_info(service_id, service_entry_id, service_entry, **kwargs)  # noqa: E501
            return data

    def update_service_entry_with_http_info(self, service_id, service_entry_id, service_entry, **kwargs):  # noqa: E501
        """Create or update a ServiceEntry  # noqa: E501

        If a service entry with the service-entry-id is not already present, create a new service entry. If it already exists, update the service entry.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_service_entry_with_http_info(service_id, service_entry_id, service_entry, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: Service ID (required)
        :param str service_entry_id: Service entry ID (required)
        :param ServiceEntry service_entry: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service_entry_id', 'service_entry']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_service_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `update_service_entry`")  # noqa: E501
        # verify the required parameter 'service_entry_id' is set
        if ('service_entry_id' not in params or
                params['service_entry_id'] is None):
            raise ValueError("Missing the required parameter `service_entry_id` when calling `update_service_entry`")  # noqa: E501
        # verify the required parameter 'service_entry' is set
        if ('service_entry' not in params or
                params['service_entry'] is None):
            raise ValueError("Missing the required parameter `service_entry` when calling `update_service_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'service_entry_id' in params:
            path_params['service-entry-id'] = params['service_entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'service_entry' in params:
            body_params = params['service_entry']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/services/{service-id}/service-entries/{service-entry-id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_service_for_tenant(self, service_id, service, **kwargs):  # noqa: E501
        """Create or update a Service  # noqa: E501

        Create a new service if a service with the given ID does not already exist. Creates new service entries if populated in the service. If a service with the given ID already exists, update the service including the nested service entries. This is a full replace.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_service_for_tenant(service_id, service, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: Service ID (required)
        :param Service service: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_service_for_tenant_with_http_info(service_id, service, **kwargs)  # noqa: E501
        else:
            (data) = self.update_service_for_tenant_with_http_info(service_id, service, **kwargs)  # noqa: E501
            return data

    def update_service_for_tenant_with_http_info(self, service_id, service, **kwargs):  # noqa: E501
        """Create or update a Service  # noqa: E501

        Create a new service if a service with the given ID does not already exist. Creates new service entries if populated in the service. If a service with the given ID already exists, update the service including the nested service entries. This is a full replace.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_service_for_tenant_with_http_info(service_id, service, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: Service ID (required)
        :param Service service: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'service']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_service_for_tenant" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `update_service_for_tenant`")  # noqa: E501
        # verify the required parameter 'service' is set
        if ('service' not in params or
                params['service'] is None):
            raise ValueError("Missing the required parameter `service` when calling `update_service_for_tenant`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'service' in params:
            body_params = params['service']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/infra/services/{service-id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
