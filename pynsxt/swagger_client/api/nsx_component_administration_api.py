# coding: utf-8

"""
    NSX API

    VMware NSX REST API  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class NsxComponentAdministrationApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_certificate_import(self, trust_object_data, **kwargs):  # noqa: E501
        """Add a New Certificate  # noqa: E501

        Adds a new private-public certificate or a chain of certificates (CAs) and, optionally, a private key that can be applied to one of the user-facing components (appliance management or edge). The certificate and the key should be stored in PEM format. If no private key is provided, the certificate is used as a client certificate in the trust store.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_certificate_import(trust_object_data, async=True)
        >>> result = thread.get()

        :param async bool
        :param TrustObjectData trust_object_data: (required)
        :return: CertificateList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_certificate_import_with_http_info(trust_object_data, **kwargs)  # noqa: E501
        else:
            (data) = self.add_certificate_import_with_http_info(trust_object_data, **kwargs)  # noqa: E501
            return data

    def add_certificate_import_with_http_info(self, trust_object_data, **kwargs):  # noqa: E501
        """Add a New Certificate  # noqa: E501

        Adds a new private-public certificate or a chain of certificates (CAs) and, optionally, a private key that can be applied to one of the user-facing components (appliance management or edge). The certificate and the key should be stored in PEM format. If no private key is provided, the certificate is used as a client certificate in the trust store.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_certificate_import_with_http_info(trust_object_data, async=True)
        >>> result = thread.get()

        :param async bool
        :param TrustObjectData trust_object_data: (required)
        :return: CertificateList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['trust_object_data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_certificate_import" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'trust_object_data' is set
        if ('trust_object_data' not in params or
                params['trust_object_data'] is None):
            raise ValueError("Missing the required parameter `trust_object_data` when calling `add_certificate_import`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'trust_object_data' in params:
            body_params = params['trust_object_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/certificates?action=import', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CertificateList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_cluster_node(self, add_cluster_node_spec, action, **kwargs):  # noqa: E501
        """Add a Node to the Cluster  # noqa: E501

        Adds a new management node or controller node to the NSX cluster. A single node can perform one role, either management or control, not both.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_cluster_node(add_cluster_node_spec, action, async=True)
        >>> result = thread.get()

        :param async bool
        :param AddClusterNodeSpec add_cluster_node_spec: (required)
        :param str action: (required)
        :return: ClusterNodeConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_cluster_node_with_http_info(add_cluster_node_spec, action, **kwargs)  # noqa: E501
        else:
            (data) = self.add_cluster_node_with_http_info(add_cluster_node_spec, action, **kwargs)  # noqa: E501
            return data

    def add_cluster_node_with_http_info(self, add_cluster_node_spec, action, **kwargs):  # noqa: E501
        """Add a Node to the Cluster  # noqa: E501

        Adds a new management node or controller node to the NSX cluster. A single node can perform one role, either management or control, not both.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_cluster_node_with_http_info(add_cluster_node_spec, action, async=True)
        >>> result = thread.get()

        :param async bool
        :param AddClusterNodeSpec add_cluster_node_spec: (required)
        :param str action: (required)
        :return: ClusterNodeConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['add_cluster_node_spec', 'action']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_cluster_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'add_cluster_node_spec' is set
        if ('add_cluster_node_spec' not in params or
                params['add_cluster_node_spec'] is None):
            raise ValueError("Missing the required parameter `add_cluster_node_spec` when calling `add_cluster_node`")  # noqa: E501
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `add_cluster_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'add_cluster_node_spec' in params:
            body_params = params['add_cluster_node_spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/nodes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterNodeConfig',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_crl_import(self, crl_object_data, **kwargs):  # noqa: E501
        """Add a New Certificate Revocation List  # noqa: E501

        Adds a new certificate revocation list (CRL). The CRL is used to verify the client certificate status against the revocation lists published by the CA. For this reason, the administrator needs to add the CRL in certificate repository as well.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_crl_import(crl_object_data, async=True)
        >>> result = thread.get()

        :param async bool
        :param CrlObjectData crl_object_data: (required)
        :return: CrlList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_crl_import_with_http_info(crl_object_data, **kwargs)  # noqa: E501
        else:
            (data) = self.add_crl_import_with_http_info(crl_object_data, **kwargs)  # noqa: E501
            return data

    def add_crl_import_with_http_info(self, crl_object_data, **kwargs):  # noqa: E501
        """Add a New Certificate Revocation List  # noqa: E501

        Adds a new certificate revocation list (CRL). The CRL is used to verify the client certificate status against the revocation lists published by the CA. For this reason, the administrator needs to add the CRL in certificate repository as well.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_crl_import_with_http_info(crl_object_data, async=True)
        >>> result = thread.get()

        :param async bool
        :param CrlObjectData crl_object_data: (required)
        :return: CrlList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['crl_object_data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_crl_import" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'crl_object_data' is set
        if ('crl_object_data' not in params or
                params['crl_object_data'] is None):
            raise ValueError("Missing the required parameter `crl_object_data` when calling `add_crl_import`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'crl_object_data' in params:
            body_params = params['crl_object_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/crls?action=import', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CrlList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_node_user_ssh_key_add_ssh_key(self, userid, ssh_key_properties, **kwargs):  # noqa: E501
        """Add SSH public key to authorized_keys file for node user  # noqa: E501

        Add SSH public key to authorized_keys file for node user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_node_user_ssh_key_add_ssh_key(userid, ssh_key_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param str userid: User id of the user (required)
        :param SshKeyProperties ssh_key_properties: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_node_user_ssh_key_add_ssh_key_with_http_info(userid, ssh_key_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.add_node_user_ssh_key_add_ssh_key_with_http_info(userid, ssh_key_properties, **kwargs)  # noqa: E501
            return data

    def add_node_user_ssh_key_add_ssh_key_with_http_info(self, userid, ssh_key_properties, **kwargs):  # noqa: E501
        """Add SSH public key to authorized_keys file for node user  # noqa: E501

        Add SSH public key to authorized_keys file for node user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_node_user_ssh_key_add_ssh_key_with_http_info(userid, ssh_key_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param str userid: User id of the user (required)
        :param SshKeyProperties ssh_key_properties: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['userid', 'ssh_key_properties']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_node_user_ssh_key_add_ssh_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'userid' is set
        if ('userid' not in params or
                params['userid'] is None):
            raise ValueError("Missing the required parameter `userid` when calling `add_node_user_ssh_key_add_ssh_key`")  # noqa: E501
        # verify the required parameter 'ssh_key_properties' is set
        if ('ssh_key_properties' not in params or
                params['ssh_key_properties'] is None):
            raise ValueError("Missing the required parameter `ssh_key_properties` when calling `add_node_user_ssh_key_add_ssh_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'userid' in params:
            path_params['userid'] = params['userid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ssh_key_properties' in params:
            body_params = params['ssh_key_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/users/{userid}/ssh-keys?action=add_ssh_key', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def advance_cluster_restore_advance(self, advance_cluster_restore_request, **kwargs):  # noqa: E501
        """Advance any suspended restore operation  # noqa: E501

        Advance any currently suspended restore operation. The operation might have been suspended because (1) the user had suspended it previously, or (2) the operation is waiting for user input, to be provided as a part of the POST request body. This operation is only valid when a GET cluster/restore/status returns a status with value SUSPENDED. Otherwise, a 409 response is returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.advance_cluster_restore_advance(advance_cluster_restore_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param AdvanceClusterRestoreRequest advance_cluster_restore_request: (required)
        :return: ClusterRestoreStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.advance_cluster_restore_advance_with_http_info(advance_cluster_restore_request, **kwargs)  # noqa: E501
        else:
            (data) = self.advance_cluster_restore_advance_with_http_info(advance_cluster_restore_request, **kwargs)  # noqa: E501
            return data

    def advance_cluster_restore_advance_with_http_info(self, advance_cluster_restore_request, **kwargs):  # noqa: E501
        """Advance any suspended restore operation  # noqa: E501

        Advance any currently suspended restore operation. The operation might have been suspended because (1) the user had suspended it previously, or (2) the operation is waiting for user input, to be provided as a part of the POST request body. This operation is only valid when a GET cluster/restore/status returns a status with value SUSPENDED. Otherwise, a 409 response is returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.advance_cluster_restore_advance_with_http_info(advance_cluster_restore_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param AdvanceClusterRestoreRequest advance_cluster_restore_request: (required)
        :return: ClusterRestoreStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['advance_cluster_restore_request']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method advance_cluster_restore_advance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'advance_cluster_restore_request' is set
        if ('advance_cluster_restore_request' not in params or
                params['advance_cluster_restore_request'] is None):
            raise ValueError("Missing the required parameter `advance_cluster_restore_request` when calling `advance_cluster_restore_advance`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'advance_cluster_restore_request' in params:
            body_params = params['advance_cluster_restore_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/restore?action=advance', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterRestoreStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cancel_appliance_management_task_cancel(self, task_id, **kwargs):  # noqa: E501
        """Cancel specified task  # noqa: E501

        Cancel specified task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.cancel_appliance_management_task_cancel(task_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str task_id: ID of task to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.cancel_appliance_management_task_cancel_with_http_info(task_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cancel_appliance_management_task_cancel_with_http_info(task_id, **kwargs)  # noqa: E501
            return data

    def cancel_appliance_management_task_cancel_with_http_info(self, task_id, **kwargs):  # noqa: E501
        """Cancel specified task  # noqa: E501

        Cancel specified task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.cancel_appliance_management_task_cancel_with_http_info(task_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str task_id: ID of task to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_appliance_management_task_cancel" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'task_id' is set
        if ('task_id' not in params or
                params['task_id'] is None):
            raise ValueError("Missing the required parameter `task_id` when calling `cancel_appliance_management_task_cancel`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_id' in params:
            path_params['task-id'] = params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/tasks/{task-id}?action=cancel', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cancel_cluster_restore_cancel(self, **kwargs):  # noqa: E501
        """Cancel any running restore operation  # noqa: E501

        Cancel any currently running restore operation. If there exists a currently running step, it is allowed to finish. The system is not rolled back to the pre-restore state. This operation is only valid when a GET cluster/restore/status returns a status with value RUNNING or SUSPENDED. Otherwise, a 409 response is returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.cancel_cluster_restore_cancel(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ClusterRestoreStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.cancel_cluster_restore_cancel_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.cancel_cluster_restore_cancel_with_http_info(**kwargs)  # noqa: E501
            return data

    def cancel_cluster_restore_cancel_with_http_info(self, **kwargs):  # noqa: E501
        """Cancel any running restore operation  # noqa: E501

        Cancel any currently running restore operation. If there exists a currently running step, it is allowed to finish. The system is not rolled back to the pre-restore state. This operation is only valid when a GET cluster/restore/status returns a status with value RUNNING or SUSPENDED. Otherwise, a 409 response is returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.cancel_cluster_restore_cancel_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ClusterRestoreStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_cluster_restore_cancel" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/restore?action=cancel', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterRestoreStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def check_rabbit_mq_management_port(self, **kwargs):  # noqa: E501
        """Check if RabbitMQ management port is enabled or not  # noqa: E501

        Returns status as true if RabbitMQ management port is enabled else false  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.check_rabbit_mq_management_port(async=True)
        >>> result = thread.get()

        :param async bool
        :return: PortStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.check_rabbit_mq_management_port_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.check_rabbit_mq_management_port_with_http_info(**kwargs)  # noqa: E501
            return data

    def check_rabbit_mq_management_port_with_http_info(self, **kwargs):  # noqa: E501
        """Check if RabbitMQ management port is enabled or not  # noqa: E501

        Returns status as true if RabbitMQ management port is enabled else false  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.check_rabbit_mq_management_port_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: PortStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method check_rabbit_mq_management_port" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/rabbitmq-management-port', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PortStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def collect_support_bundles_collect(self, support_bundle_request, **kwargs):  # noqa: E501
        """Collect support bundles from registered cluster and fabric nodes  # noqa: E501

        Collect support bundles from registered cluster and fabric nodes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.collect_support_bundles_collect(support_bundle_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param SupportBundleRequest support_bundle_request: (required)
        :param bool override_async_response: Override any existing support bundle async response
        :return: SupportBundleResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.collect_support_bundles_collect_with_http_info(support_bundle_request, **kwargs)  # noqa: E501
        else:
            (data) = self.collect_support_bundles_collect_with_http_info(support_bundle_request, **kwargs)  # noqa: E501
            return data

    def collect_support_bundles_collect_with_http_info(self, support_bundle_request, **kwargs):  # noqa: E501
        """Collect support bundles from registered cluster and fabric nodes  # noqa: E501

        Collect support bundles from registered cluster and fabric nodes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.collect_support_bundles_collect_with_http_info(support_bundle_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param SupportBundleRequest support_bundle_request: (required)
        :param bool override_async_response: Override any existing support bundle async response
        :return: SupportBundleResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['support_bundle_request', 'override_async_response']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method collect_support_bundles_collect" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'support_bundle_request' is set
        if ('support_bundle_request' not in params or
                params['support_bundle_request'] is None):
            raise ValueError("Missing the required parameter `support_bundle_request` when calling `collect_support_bundles_collect`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'override_async_response' in params:
            query_params.append(('override_async_response', params['override_async_response']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'support_bundle_request' in params:
            body_params = params['support_bundle_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/administration/support-bundles?action=collect', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SupportBundleResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def configure_backup_config(self, backup_configuration, **kwargs):  # noqa: E501
        """Configure backup  # noqa: E501

        Configure file server and timers for automated backup. If secret fields are omitted (password, passphrase) then use the previously set value.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.configure_backup_config(backup_configuration, async=True)
        >>> result = thread.get()

        :param async bool
        :param BackupConfiguration backup_configuration: (required)
        :return: BackupConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.configure_backup_config_with_http_info(backup_configuration, **kwargs)  # noqa: E501
        else:
            (data) = self.configure_backup_config_with_http_info(backup_configuration, **kwargs)  # noqa: E501
            return data

    def configure_backup_config_with_http_info(self, backup_configuration, **kwargs):  # noqa: E501
        """Configure backup  # noqa: E501

        Configure file server and timers for automated backup. If secret fields are omitted (password, passphrase) then use the previously set value.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.configure_backup_config_with_http_info(backup_configuration, async=True)
        >>> result = thread.get()

        :param async bool
        :param BackupConfiguration backup_configuration: (required)
        :return: BackupConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['backup_configuration']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method configure_backup_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'backup_configuration' is set
        if ('backup_configuration' not in params or
                params['backup_configuration'] is None):
            raise ValueError("Missing the required parameter `backup_configuration` when calling `configure_backup_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'backup_configuration' in params:
            body_params = params['backup_configuration']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/backups/config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BackupConfiguration',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def configure_restore_config(self, restore_configuration, **kwargs):  # noqa: E501
        """Configure Restore SFTP server credentials  # noqa: E501

        Configure file server where the backed-up files used for the Restore operation are available.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.configure_restore_config(restore_configuration, async=True)
        >>> result = thread.get()

        :param async bool
        :param RestoreConfiguration restore_configuration: (required)
        :return: RestoreConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.configure_restore_config_with_http_info(restore_configuration, **kwargs)  # noqa: E501
        else:
            (data) = self.configure_restore_config_with_http_info(restore_configuration, **kwargs)  # noqa: E501
            return data

    def configure_restore_config_with_http_info(self, restore_configuration, **kwargs):  # noqa: E501
        """Configure Restore SFTP server credentials  # noqa: E501

        Configure file server where the backed-up files used for the Restore operation are available.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.configure_restore_config_with_http_info(restore_configuration, async=True)
        >>> result = thread.get()

        :param async bool
        :param RestoreConfiguration restore_configuration: (required)
        :return: RestoreConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['restore_configuration']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method configure_restore_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'restore_configuration' is set
        if ('restore_configuration' not in params or
                params['restore_configuration'] is None):
            raise ValueError("Missing the required parameter `restore_configuration` when calling `configure_restore_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'restore_configuration' in params:
            body_params = params['restore_configuration']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/restore/config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RestoreConfiguration',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def copy_from_remote_file_copy_from_remote_file(self, file_name, copy_from_remote_file_properties, **kwargs):  # noqa: E501
        """Copy a remote file to the file store  # noqa: E501

        Copy a remote file to the file store. If you use scp or sftp, you must provide the remote server's SSH fingerprint. See the <i>NSX-T Administration Guide</i> for information and instructions about finding the SSH fingerprint.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.copy_from_remote_file_copy_from_remote_file(file_name, copy_from_remote_file_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_name: Destination filename (required)
        :param CopyFromRemoteFileProperties copy_from_remote_file_properties: (required)
        :return: FileProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.copy_from_remote_file_copy_from_remote_file_with_http_info(file_name, copy_from_remote_file_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.copy_from_remote_file_copy_from_remote_file_with_http_info(file_name, copy_from_remote_file_properties, **kwargs)  # noqa: E501
            return data

    def copy_from_remote_file_copy_from_remote_file_with_http_info(self, file_name, copy_from_remote_file_properties, **kwargs):  # noqa: E501
        """Copy a remote file to the file store  # noqa: E501

        Copy a remote file to the file store. If you use scp or sftp, you must provide the remote server's SSH fingerprint. See the <i>NSX-T Administration Guide</i> for information and instructions about finding the SSH fingerprint.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.copy_from_remote_file_copy_from_remote_file_with_http_info(file_name, copy_from_remote_file_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_name: Destination filename (required)
        :param CopyFromRemoteFileProperties copy_from_remote_file_properties: (required)
        :return: FileProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_name', 'copy_from_remote_file_properties']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_from_remote_file_copy_from_remote_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `copy_from_remote_file_copy_from_remote_file`")  # noqa: E501
        # verify the required parameter 'copy_from_remote_file_properties' is set
        if ('copy_from_remote_file_properties' not in params or
                params['copy_from_remote_file_properties'] is None):
            raise ValueError("Missing the required parameter `copy_from_remote_file_properties` when calling `copy_from_remote_file_copy_from_remote_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_name' in params:
            path_params['file-name'] = params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'copy_from_remote_file_properties' in params:
            body_params = params['copy_from_remote_file_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/file-store/{file-name}?action=copy_from_remote_file', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def copy_to_remote_file_copy_to_remote_file(self, file_name, copy_to_remote_file_properties, **kwargs):  # noqa: E501
        """Copy file in the file store to a remote file store  # noqa: E501

        Copy a file in the file store to a remote server. If you use scp or sftp, you must provide the remote server's SSH fingerprint. See the <i>NSX-T Administration Guide</i> for information and instructions about finding the SSH fingerprint.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.copy_to_remote_file_copy_to_remote_file(file_name, copy_to_remote_file_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_name: Destination filename (required)
        :param CopyToRemoteFileProperties copy_to_remote_file_properties: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.copy_to_remote_file_copy_to_remote_file_with_http_info(file_name, copy_to_remote_file_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.copy_to_remote_file_copy_to_remote_file_with_http_info(file_name, copy_to_remote_file_properties, **kwargs)  # noqa: E501
            return data

    def copy_to_remote_file_copy_to_remote_file_with_http_info(self, file_name, copy_to_remote_file_properties, **kwargs):  # noqa: E501
        """Copy file in the file store to a remote file store  # noqa: E501

        Copy a file in the file store to a remote server. If you use scp or sftp, you must provide the remote server's SSH fingerprint. See the <i>NSX-T Administration Guide</i> for information and instructions about finding the SSH fingerprint.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.copy_to_remote_file_copy_to_remote_file_with_http_info(file_name, copy_to_remote_file_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_name: Destination filename (required)
        :param CopyToRemoteFileProperties copy_to_remote_file_properties: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_name', 'copy_to_remote_file_properties']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_to_remote_file_copy_to_remote_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `copy_to_remote_file_copy_to_remote_file`")  # noqa: E501
        # verify the required parameter 'copy_to_remote_file_properties' is set
        if ('copy_to_remote_file_properties' not in params or
                params['copy_to_remote_file_properties'] is None):
            raise ValueError("Missing the required parameter `copy_to_remote_file_properties` when calling `copy_to_remote_file_copy_to_remote_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_name' in params:
            path_params['file-name'] = params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'copy_to_remote_file_properties' in params:
            body_params = params['copy_to_remote_file_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/file-store/{file-name}?action=copy_to_remote_file', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_appliance_management_service_action_restart(self, **kwargs):  # noqa: E501
        """Restart the node management service  # noqa: E501

        Restart the node management service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_appliance_management_service_action_restart(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_appliance_management_service_action_restart_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_appliance_management_service_action_restart_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_appliance_management_service_action_restart_with_http_info(self, **kwargs):  # noqa: E501
        """Restart the node management service  # noqa: E501

        Restart the node management service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_appliance_management_service_action_restart_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_appliance_management_service_action_restart" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/node-mgmt?action=restart', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cminventory_service_action_restart(self, **kwargs):  # noqa: E501
        """Restart, start or stop the manager service  # noqa: E501

        Restart, start or stop the manager service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_cminventory_service_action_restart(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_cminventory_service_action_restart_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_cminventory_service_action_restart_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_cminventory_service_action_restart_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the manager service  # noqa: E501

        Restart, start or stop the manager service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_cminventory_service_action_restart_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cminventory_service_action_restart" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/cm-inventory?action=restart', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cminventory_service_action_start(self, **kwargs):  # noqa: E501
        """Restart, start or stop the manager service  # noqa: E501

        Restart, start or stop the manager service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_cminventory_service_action_start(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_cminventory_service_action_start_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_cminventory_service_action_start_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_cminventory_service_action_start_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the manager service  # noqa: E501

        Restart, start or stop the manager service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_cminventory_service_action_start_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cminventory_service_action_start" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/cm-inventory?action=start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cminventory_service_action_stop(self, **kwargs):  # noqa: E501
        """Restart, start or stop the manager service  # noqa: E501

        Restart, start or stop the manager service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_cminventory_service_action_stop(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_cminventory_service_action_stop_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_cminventory_service_action_stop_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_cminventory_service_action_stop_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the manager service  # noqa: E501

        Restart, start or stop the manager service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_cminventory_service_action_stop_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cminventory_service_action_stop" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/cm-inventory?action=stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_file(self, file_name, **kwargs):  # noqa: E501
        """Upload a file to the file store  # noqa: E501

        When you issue this API, the client must specify: - HTTP header Content-Type:application/octet-stream. - Request body with the contents of the file in the filestore. In the CLI, you can view the filestore with the <em>get files</em> command.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_file(file_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_name: Destination filename (required)
        :return: FileProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_file_with_http_info(file_name, **kwargs)  # noqa: E501
        else:
            (data) = self.create_file_with_http_info(file_name, **kwargs)  # noqa: E501
            return data

    def create_file_with_http_info(self, file_name, **kwargs):  # noqa: E501
        """Upload a file to the file store  # noqa: E501

        When you issue this API, the client must specify: - HTTP header Content-Type:application/octet-stream. - Request body with the contents of the file in the filestore. In the CLI, you can view the filestore with the <em>get files</em> command.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_file_with_http_info(file_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_name: Destination filename (required)
        :return: FileProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `create_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_name' in params:
            path_params['file-name'] = params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/file-store/{file-name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_liagent_service_action_restart(self, **kwargs):  # noqa: E501
        """Restart, start or stop the liagent service  # noqa: E501

        Restart, start or stop the liagent service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_liagent_service_action_restart(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_liagent_service_action_restart_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_liagent_service_action_restart_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_liagent_service_action_restart_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the liagent service  # noqa: E501

        Restart, start or stop the liagent service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_liagent_service_action_restart_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_liagent_service_action_restart" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/liagent?action=restart', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_liagent_service_action_start(self, **kwargs):  # noqa: E501
        """Restart, start or stop the liagent service  # noqa: E501

        Restart, start or stop the liagent service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_liagent_service_action_start(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_liagent_service_action_start_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_liagent_service_action_start_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_liagent_service_action_start_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the liagent service  # noqa: E501

        Restart, start or stop the liagent service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_liagent_service_action_start_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_liagent_service_action_start" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/liagent?action=start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_liagent_service_action_stop(self, **kwargs):  # noqa: E501
        """Restart, start or stop the liagent service  # noqa: E501

        Restart, start or stop the liagent service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_liagent_service_action_stop(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_liagent_service_action_stop_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_liagent_service_action_stop_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_liagent_service_action_stop_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the liagent service  # noqa: E501

        Restart, start or stop the liagent service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_liagent_service_action_stop_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_liagent_service_action_stop" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/liagent?action=stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_node_network_route(self, node_route_properties, **kwargs):  # noqa: E501
        """Create node network route  # noqa: E501

        Add a route to the NSX Manager routing table. For static routes, the route_type, interface_id, netmask, and destination are required parameters. For default routes, the route_type, gateway address, and interface_id are required. For blackhole routes, the route_type and destination are required. All other parameters are optional. When you add a static route, the scope and route_id are created automatically. When you add a default or blackhole route, the route_id is created automatically. The route_id is read-only, meaning that it cannot be modified. All other properties can be modified by deleting and readding the route.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_node_network_route(node_route_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeRouteProperties node_route_properties: (required)
        :return: NodeRouteProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_node_network_route_with_http_info(node_route_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.create_node_network_route_with_http_info(node_route_properties, **kwargs)  # noqa: E501
            return data

    def create_node_network_route_with_http_info(self, node_route_properties, **kwargs):  # noqa: E501
        """Create node network route  # noqa: E501

        Add a route to the NSX Manager routing table. For static routes, the route_type, interface_id, netmask, and destination are required parameters. For default routes, the route_type, gateway address, and interface_id are required. For blackhole routes, the route_type and destination are required. All other parameters are optional. When you add a static route, the scope and route_id are created automatically. When you add a default or blackhole route, the route_id is created automatically. The route_id is read-only, meaning that it cannot be modified. All other properties can be modified by deleting and readding the route.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_node_network_route_with_http_info(node_route_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeRouteProperties node_route_properties: (required)
        :return: NodeRouteProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_route_properties']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_node_network_route" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_route_properties' is set
        if ('node_route_properties' not in params or
                params['node_route_properties'] is None):
            raise ValueError("Missing the required parameter `node_route_properties` when calling `create_node_network_route`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'node_route_properties' in params:
            body_params = params['node_route_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/network/routes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeRouteProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_nsx_message_bus_service_action_restart(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX Message Bus service  # noqa: E501

        Restart, start or stop the NSX Message Bus service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_nsx_message_bus_service_action_restart(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_nsx_message_bus_service_action_restart_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_nsx_message_bus_service_action_restart_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_nsx_message_bus_service_action_restart_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX Message Bus service  # noqa: E501

        Restart, start or stop the NSX Message Bus service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_nsx_message_bus_service_action_restart_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_nsx_message_bus_service_action_restart" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/nsx-message-bus?action=restart', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_nsx_message_bus_service_action_start(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX Message Bus service  # noqa: E501

        Restart, start or stop the NSX Message Bus service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_nsx_message_bus_service_action_start(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_nsx_message_bus_service_action_start_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_nsx_message_bus_service_action_start_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_nsx_message_bus_service_action_start_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX Message Bus service  # noqa: E501

        Restart, start or stop the NSX Message Bus service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_nsx_message_bus_service_action_start_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_nsx_message_bus_service_action_start" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/nsx-message-bus?action=start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_nsx_message_bus_service_action_stop(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX Message Bus service  # noqa: E501

        Restart, start or stop the NSX Message Bus service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_nsx_message_bus_service_action_stop(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_nsx_message_bus_service_action_stop_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_nsx_message_bus_service_action_stop_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_nsx_message_bus_service_action_stop_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX Message Bus service  # noqa: E501

        Restart, start or stop the NSX Message Bus service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_nsx_message_bus_service_action_stop_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_nsx_message_bus_service_action_stop" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/nsx-message-bus?action=stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_nsx_upgrade_agent_service_action_restart(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX upgrade agent service  # noqa: E501

        Restart, start or stop the NSX upgrade agent service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_nsx_upgrade_agent_service_action_restart(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_nsx_upgrade_agent_service_action_restart_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_nsx_upgrade_agent_service_action_restart_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_nsx_upgrade_agent_service_action_restart_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX upgrade agent service  # noqa: E501

        Restart, start or stop the NSX upgrade agent service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_nsx_upgrade_agent_service_action_restart_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_nsx_upgrade_agent_service_action_restart" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/nsx-upgrade-agent?action=restart', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_nsx_upgrade_agent_service_action_start(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX upgrade agent service  # noqa: E501

        Restart, start or stop the NSX upgrade agent service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_nsx_upgrade_agent_service_action_start(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_nsx_upgrade_agent_service_action_start_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_nsx_upgrade_agent_service_action_start_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_nsx_upgrade_agent_service_action_start_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX upgrade agent service  # noqa: E501

        Restart, start or stop the NSX upgrade agent service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_nsx_upgrade_agent_service_action_start_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_nsx_upgrade_agent_service_action_start" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/nsx-upgrade-agent?action=start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_nsx_upgrade_agent_service_action_stop(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX upgrade agent service  # noqa: E501

        Restart, start or stop the NSX upgrade agent service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_nsx_upgrade_agent_service_action_stop(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_nsx_upgrade_agent_service_action_stop_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_nsx_upgrade_agent_service_action_stop_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_nsx_upgrade_agent_service_action_stop_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX upgrade agent service  # noqa: E501

        Restart, start or stop the NSX upgrade agent service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_nsx_upgrade_agent_service_action_stop_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_nsx_upgrade_agent_service_action_stop" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/nsx-upgrade-agent?action=stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ntp_service_action_restart(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NTP service  # noqa: E501

        Restart, start or stop the NTP service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ntp_service_action_restart(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_ntp_service_action_restart_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_ntp_service_action_restart_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_ntp_service_action_restart_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NTP service  # noqa: E501

        Restart, start or stop the NTP service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ntp_service_action_restart_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ntp_service_action_restart" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/ntp?action=restart', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ntp_service_action_start(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NTP service  # noqa: E501

        Restart, start or stop the NTP service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ntp_service_action_start(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_ntp_service_action_start_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_ntp_service_action_start_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_ntp_service_action_start_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NTP service  # noqa: E501

        Restart, start or stop the NTP service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ntp_service_action_start_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ntp_service_action_start" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/ntp?action=start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ntp_service_action_stop(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NTP service  # noqa: E501

        Restart, start or stop the NTP service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ntp_service_action_stop(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_ntp_service_action_stop_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_ntp_service_action_stop_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_ntp_service_action_stop_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NTP service  # noqa: E501

        Restart, start or stop the NTP service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ntp_service_action_stop_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ntp_service_action_stop" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/ntp?action=stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_proton_service_action_restart(self, **kwargs):  # noqa: E501
        """Restart, start or stop the service  # noqa: E501

        Restart, start or stop the service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_proton_service_action_restart(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_proton_service_action_restart_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_proton_service_action_restart_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_proton_service_action_restart_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the service  # noqa: E501

        Restart, start or stop the service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_proton_service_action_restart_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_proton_service_action_restart" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/manager?action=restart', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_proton_service_action_start(self, **kwargs):  # noqa: E501
        """Restart, start or stop the service  # noqa: E501

        Restart, start or stop the service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_proton_service_action_start(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_proton_service_action_start_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_proton_service_action_start_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_proton_service_action_start_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the service  # noqa: E501

        Restart, start or stop the service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_proton_service_action_start_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_proton_service_action_start" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/manager?action=start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_proton_service_action_stop(self, **kwargs):  # noqa: E501
        """Restart, start or stop the service  # noqa: E501

        Restart, start or stop the service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_proton_service_action_stop(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_proton_service_action_stop_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_proton_service_action_stop_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_proton_service_action_stop_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the service  # noqa: E501

        Restart, start or stop the service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_proton_service_action_stop_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_proton_service_action_stop" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/manager?action=stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_proxy_service_action_restart(self, **kwargs):  # noqa: E501
        """Restart the http service  # noqa: E501

        Restart the http service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_proxy_service_action_restart(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_proxy_service_action_restart_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_proxy_service_action_restart_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_proxy_service_action_restart_with_http_info(self, **kwargs):  # noqa: E501
        """Restart the http service  # noqa: E501

        Restart the http service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_proxy_service_action_restart_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_proxy_service_action_restart" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/http?action=restart', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_proxy_service_action_start(self, **kwargs):  # noqa: E501
        """Start the http service  # noqa: E501

        Start the http service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_proxy_service_action_start(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_proxy_service_action_start_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_proxy_service_action_start_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_proxy_service_action_start_with_http_info(self, **kwargs):  # noqa: E501
        """Start the http service  # noqa: E501

        Start the http service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_proxy_service_action_start_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_proxy_service_action_start" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/http?action=start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_proxy_service_action_stop(self, **kwargs):  # noqa: E501
        """Stop the http service  # noqa: E501

        Stop the http service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_proxy_service_action_stop(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_proxy_service_action_stop_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_proxy_service_action_stop_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_proxy_service_action_stop_with_http_info(self, **kwargs):  # noqa: E501
        """Stop the http service  # noqa: E501

        Stop the http service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_proxy_service_action_stop_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_proxy_service_action_stop" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/http?action=stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_proxy_service_apply_certificate_action_apply_certificate(self, certificate_id, **kwargs):  # noqa: E501
        """Update http service certificate  # noqa: E501

        Applies a security certificate to the http service. In the POST request, the CERTIFICATE_ID references a certificate created with the /api/v1/trust-management APIs. Issuing this request causes the http service to restart so that the service can begin using the new certificate. When the POST request succeeds, it doesn't return a valid response. The request times out because of the restart.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_proxy_service_apply_certificate_action_apply_certificate(certificate_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str certificate_id: Certificate ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_proxy_service_apply_certificate_action_apply_certificate_with_http_info(certificate_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_proxy_service_apply_certificate_action_apply_certificate_with_http_info(certificate_id, **kwargs)  # noqa: E501
            return data

    def create_proxy_service_apply_certificate_action_apply_certificate_with_http_info(self, certificate_id, **kwargs):  # noqa: E501
        """Update http service certificate  # noqa: E501

        Applies a security certificate to the http service. In the POST request, the CERTIFICATE_ID references a certificate created with the /api/v1/trust-management APIs. Issuing this request causes the http service to restart so that the service can begin using the new certificate. When the POST request succeeds, it doesn't return a valid response. The request times out because of the restart.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_proxy_service_apply_certificate_action_apply_certificate_with_http_info(certificate_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str certificate_id: Certificate ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['certificate_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_proxy_service_apply_certificate_action_apply_certificate" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'certificate_id' is set
        if ('certificate_id' not in params or
                params['certificate_id'] is None):
            raise ValueError("Missing the required parameter `certificate_id` when calling `create_proxy_service_apply_certificate_action_apply_certificate`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'certificate_id' in params:
            query_params.append(('certificate_id', params['certificate_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/http?action=apply_certificate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_rabbit_mq_service_action_restart(self, **kwargs):  # noqa: E501
        """Restart, start or stop the Rabbit MQ service  # noqa: E501

        Restart, start or stop the Rabbit MQ service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_rabbit_mq_service_action_restart(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_rabbit_mq_service_action_restart_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_rabbit_mq_service_action_restart_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_rabbit_mq_service_action_restart_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the Rabbit MQ service  # noqa: E501

        Restart, start or stop the Rabbit MQ service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_rabbit_mq_service_action_restart_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_rabbit_mq_service_action_restart" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/mgmt-plane-bus?action=restart', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_rabbit_mq_service_action_start(self, **kwargs):  # noqa: E501
        """Restart, start or stop the Rabbit MQ service  # noqa: E501

        Restart, start or stop the Rabbit MQ service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_rabbit_mq_service_action_start(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_rabbit_mq_service_action_start_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_rabbit_mq_service_action_start_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_rabbit_mq_service_action_start_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the Rabbit MQ service  # noqa: E501

        Restart, start or stop the Rabbit MQ service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_rabbit_mq_service_action_start_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_rabbit_mq_service_action_start" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/mgmt-plane-bus?action=start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_rabbit_mq_service_action_stop(self, **kwargs):  # noqa: E501
        """Restart, start or stop the Rabbit MQ service  # noqa: E501

        Restart, start or stop the Rabbit MQ service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_rabbit_mq_service_action_stop(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_rabbit_mq_service_action_stop_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_rabbit_mq_service_action_stop_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_rabbit_mq_service_action_stop_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the Rabbit MQ service  # noqa: E501

        Restart, start or stop the Rabbit MQ service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_rabbit_mq_service_action_stop_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_rabbit_mq_service_action_stop" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/mgmt-plane-bus?action=stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_remote_directory_create_remote_directory(self, create_remote_directory_properties, **kwargs):  # noqa: E501
        """Create directory in remote file server  # noqa: E501

        Create a directory on the remote remote server. Supports only SFTP. You must provide the remote server's SSH fingerprint. See the <i>NSX Administration Guide</i> for information and instructions about finding the SSH fingerprint.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_remote_directory_create_remote_directory(create_remote_directory_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param CreateRemoteDirectoryProperties create_remote_directory_properties: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_remote_directory_create_remote_directory_with_http_info(create_remote_directory_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.create_remote_directory_create_remote_directory_with_http_info(create_remote_directory_properties, **kwargs)  # noqa: E501
            return data

    def create_remote_directory_create_remote_directory_with_http_info(self, create_remote_directory_properties, **kwargs):  # noqa: E501
        """Create directory in remote file server  # noqa: E501

        Create a directory on the remote remote server. Supports only SFTP. You must provide the remote server's SSH fingerprint. See the <i>NSX Administration Guide</i> for information and instructions about finding the SSH fingerprint.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_remote_directory_create_remote_directory_with_http_info(create_remote_directory_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param CreateRemoteDirectoryProperties create_remote_directory_properties: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['create_remote_directory_properties']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_remote_directory_create_remote_directory" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'create_remote_directory_properties' is set
        if ('create_remote_directory_properties' not in params or
                params['create_remote_directory_properties'] is None):
            raise ValueError("Missing the required parameter `create_remote_directory_properties` when calling `create_remote_directory_create_remote_directory`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_remote_directory_properties' in params:
            body_params = params['create_remote_directory_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/file-store?action=create_remote_directory', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_repository_service_action_restart(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX install-upgrade service  # noqa: E501

        Restart, start or stop the NSX install-upgrade service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_repository_service_action_restart(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_repository_service_action_restart_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_repository_service_action_restart_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_repository_service_action_restart_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX install-upgrade service  # noqa: E501

        Restart, start or stop the NSX install-upgrade service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_repository_service_action_restart_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_repository_service_action_restart" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/install-upgrade?action=restart', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_repository_service_action_start(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX install-upgrade service  # noqa: E501

        Restart, start or stop the NSX install-upgrade service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_repository_service_action_start(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_repository_service_action_start_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_repository_service_action_start_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_repository_service_action_start_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX install-upgrade service  # noqa: E501

        Restart, start or stop the NSX install-upgrade service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_repository_service_action_start_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_repository_service_action_start" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/install-upgrade?action=start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_repository_service_action_stop(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX install-upgrade service  # noqa: E501

        Restart, start or stop the NSX install-upgrade service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_repository_service_action_stop(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_repository_service_action_stop_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_repository_service_action_stop_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_repository_service_action_stop_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX install-upgrade service  # noqa: E501

        Restart, start or stop the NSX install-upgrade service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_repository_service_action_stop_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_repository_service_action_stop" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/install-upgrade?action=stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_search_service_action_restart(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX Search service  # noqa: E501

        Restart, start or stop the NSX Search service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_search_service_action_restart(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_search_service_action_restart_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_search_service_action_restart_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_search_service_action_restart_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX Search service  # noqa: E501

        Restart, start or stop the NSX Search service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_search_service_action_restart_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_search_service_action_restart" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/search?action=restart', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_search_service_action_start(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX Search service  # noqa: E501

        Restart, start or stop the NSX Search service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_search_service_action_start(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_search_service_action_start_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_search_service_action_start_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_search_service_action_start_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX Search service  # noqa: E501

        Restart, start or stop the NSX Search service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_search_service_action_start_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_search_service_action_start" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/search?action=start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_search_service_action_stop(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX Search service  # noqa: E501

        Restart, start or stop the NSX Search service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_search_service_action_stop(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_search_service_action_stop_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_search_service_action_stop_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_search_service_action_stop_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the NSX Search service  # noqa: E501

        Restart, start or stop the NSX Search service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_search_service_action_stop_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_search_service_action_stop" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/search?action=stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_snmp_service_action_restart(self, **kwargs):  # noqa: E501
        """Restart, start or stop the SNMP service  # noqa: E501

        Restart, start or stop the SNMP service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_snmp_service_action_restart(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_snmp_service_action_restart_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_snmp_service_action_restart_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_snmp_service_action_restart_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the SNMP service  # noqa: E501

        Restart, start or stop the SNMP service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_snmp_service_action_restart_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_snmp_service_action_restart" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/snmp?action=restart', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_snmp_service_action_start(self, **kwargs):  # noqa: E501
        """Restart, start or stop the SNMP service  # noqa: E501

        Restart, start or stop the SNMP service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_snmp_service_action_start(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_snmp_service_action_start_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_snmp_service_action_start_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_snmp_service_action_start_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the SNMP service  # noqa: E501

        Restart, start or stop the SNMP service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_snmp_service_action_start_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_snmp_service_action_start" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/snmp?action=start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_snmp_service_action_stop(self, **kwargs):  # noqa: E501
        """Restart, start or stop the SNMP service  # noqa: E501

        Restart, start or stop the SNMP service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_snmp_service_action_stop(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_snmp_service_action_stop_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_snmp_service_action_stop_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_snmp_service_action_stop_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the SNMP service  # noqa: E501

        Restart, start or stop the SNMP service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_snmp_service_action_stop_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_snmp_service_action_stop" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/snmp?action=stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ssh_service_action_restart(self, **kwargs):  # noqa: E501
        """Restart, start or stop the ssh service  # noqa: E501

        Restart, start or stop the ssh service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ssh_service_action_restart(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_ssh_service_action_restart_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_ssh_service_action_restart_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_ssh_service_action_restart_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the ssh service  # noqa: E501

        Restart, start or stop the ssh service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ssh_service_action_restart_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ssh_service_action_restart" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/ssh?action=restart', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ssh_service_action_start(self, **kwargs):  # noqa: E501
        """Restart, start or stop the ssh service  # noqa: E501

        Restart, start or stop the ssh service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ssh_service_action_start(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_ssh_service_action_start_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_ssh_service_action_start_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_ssh_service_action_start_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the ssh service  # noqa: E501

        Restart, start or stop the ssh service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ssh_service_action_start_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ssh_service_action_start" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/ssh?action=start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ssh_service_action_stop(self, **kwargs):  # noqa: E501
        """Restart, start or stop the ssh service  # noqa: E501

        Restart, start or stop the ssh service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ssh_service_action_stop(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_ssh_service_action_stop_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_ssh_service_action_stop_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_ssh_service_action_stop_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the ssh service  # noqa: E501

        Restart, start or stop the ssh service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ssh_service_action_stop_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ssh_service_action_stop" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/ssh?action=stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ssh_service_remove_host_fingerprint_action_remove_host_fingerprint(self, known_host_parameter, **kwargs):  # noqa: E501
        """Remove a host&#39;s fingerprint from known hosts file  # noqa: E501

        Remove a host's fingerprint from known hosts file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ssh_service_remove_host_fingerprint_action_remove_host_fingerprint(known_host_parameter, async=True)
        >>> result = thread.get()

        :param async bool
        :param KnownHostParameter known_host_parameter: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_ssh_service_remove_host_fingerprint_action_remove_host_fingerprint_with_http_info(known_host_parameter, **kwargs)  # noqa: E501
        else:
            (data) = self.create_ssh_service_remove_host_fingerprint_action_remove_host_fingerprint_with_http_info(known_host_parameter, **kwargs)  # noqa: E501
            return data

    def create_ssh_service_remove_host_fingerprint_action_remove_host_fingerprint_with_http_info(self, known_host_parameter, **kwargs):  # noqa: E501
        """Remove a host&#39;s fingerprint from known hosts file  # noqa: E501

        Remove a host's fingerprint from known hosts file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_ssh_service_remove_host_fingerprint_action_remove_host_fingerprint_with_http_info(known_host_parameter, async=True)
        >>> result = thread.get()

        :param async bool
        :param KnownHostParameter known_host_parameter: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['known_host_parameter']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ssh_service_remove_host_fingerprint_action_remove_host_fingerprint" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'known_host_parameter' is set
        if ('known_host_parameter' not in params or
                params['known_host_parameter'] is None):
            raise ValueError("Missing the required parameter `known_host_parameter` when calling `create_ssh_service_remove_host_fingerprint_action_remove_host_fingerprint`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'known_host_parameter' in params:
            body_params = params['known_host_parameter']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/ssh?action=remove_host_fingerprint', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_syslog_service_action_restart(self, **kwargs):  # noqa: E501
        """Restart, start or stop the syslog service  # noqa: E501

        Restart, start or stop the syslog service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_syslog_service_action_restart(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_syslog_service_action_restart_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_syslog_service_action_restart_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_syslog_service_action_restart_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the syslog service  # noqa: E501

        Restart, start or stop the syslog service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_syslog_service_action_restart_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_syslog_service_action_restart" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/syslog?action=restart', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_syslog_service_action_start(self, **kwargs):  # noqa: E501
        """Restart, start or stop the syslog service  # noqa: E501

        Restart, start or stop the syslog service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_syslog_service_action_start(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_syslog_service_action_start_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_syslog_service_action_start_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_syslog_service_action_start_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the syslog service  # noqa: E501

        Restart, start or stop the syslog service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_syslog_service_action_start_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_syslog_service_action_start" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/syslog?action=start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_syslog_service_action_stop(self, **kwargs):  # noqa: E501
        """Restart, start or stop the syslog service  # noqa: E501

        Restart, start or stop the syslog service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_syslog_service_action_stop(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_syslog_service_action_stop_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_syslog_service_action_stop_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_syslog_service_action_stop_with_http_info(self, **kwargs):  # noqa: E501
        """Restart, start or stop the syslog service  # noqa: E501

        Restart, start or stop the syslog service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_syslog_service_action_stop_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_syslog_service_action_stop" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/syslog?action=stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def d_elete_rabbit_mq_management_port(self, **kwargs):  # noqa: E501
        """Delete RabbitMQ management port  # noqa: E501

        Delete RabbitMQ management port  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.d_elete_rabbit_mq_management_port(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.d_elete_rabbit_mq_management_port_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.d_elete_rabbit_mq_management_port_with_http_info(**kwargs)  # noqa: E501
            return data

    def d_elete_rabbit_mq_management_port_with_http_info(self, **kwargs):  # noqa: E501
        """Delete RabbitMQ management port  # noqa: E501

        Delete RabbitMQ management port  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.d_elete_rabbit_mq_management_port_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method d_elete_rabbit_mq_management_port" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/rabbitmq-management-port', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_appliance_management_task(self, task_id, **kwargs):  # noqa: E501
        """Delete task  # noqa: E501

        Delete task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_appliance_management_task(task_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str task_id: ID of task to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_appliance_management_task_with_http_info(task_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_appliance_management_task_with_http_info(task_id, **kwargs)  # noqa: E501
            return data

    def delete_appliance_management_task_with_http_info(self, task_id, **kwargs):  # noqa: E501
        """Delete task  # noqa: E501

        Delete task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_appliance_management_task_with_http_info(task_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str task_id: ID of task to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_appliance_management_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'task_id' is set
        if ('task_id' not in params or
                params['task_id'] is None):
            raise ValueError("Missing the required parameter `task_id` when calling `delete_appliance_management_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_id' in params:
            path_params['task-id'] = params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/tasks/{task-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_certificate(self, cert_id, **kwargs):  # noqa: E501
        """Delete Certificate for the Given Certificate ID  # noqa: E501

        Removes the specified certificate. The private key associated with the certificate is also deleted.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_certificate(cert_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str cert_id: ID of certificate to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_certificate_with_http_info(cert_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_certificate_with_http_info(cert_id, **kwargs)  # noqa: E501
            return data

    def delete_certificate_with_http_info(self, cert_id, **kwargs):  # noqa: E501
        """Delete Certificate for the Given Certificate ID  # noqa: E501

        Removes the specified certificate. The private key associated with the certificate is also deleted.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_certificate_with_http_info(cert_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str cert_id: ID of certificate to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cert_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_certificate" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cert_id' is set
        if ('cert_id' not in params or
                params['cert_id'] is None):
            raise ValueError("Missing the required parameter `cert_id` when calling `delete_certificate`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cert_id' in params:
            path_params['cert-id'] = params['cert_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/certificates/{cert-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_cluster_node_config(self, node_id, **kwargs):  # noqa: E501
        """Remove a Node from the Cluster  # noqa: E501

        Removes the specified manager or control node from the NSX cluster. Before you can remove a node from the cluster, you must shut down the manager or controller service with the \"stop service manager\" or the \"stop service controller\" command.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_cluster_node_config(node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_cluster_node_config_with_http_info(node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_cluster_node_config_with_http_info(node_id, **kwargs)  # noqa: E501
            return data

    def delete_cluster_node_config_with_http_info(self, node_id, **kwargs):  # noqa: E501
        """Remove a Node from the Cluster  # noqa: E501

        Removes the specified manager or control node from the NSX cluster. Before you can remove a node from the cluster, you must shut down the manager or controller service with the \"stop service manager\" or the \"stop service controller\" command.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_cluster_node_config_with_http_info(node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_cluster_node_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `delete_cluster_node_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/nodes/{node-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_crl(self, crl_id, **kwargs):  # noqa: E501
        """Delete a CRL  # noqa: E501

        Deletes an existing CRL.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_crl(crl_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str crl_id: ID of CRL to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_crl_with_http_info(crl_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_crl_with_http_info(crl_id, **kwargs)  # noqa: E501
            return data

    def delete_crl_with_http_info(self, crl_id, **kwargs):  # noqa: E501
        """Delete a CRL  # noqa: E501

        Deletes an existing CRL.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_crl_with_http_info(crl_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str crl_id: ID of CRL to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['crl_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_crl" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'crl_id' is set
        if ('crl_id' not in params or
                params['crl_id'] is None):
            raise ValueError("Missing the required parameter `crl_id` when calling `delete_crl`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'crl_id' in params:
            path_params['crl-id'] = params['crl_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/crls/{crl-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_csr(self, csr_id, **kwargs):  # noqa: E501
        """Delete a CSR  # noqa: E501

        Removes a specified CSR. If a CSR is not used for verification, you can delete it. Note that the CSR import and upload POST actions automatically delete the associated CSR.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_csr(csr_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str csr_id: ID of CSR to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_csr_with_http_info(csr_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_csr_with_http_info(csr_id, **kwargs)  # noqa: E501
            return data

    def delete_csr_with_http_info(self, csr_id, **kwargs):  # noqa: E501
        """Delete a CSR  # noqa: E501

        Removes a specified CSR. If a CSR is not used for verification, you can delete it. Note that the CSR import and upload POST actions automatically delete the associated CSR.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_csr_with_http_info(csr_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str csr_id: ID of CSR to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['csr_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_csr" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'csr_id' is set
        if ('csr_id' not in params or
                params['csr_id'] is None):
            raise ValueError("Missing the required parameter `csr_id` when calling `delete_csr`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'csr_id' in params:
            path_params['csr-id'] = params['csr_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/csrs/{csr-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_file(self, file_name, **kwargs):  # noqa: E501
        """Delete file  # noqa: E501

        Delete file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_file(file_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_name: Name of the file to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_file_with_http_info(file_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_file_with_http_info(file_name, **kwargs)  # noqa: E501
            return data

    def delete_file_with_http_info(self, file_name, **kwargs):  # noqa: E501
        """Delete file  # noqa: E501

        Delete file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_file_with_http_info(file_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_name: Name of the file to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `delete_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_name' in params:
            path_params['file-name'] = params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/file-store/{file-name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_node_network_route(self, route_id, **kwargs):  # noqa: E501
        """Delete node network route  # noqa: E501

        Delete a route from the NSX Manager routing table. You can modify an existing route by deleting it and then posting the modified version of the route. To verify, remove the route ID from the URI, issue a GET request, and note the absense of the deleted route.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_node_network_route(route_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str route_id: ID of route to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_node_network_route_with_http_info(route_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_node_network_route_with_http_info(route_id, **kwargs)  # noqa: E501
            return data

    def delete_node_network_route_with_http_info(self, route_id, **kwargs):  # noqa: E501
        """Delete node network route  # noqa: E501

        Delete a route from the NSX Manager routing table. You can modify an existing route by deleting it and then posting the modified version of the route. To verify, remove the route ID from the URI, issue a GET request, and note the absense of the deleted route.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_node_network_route_with_http_info(route_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str route_id: ID of route to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['route_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_node_network_route" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'route_id' is set
        if ('route_id' not in params or
                params['route_id'] is None):
            raise ValueError("Missing the required parameter `route_id` when calling `delete_node_network_route`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'route_id' in params:
            path_params['route-id'] = params['route_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/network/routes/{route-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_node_syslog_exporter(self, exporter_name, **kwargs):  # noqa: E501
        """Delete node syslog exporter  # noqa: E501

        Removes a specified rule from the collection of syslog exporter rules.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_node_syslog_exporter(exporter_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str exporter_name: Name of syslog exporter to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_node_syslog_exporter_with_http_info(exporter_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_node_syslog_exporter_with_http_info(exporter_name, **kwargs)  # noqa: E501
            return data

    def delete_node_syslog_exporter_with_http_info(self, exporter_name, **kwargs):  # noqa: E501
        """Delete node syslog exporter  # noqa: E501

        Removes a specified rule from the collection of syslog exporter rules.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_node_syslog_exporter_with_http_info(exporter_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str exporter_name: Name of syslog exporter to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['exporter_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_node_syslog_exporter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'exporter_name' is set
        if ('exporter_name' not in params or
                params['exporter_name'] is None):
            raise ValueError("Missing the required parameter `exporter_name` when calling `delete_node_syslog_exporter`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'exporter_name' in params:
            path_params['exporter-name'] = params['exporter_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/syslog/exporters/{exporter-name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_node_user_ssh_key_remove_ssh_key(self, userid, ssh_key_base_properties, **kwargs):  # noqa: E501
        """Remove SSH public key from authorized_keys file for node user  # noqa: E501

        Remove SSH public key from authorized_keys file for node user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_node_user_ssh_key_remove_ssh_key(userid, ssh_key_base_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param str userid: User id of the user (required)
        :param SshKeyBaseProperties ssh_key_base_properties: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_node_user_ssh_key_remove_ssh_key_with_http_info(userid, ssh_key_base_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_node_user_ssh_key_remove_ssh_key_with_http_info(userid, ssh_key_base_properties, **kwargs)  # noqa: E501
            return data

    def delete_node_user_ssh_key_remove_ssh_key_with_http_info(self, userid, ssh_key_base_properties, **kwargs):  # noqa: E501
        """Remove SSH public key from authorized_keys file for node user  # noqa: E501

        Remove SSH public key from authorized_keys file for node user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_node_user_ssh_key_remove_ssh_key_with_http_info(userid, ssh_key_base_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param str userid: User id of the user (required)
        :param SshKeyBaseProperties ssh_key_base_properties: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['userid', 'ssh_key_base_properties']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_node_user_ssh_key_remove_ssh_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'userid' is set
        if ('userid' not in params or
                params['userid'] is None):
            raise ValueError("Missing the required parameter `userid` when calling `delete_node_user_ssh_key_remove_ssh_key`")  # noqa: E501
        # verify the required parameter 'ssh_key_base_properties' is set
        if ('ssh_key_base_properties' not in params or
                params['ssh_key_base_properties'] is None):
            raise ValueError("Missing the required parameter `ssh_key_base_properties` when calling `delete_node_user_ssh_key_remove_ssh_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'userid' in params:
            path_params['userid'] = params['userid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ssh_key_base_properties' in params:
            body_params = params['ssh_key_base_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/users/{userid}/ssh-keys?action=remove_ssh_key', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_principal_identity(self, principal_identity_id, **kwargs):  # noqa: E501
        """Delete a principal identity  # noqa: E501

        Delete a principal identity. It does not delete the certificate.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_principal_identity(principal_identity_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str principal_identity_id: Unique id of the principal identity to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_principal_identity_with_http_info(principal_identity_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_principal_identity_with_http_info(principal_identity_id, **kwargs)  # noqa: E501
            return data

    def delete_principal_identity_with_http_info(self, principal_identity_id, **kwargs):  # noqa: E501
        """Delete a principal identity  # noqa: E501

        Delete a principal identity. It does not delete the certificate.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_principal_identity_with_http_info(principal_identity_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str principal_identity_id: Unique id of the principal identity to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['principal_identity_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_principal_identity" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'principal_identity_id' is set
        if ('principal_identity_id' not in params or
                params['principal_identity_id'] is None):
            raise ValueError("Missing the required parameter `principal_identity_id` when calling `delete_principal_identity`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'principal_identity_id' in params:
            path_params['principal-identity-id'] = params['principal_identity_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/principal-identities/{principal-identity-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def generate_csr(self, csr, **kwargs):  # noqa: E501
        """Generate a New Certificate Signing Request  # noqa: E501

        Creates a new certificate signing request (CSR). A CSR is encrypted text that contains information about your organization (organization name, country, and so on) and your Web server's public key, which is a public certificate the is generated on the server that can be used to forward this request to a certificate authority (CA). A private key is also usually created at the same time as the CSR.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.generate_csr(csr, async=True)
        >>> result = thread.get()

        :param async bool
        :param Csr csr: (required)
        :return: Csr
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.generate_csr_with_http_info(csr, **kwargs)  # noqa: E501
        else:
            (data) = self.generate_csr_with_http_info(csr, **kwargs)  # noqa: E501
            return data

    def generate_csr_with_http_info(self, csr, **kwargs):  # noqa: E501
        """Generate a New Certificate Signing Request  # noqa: E501

        Creates a new certificate signing request (CSR). A CSR is encrypted text that contains information about your organization (organization name, country, and so on) and your Web server's public key, which is a public certificate the is generated on the server that can be used to forward this request to a certificate authority (CA). A private key is also usually created at the same time as the CSR.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.generate_csr_with_http_info(csr, async=True)
        >>> result = thread.get()

        :param async bool
        :param Csr csr: (required)
        :return: Csr
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['csr']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_csr" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'csr' is set
        if ('csr' not in params or
                params['csr'] is None):
            raise ValueError("Missing the required parameter `csr` when calling `generate_csr`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'csr' in params:
            body_params = params['csr']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/csrs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Csr',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_backup_config(self, **kwargs):  # noqa: E501
        """Get backup configuration  # noqa: E501

        Get a configuration of a file server and timers for automated backup. Fields that contain secrets (password, passphrase) are not returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_backup_config(async=True)
        >>> result = thread.get()

        :param async bool
        :return: BackupConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_backup_config_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_backup_config_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_backup_config_with_http_info(self, **kwargs):  # noqa: E501
        """Get backup configuration  # noqa: E501

        Get a configuration of a file server and timers for automated backup. Fields that contain secrets (password, passphrase) are not returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_backup_config_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: BackupConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_backup_config" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/backups/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BackupConfiguration',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_backup_history(self, **kwargs):  # noqa: E501
        """Get backup history  # noqa: E501

        Get history of previous backup operations   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_backup_history(async=True)
        >>> result = thread.get()

        :param async bool
        :return: BackupOperationHistory
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_backup_history_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_backup_history_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_backup_history_with_http_info(self, **kwargs):  # noqa: E501
        """Get backup history  # noqa: E501

        Get history of previous backup operations   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_backup_history_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: BackupOperationHistory
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_backup_history" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/backups/history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BackupOperationHistory',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_backup_status(self, **kwargs):  # noqa: E501
        """Get backup status  # noqa: E501

        Get status of active backup operations   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_backup_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: CurrentBackupOperationStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_backup_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_backup_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_backup_status_with_http_info(self, **kwargs):  # noqa: E501
        """Get backup status  # noqa: E501

        Get status of active backup operations   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_backup_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: CurrentBackupOperationStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_backup_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/backups/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CurrentBackupOperationStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_certificate(self, cert_id, **kwargs):  # noqa: E501
        """Show Certificate Data for the Given Certificate ID  # noqa: E501

        Returns information for the specified certificate ID, including the certificate's UUID; resource_type (for example, certificate_self_signed, certificate_ca, or certificate_signed); pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details=true modifier at the end of the request URI.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_certificate(cert_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str cert_id: ID of certificate to read (required)
        :param bool details: whether to expand the pem data and show all its details
        :return: Certificate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_certificate_with_http_info(cert_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_certificate_with_http_info(cert_id, **kwargs)  # noqa: E501
            return data

    def get_certificate_with_http_info(self, cert_id, **kwargs):  # noqa: E501
        """Show Certificate Data for the Given Certificate ID  # noqa: E501

        Returns information for the specified certificate ID, including the certificate's UUID; resource_type (for example, certificate_self_signed, certificate_ca, or certificate_signed); pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details=true modifier at the end of the request URI.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_certificate_with_http_info(cert_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str cert_id: ID of certificate to read (required)
        :param bool details: whether to expand the pem data and show all its details
        :return: Certificate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cert_id', 'details']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_certificate" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cert_id' is set
        if ('cert_id' not in params or
                params['cert_id'] is None):
            raise ValueError("Missing the required parameter `cert_id` when calling `get_certificate`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cert_id' in params:
            path_params['cert-id'] = params['cert_id']  # noqa: E501

        query_params = []
        if 'details' in params:
            query_params.append(('details', params['details']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/certificates/{cert-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Certificate',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_certificates(self, **kwargs):  # noqa: E501
        """Return All the User-Facing Components&#39; Certificates  # noqa: E501

        Returns all certificate information viewable by the user, including each certificate's UUID; resource_type (for example, certificate_self_signed, certificate_ca, or certificate_signed); pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details=true modifier at the end of the request URI.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_certificates(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool details: whether to expand the pem data and show all its details
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: CertificateList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_certificates_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_certificates_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_certificates_with_http_info(self, **kwargs):  # noqa: E501
        """Return All the User-Facing Components&#39; Certificates  # noqa: E501

        Returns all certificate information viewable by the user, including each certificate's UUID; resource_type (for example, certificate_self_signed, certificate_ca, or certificate_signed); pem_encoded data; and history of the certificate (who created or modified it and when). For additional information, include the ?details=true modifier at the end of the request URI.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_certificates_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool details: whether to expand the pem data and show all its details
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: CertificateList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'details', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_certificates" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_certificates`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_certificates`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'details' in params:
            query_params.append(('details', params['details']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/certificates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CertificateList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crl(self, crl_id, **kwargs):  # noqa: E501
        """Show CRL Data for the Given CRL ID  # noqa: E501

        Returns information about the specified CRL. For additional information, include the ?details=true modifier at the end of the request URI.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crl(crl_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str crl_id: ID of CRL to read (required)
        :param bool details: whether to expand the pem data and show all its details
        :return: Crl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crl_with_http_info(crl_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_crl_with_http_info(crl_id, **kwargs)  # noqa: E501
            return data

    def get_crl_with_http_info(self, crl_id, **kwargs):  # noqa: E501
        """Show CRL Data for the Given CRL ID  # noqa: E501

        Returns information about the specified CRL. For additional information, include the ?details=true modifier at the end of the request URI.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crl_with_http_info(crl_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str crl_id: ID of CRL to read (required)
        :param bool details: whether to expand the pem data and show all its details
        :return: Crl
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['crl_id', 'details']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crl" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'crl_id' is set
        if ('crl_id' not in params or
                params['crl_id'] is None):
            raise ValueError("Missing the required parameter `crl_id` when calling `get_crl`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'crl_id' in params:
            path_params['crl-id'] = params['crl_id']  # noqa: E501

        query_params = []
        if 'details' in params:
            query_params.append(('details', params['details']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/crls/{crl-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Crl',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_crls(self, **kwargs):  # noqa: E501
        """Return All Added CRLs  # noqa: E501

        Returns information about all CRLs. For additional information, include the ?details=true modifier at the end of the request URI.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crls(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool details: whether to expand the pem data and show all its details
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: CrlList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_crls_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_crls_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_crls_with_http_info(self, **kwargs):  # noqa: E501
        """Return All Added CRLs  # noqa: E501

        Returns information about all CRLs. For additional information, include the ?details=true modifier at the end of the request URI.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_crls_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param bool details: whether to expand the pem data and show all its details
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: CrlList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'details', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_crls" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crls`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_crls`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'details' in params:
            query_params.append(('details', params['details']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/crls', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CrlList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_csr(self, csr_id, **kwargs):  # noqa: E501
        """Show CSR Data for the Given CSR ID  # noqa: E501

        Returns information about the specified CSR.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_csr(csr_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str csr_id: ID of CSR to read (required)
        :return: Csr
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_csr_with_http_info(csr_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_csr_with_http_info(csr_id, **kwargs)  # noqa: E501
            return data

    def get_csr_with_http_info(self, csr_id, **kwargs):  # noqa: E501
        """Show CSR Data for the Given CSR ID  # noqa: E501

        Returns information about the specified CSR.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_csr_with_http_info(csr_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str csr_id: ID of CSR to read (required)
        :return: Csr
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['csr_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_csr" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'csr_id' is set
        if ('csr_id' not in params or
                params['csr_id'] is None):
            raise ValueError("Missing the required parameter `csr_id` when calling `get_csr`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'csr_id' in params:
            path_params['csr-id'] = params['csr_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/csrs/{csr-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Csr',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_csr_pem(self, csr_id, **kwargs):  # noqa: E501
        """Get CSR PEM File for the Given CSR ID  # noqa: E501

        Downloads the CSR PEM file for a specified CSR. Clients must include an Accept: text/plain request header.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_csr_pem(csr_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str csr_id: ID of CSR to read (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_csr_pem_with_http_info(csr_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_csr_pem_with_http_info(csr_id, **kwargs)  # noqa: E501
            return data

    def get_csr_pem_with_http_info(self, csr_id, **kwargs):  # noqa: E501
        """Get CSR PEM File for the Given CSR ID  # noqa: E501

        Downloads the CSR PEM file for a specified CSR. Clients must include an Accept: text/plain request header.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_csr_pem_with_http_info(csr_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str csr_id: ID of CSR to read (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['csr_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_csr_pem" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'csr_id' is set
        if ('csr_id' not in params or
                params['csr_id'] is None):
            raise ValueError("Missing the required parameter `csr_id` when calling `get_csr_pem`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'csr_id' in params:
            path_params['csr-id'] = params['csr_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain;charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/csrs/{csr-id}/pem-file', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_csrs(self, **kwargs):  # noqa: E501
        """Return All the Generated CSRs  # noqa: E501

        Returns information about all of the CSRs that have been created.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_csrs(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: CsrList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_csrs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_csrs_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_csrs_with_http_info(self, **kwargs):  # noqa: E501
        """Return All the Generated CSRs  # noqa: E501

        Returns information about all of the CSRs that have been created.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_csrs_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: CsrList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_csrs" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_csrs`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_csrs`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/csrs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CsrList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_node_mandatory_access_control(self, **kwargs):  # noqa: E501
        """Gets the enable status for Mandatory Access Control  # noqa: E501

        Gets the enable status for Mandatory Access Control  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_node_mandatory_access_control(async=True)
        >>> result = thread.get()

        :param async bool
        :return: MandatoryAccessControlProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_node_mandatory_access_control_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_node_mandatory_access_control_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_node_mandatory_access_control_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the enable status for Mandatory Access Control  # noqa: E501

        Gets the enable status for Mandatory Access Control  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_node_mandatory_access_control_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: MandatoryAccessControlProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_node_mandatory_access_control" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/hardening-policy/mandatory-access-control', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MandatoryAccessControlProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_node_mandatory_access_control_report(self, **kwargs):  # noqa: E501
        """Get the report for Mandatory Access Control  # noqa: E501

        Get the report for Mandatory Access Control  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_node_mandatory_access_control_report(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_node_mandatory_access_control_report_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_node_mandatory_access_control_report_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_node_mandatory_access_control_report_with_http_info(self, **kwargs):  # noqa: E501
        """Get the report for Mandatory Access Control  # noqa: E501

        Get the report for Mandatory Access Control  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_node_mandatory_access_control_report_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_node_mandatory_access_control_report" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/hardening-policy/mandatory-access-control/report', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_principal_identities(self, **kwargs):  # noqa: E501
        """Return the list of principal identities  # noqa: E501

        Returns the list of principals registered with a certificate.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_principal_identities(async=True)
        >>> result = thread.get()

        :param async bool
        :return: PrincipalIdentityList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_principal_identities_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_principal_identities_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_principal_identities_with_http_info(self, **kwargs):  # noqa: E501
        """Return the list of principal identities  # noqa: E501

        Returns the list of principals registered with a certificate.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_principal_identities_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: PrincipalIdentityList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_principal_identities" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/principal-identities', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrincipalIdentityList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_restore_config(self, **kwargs):  # noqa: E501
        """Get Restore configuration  # noqa: E501

        Get configuration information for the file server used to store backed-up files. Fields that contain secrets (password, passphrase) are not returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_restore_config(async=True)
        >>> result = thread.get()

        :param async bool
        :return: RestoreConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_restore_config_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_restore_config_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_restore_config_with_http_info(self, **kwargs):  # noqa: E501
        """Get Restore configuration  # noqa: E501

        Get configuration information for the file server used to store backed-up files. Fields that contain secrets (password, passphrase) are not returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_restore_config_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: RestoreConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_restore_config" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/restore/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RestoreConfiguration',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_trust_objects(self, **kwargs):  # noqa: E501
        """Return the Properties of a Trust Manager  # noqa: E501

        Returns information about the supported algorithms and key sizes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_trust_objects(async=True)
        >>> result = thread.get()

        :param async bool
        :return: TrustManagementData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_trust_objects_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_trust_objects_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_trust_objects_with_http_info(self, **kwargs):  # noqa: E501
        """Return the Properties of a Trust Manager  # noqa: E501

        Returns information about the supported algorithms and key sizes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_trust_objects_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: TrustManagementData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_trust_objects" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TrustManagementData',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_certificate_import(self, csr_id, trust_object_data, **kwargs):  # noqa: E501
        """Import a Certificate Associated with an Approved CSR  # noqa: E501

        Imports a certificate authority (CA)-signed certificate for a CSR. This action links the certificate to the private key created by the CSR. The pem_encoded string in the request body is the signed certificate provided by your CA in response to the CSR that you provide to them. The import POST action automatically deletes the associated CSR.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.import_certificate_import(csr_id, trust_object_data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str csr_id: CSR this certificate is associated with (required)
        :param TrustObjectData trust_object_data: (required)
        :return: CertificateList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.import_certificate_import_with_http_info(csr_id, trust_object_data, **kwargs)  # noqa: E501
        else:
            (data) = self.import_certificate_import_with_http_info(csr_id, trust_object_data, **kwargs)  # noqa: E501
            return data

    def import_certificate_import_with_http_info(self, csr_id, trust_object_data, **kwargs):  # noqa: E501
        """Import a Certificate Associated with an Approved CSR  # noqa: E501

        Imports a certificate authority (CA)-signed certificate for a CSR. This action links the certificate to the private key created by the CSR. The pem_encoded string in the request body is the signed certificate provided by your CA in response to the CSR that you provide to them. The import POST action automatically deletes the associated CSR.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.import_certificate_import_with_http_info(csr_id, trust_object_data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str csr_id: CSR this certificate is associated with (required)
        :param TrustObjectData trust_object_data: (required)
        :return: CertificateList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['csr_id', 'trust_object_data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_certificate_import" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'csr_id' is set
        if ('csr_id' not in params or
                params['csr_id'] is None):
            raise ValueError("Missing the required parameter `csr_id` when calling `import_certificate_import`")  # noqa: E501
        # verify the required parameter 'trust_object_data' is set
        if ('trust_object_data' not in params or
                params['trust_object_data'] is None):
            raise ValueError("Missing the required parameter `trust_object_data` when calling `import_certificate_import`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'csr_id' in params:
            path_params['csr-id'] = params['csr_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'trust_object_data' in params:
            body_params = params['trust_object_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/csrs/{csr-id}?action=import', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CertificateList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def initiate_cluster_restore_start(self, initiate_cluster_restore_request, **kwargs):  # noqa: E501
        """Initiate a restore operation  # noqa: E501

        Start the restore of an NSX cluster, from some previously backed-up configuration. This operation is only valid when a GET cluster/restore/status returns a status with value NOT_STARTED. Otherwise, a 409 response is returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.initiate_cluster_restore_start(initiate_cluster_restore_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param InitiateClusterRestoreRequest initiate_cluster_restore_request: (required)
        :return: ClusterRestoreStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.initiate_cluster_restore_start_with_http_info(initiate_cluster_restore_request, **kwargs)  # noqa: E501
        else:
            (data) = self.initiate_cluster_restore_start_with_http_info(initiate_cluster_restore_request, **kwargs)  # noqa: E501
            return data

    def initiate_cluster_restore_start_with_http_info(self, initiate_cluster_restore_request, **kwargs):  # noqa: E501
        """Initiate a restore operation  # noqa: E501

        Start the restore of an NSX cluster, from some previously backed-up configuration. This operation is only valid when a GET cluster/restore/status returns a status with value NOT_STARTED. Otherwise, a 409 response is returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.initiate_cluster_restore_start_with_http_info(initiate_cluster_restore_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param InitiateClusterRestoreRequest initiate_cluster_restore_request: (required)
        :return: ClusterRestoreStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['initiate_cluster_restore_request']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method initiate_cluster_restore_start" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'initiate_cluster_restore_request' is set
        if ('initiate_cluster_restore_request' not in params or
                params['initiate_cluster_restore_request'] is None):
            raise ValueError("Missing the required parameter `initiate_cluster_restore_request` when calling `initiate_cluster_restore_start`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'initiate_cluster_restore_request' in params:
            body_params = params['initiate_cluster_restore_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/restore?action=start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterRestoreStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_appliance_management_tasks(self, **kwargs):  # noqa: E501
        """List appliance management tasks  # noqa: E501

        List appliance management tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_appliance_management_tasks(async=True)
        >>> result = thread.get()

        :param async bool
        :param str fields: Fields to include in query results
        :param str request_method: Request method(s) to include in query result
        :param str request_path: Request URI path(s) to include in query result
        :param str request_uri: Request URI(s) to include in query result
        :param str status: Status(es) to include in query result
        :param str user: Names of users to include in query result
        :return: ApplianceManagementTaskListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_appliance_management_tasks_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_appliance_management_tasks_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_appliance_management_tasks_with_http_info(self, **kwargs):  # noqa: E501
        """List appliance management tasks  # noqa: E501

        List appliance management tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_appliance_management_tasks_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str fields: Fields to include in query results
        :param str request_method: Request method(s) to include in query result
        :param str request_path: Request URI path(s) to include in query result
        :param str request_uri: Request URI(s) to include in query result
        :param str status: Status(es) to include in query result
        :param str user: Names of users to include in query result
        :return: ApplianceManagementTaskListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'request_method', 'request_path', 'request_uri', 'status', 'user']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_appliance_management_tasks" % key
                )
            params[key] = val
        del params['kwargs']

        if 'request_method' in params and not re.search('^(=|!=|~|!~)?.+$', params['request_method']):  # noqa: E501
            raise ValueError("Invalid value for parameter `request_method` when calling `list_appliance_management_tasks`, must conform to the pattern `/^(=|!=|~|!~)?.+$/`")  # noqa: E501
        if 'request_path' in params and not re.search('^(=|!=|~|!~)?.+$', params['request_path']):  # noqa: E501
            raise ValueError("Invalid value for parameter `request_path` when calling `list_appliance_management_tasks`, must conform to the pattern `/^(=|!=|~|!~)?.+$/`")  # noqa: E501
        if 'request_uri' in params and not re.search('^(=|!=|~|!~)?.+$', params['request_uri']):  # noqa: E501
            raise ValueError("Invalid value for parameter `request_uri` when calling `list_appliance_management_tasks`, must conform to the pattern `/^(=|!=|~|!~)?.+$/`")  # noqa: E501
        if 'status' in params and not re.search('^(=|!=|~|!~)?.+$', params['status']):  # noqa: E501
            raise ValueError("Invalid value for parameter `status` when calling `list_appliance_management_tasks`, must conform to the pattern `/^(=|!=|~|!~)?.+$/`")  # noqa: E501
        if 'user' in params and not re.search('^(=|!=|~|!~)?.+$', params['user']):  # noqa: E501
            raise ValueError("Invalid value for parameter `user` when calling `list_appliance_management_tasks`, must conform to the pattern `/^(=|!=|~|!~)?.+$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'request_method' in params:
            query_params.append(('request_method', params['request_method']))  # noqa: E501
        if 'request_path' in params:
            query_params.append(('request_path', params['request_path']))  # noqa: E501
        if 'request_uri' in params:
            query_params.append(('request_uri', params['request_uri']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'user' in params:
            query_params.append(('user', params['user']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/tasks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApplianceManagementTaskListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_cluster_backup_timestamps(self, **kwargs):  # noqa: E501
        """List timestamps of all available Cluster Backups.  # noqa: E501

        Returns timestamps for all backup files that are available on the SFTP server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_cluster_backup_timestamps(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ClusterBackupInfoListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_cluster_backup_timestamps_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_cluster_backup_timestamps_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_cluster_backup_timestamps_with_http_info(self, **kwargs):  # noqa: E501
        """List timestamps of all available Cluster Backups.  # noqa: E501

        Returns timestamps for all backup files that are available on the SFTP server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_cluster_backup_timestamps_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ClusterBackupInfoListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_cluster_backup_timestamps" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_cluster_backup_timestamps`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_cluster_backup_timestamps`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/restore/backuptimestamps', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterBackupInfoListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_cluster_node_configs(self, **kwargs):  # noqa: E501
        """List Cluster Node Configurations  # noqa: E501

        Returns information about all NSX cluster nodes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_cluster_node_configs(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ClusterNodeConfigListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_cluster_node_configs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_cluster_node_configs_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_cluster_node_configs_with_http_info(self, **kwargs):  # noqa: E501
        """List Cluster Node Configurations  # noqa: E501

        Returns information about all NSX cluster nodes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_cluster_node_configs_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ClusterNodeConfigListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_cluster_node_configs" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_cluster_node_configs`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_cluster_node_configs`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/nodes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterNodeConfigListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_cluster_node_interfaces(self, node_id, **kwargs):  # noqa: E501
        """List the specified node&#39;s Network Interfaces  # noqa: E501

        Returns the number of interfaces on the node and detailed information about each interface. Interface information includes MTU, broadcast and host IP addresses, link and admin status, MAC address, network mask, and the IP configuration method (static or DHCP).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_cluster_node_interfaces(node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: (required)
        :param str source: Data source type.
        :return: NodeInterfacePropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_cluster_node_interfaces_with_http_info(node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_cluster_node_interfaces_with_http_info(node_id, **kwargs)  # noqa: E501
            return data

    def list_cluster_node_interfaces_with_http_info(self, node_id, **kwargs):  # noqa: E501
        """List the specified node&#39;s Network Interfaces  # noqa: E501

        Returns the number of interfaces on the node and detailed information about each interface. Interface information includes MTU, broadcast and host IP addresses, link and admin status, MAC address, network mask, and the IP configuration method (static or DHCP).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_cluster_node_interfaces_with_http_info(node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: (required)
        :param str source: Data source type.
        :return: NodeInterfacePropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_cluster_node_interfaces" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `list_cluster_node_interfaces`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/nodes/{node-id}/network/interfaces', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeInterfacePropertiesListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_files(self, **kwargs):  # noqa: E501
        """List node files  # noqa: E501

        List node files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_files(async=True)
        >>> result = thread.get()

        :param async bool
        :return: FilePropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_files_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_files_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_files_with_http_info(self, **kwargs):  # noqa: E501
        """List node files  # noqa: E501

        List node files  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_files_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: FilePropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_files" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/file-store', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilePropertiesListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_node_interfaces(self, **kwargs):  # noqa: E501
        """List the NSX Manager&#39;s Network Interfaces  # noqa: E501

        Returns the number of interfaces on the NSX Manager appliance and detailed information about each interface. Interface information includes MTU, broadcast and host IP addresses, link and admin status, MAC address, network mask, and the IP configuration method (static or DHCP).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_node_interfaces(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeNetworkInterfacePropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_node_interfaces_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_node_interfaces_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_node_interfaces_with_http_info(self, **kwargs):  # noqa: E501
        """List the NSX Manager&#39;s Network Interfaces  # noqa: E501

        Returns the number of interfaces on the NSX Manager appliance and detailed information about each interface. Interface information includes MTU, broadcast and host IP addresses, link and admin status, MAC address, network mask, and the IP configuration method (static or DHCP).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_node_interfaces_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeNetworkInterfacePropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_node_interfaces" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/network/interfaces', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeNetworkInterfacePropertiesListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_node_network_routes(self, **kwargs):  # noqa: E501
        """List node network routes  # noqa: E501

        Returns detailed information about each route in the NSX Manager routing table. Route information includes the route type (default, static, and so on), a unique route identifier, the route metric, the protocol from which the route was learned, the route source (which is the preferred egress interface), the route destination, and the route scope. The route scope refers to the distance to the destination network: The \"host\" scope leads to a destination address on the NSX Manager, such as a loopback address; the \"link\" scope leads to a destination on the local network; and the \"global\" scope leads to addresses that are more than one hop away.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_node_network_routes(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeRoutePropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_node_network_routes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_node_network_routes_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_node_network_routes_with_http_info(self, **kwargs):  # noqa: E501
        """List node network routes  # noqa: E501

        Returns detailed information about each route in the NSX Manager routing table. Route information includes the route type (default, static, and so on), a unique route identifier, the route metric, the protocol from which the route was learned, the route source (which is the preferred egress interface), the route destination, and the route scope. The route scope refers to the distance to the destination network: The \"host\" scope leads to a destination address on the NSX Manager, such as a loopback address; the \"link\" scope leads to a destination on the local network; and the \"global\" scope leads to addresses that are more than one hop away.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_node_network_routes_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeRoutePropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_node_network_routes" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/network/routes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeRoutePropertiesListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_node_processes(self, **kwargs):  # noqa: E501
        """List node processes  # noqa: E501

        Returns the number of processes and information about each process. Process information includes 1) mem_resident, which is roughly equivalent to the amount of RAM, in bytes, currently used by the process, 2) parent process ID (ppid), 3) process name, 4) process up time in milliseconds, 5) mem_used, wich is the amount of virtual memory used by the process, in bytes, 6) process start time, in milliseconds since epoch, 7) process ID (pid), 8) CPU time, both user and the system, consumed by the process in milliseconds.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_node_processes(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeProcessPropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_node_processes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_node_processes_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_node_processes_with_http_info(self, **kwargs):  # noqa: E501
        """List node processes  # noqa: E501

        Returns the number of processes and information about each process. Process information includes 1) mem_resident, which is roughly equivalent to the amount of RAM, in bytes, currently used by the process, 2) parent process ID (ppid), 3) process name, 4) process up time in milliseconds, 5) mem_used, wich is the amount of virtual memory used by the process, in bytes, 6) process start time, in milliseconds since epoch, 7) process ID (pid), 8) CPU time, both user and the system, consumed by the process in milliseconds.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_node_processes_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeProcessPropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_node_processes" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/processes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeProcessPropertiesListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_node_services(self, **kwargs):  # noqa: E501
        """List node services  # noqa: E501

        Returns a list of all services available on the NSX Manager applicance.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_node_services(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServicePropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_node_services_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_node_services_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_node_services_with_http_info(self, **kwargs):  # noqa: E501
        """List node services  # noqa: E501

        Returns a list of all services available on the NSX Manager applicance.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_node_services_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServicePropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_node_services" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServicePropertiesListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_node_syslog_exporters(self, **kwargs):  # noqa: E501
        """List node syslog exporters  # noqa: E501

        Returns the collection of registered syslog exporter rules, if any. The rules specify the collector IP address and port, and the protocol to use.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_node_syslog_exporters(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeSyslogExporterPropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_node_syslog_exporters_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_node_syslog_exporters_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_node_syslog_exporters_with_http_info(self, **kwargs):  # noqa: E501
        """List node syslog exporters  # noqa: E501

        Returns the collection of registered syslog exporter rules, if any. The rules specify the collector IP address and port, and the protocol to use.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_node_syslog_exporters_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeSyslogExporterPropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_node_syslog_exporters" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/syslog/exporters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeSyslogExporterPropertiesListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_node_user_ssh_keys(self, userid, **kwargs):  # noqa: E501
        """List SSH keys from authorized_keys file for node user  # noqa: E501

        Returns a list of all SSH keys from authorized_keys file for node user   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_node_user_ssh_keys(userid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str userid: User id of the user (required)
        :return: SshKeyPropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_node_user_ssh_keys_with_http_info(userid, **kwargs)  # noqa: E501
        else:
            (data) = self.list_node_user_ssh_keys_with_http_info(userid, **kwargs)  # noqa: E501
            return data

    def list_node_user_ssh_keys_with_http_info(self, userid, **kwargs):  # noqa: E501
        """List SSH keys from authorized_keys file for node user  # noqa: E501

        Returns a list of all SSH keys from authorized_keys file for node user   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_node_user_ssh_keys_with_http_info(userid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str userid: User id of the user (required)
        :return: SshKeyPropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['userid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_node_user_ssh_keys" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'userid' is set
        if ('userid' not in params or
                params['userid'] is None):
            raise ValueError("Missing the required parameter `userid` when calling `list_node_user_ssh_keys`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'userid' in params:
            path_params['userid'] = params['userid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/users/{userid}/ssh-keys', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SshKeyPropertiesListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_node_users(self, **kwargs):  # noqa: E501
        """List node users  # noqa: E501

        Returns the list of users configued to log in to the NSX Manager appliance.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_node_users(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeUserPropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_node_users_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_node_users_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_node_users_with_http_info(self, **kwargs):  # noqa: E501
        """List node users  # noqa: E501

        Returns the list of users configued to log in to the NSX Manager appliance.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_node_users_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeUserPropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_node_users" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeUserPropertiesListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_restore_instruction_resources(self, instruction_id, **kwargs):  # noqa: E501
        """List resources for a given instruction, to be shown to/executed by users.   # noqa: E501

        For restore operations requiring user input e.g. performing an action, accepting/rejecting an action, etc. the information to be conveyed to users is provided in this call.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_restore_instruction_resources(instruction_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str instruction_id: Id of the instruction set whose instructions are to be returned (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ActionableResourceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_restore_instruction_resources_with_http_info(instruction_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_restore_instruction_resources_with_http_info(instruction_id, **kwargs)  # noqa: E501
            return data

    def list_restore_instruction_resources_with_http_info(self, instruction_id, **kwargs):  # noqa: E501
        """List resources for a given instruction, to be shown to/executed by users.   # noqa: E501

        For restore operations requiring user input e.g. performing an action, accepting/rejecting an action, etc. the information to be conveyed to users is provided in this call.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_restore_instruction_resources_with_http_info(instruction_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str instruction_id: Id of the instruction set whose instructions are to be returned (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: ActionableResourceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['instruction_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_restore_instruction_resources" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'instruction_id' is set
        if ('instruction_id' not in params or
                params['instruction_id'] is None):
            raise ValueError("Missing the required parameter `instruction_id` when calling `list_restore_instruction_resources`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_restore_instruction_resources`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_restore_instruction_resources`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'instruction_id' in params:
            query_params.append(('instruction_id', params['instruction_id']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/restore/instruction-resources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ActionableResourceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_node_syslog_exporter(self, node_syslog_exporter_properties, **kwargs):  # noqa: E501
        """Add node syslog exporter  # noqa: E501

        Adds a rule for exporting syslog information to a specified server. The required parameters are the rule name (exporter_name); severity level (emerg, alert, crit, and so on); transmission protocol (TCP or UDP); and server IP address or hostname. The optional parameters are the syslog port number, which can be 1 through 65,535 (514, by default); facility level to use when logging messages to syslog (kern, user, mail, and so on); and message IDs (msgids), which identify the types of messages to export.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_node_syslog_exporter(node_syslog_exporter_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeSyslogExporterProperties node_syslog_exporter_properties: (required)
        :return: NodeSyslogExporterProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_node_syslog_exporter_with_http_info(node_syslog_exporter_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.post_node_syslog_exporter_with_http_info(node_syslog_exporter_properties, **kwargs)  # noqa: E501
            return data

    def post_node_syslog_exporter_with_http_info(self, node_syslog_exporter_properties, **kwargs):  # noqa: E501
        """Add node syslog exporter  # noqa: E501

        Adds a rule for exporting syslog information to a specified server. The required parameters are the rule name (exporter_name); severity level (emerg, alert, crit, and so on); transmission protocol (TCP or UDP); and server IP address or hostname. The optional parameters are the syslog port number, which can be 1 through 65,535 (514, by default); facility level to use when logging messages to syslog (kern, user, mail, and so on); and message IDs (msgids), which identify the types of messages to export.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_node_syslog_exporter_with_http_info(node_syslog_exporter_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeSyslogExporterProperties node_syslog_exporter_properties: (required)
        :return: NodeSyslogExporterProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_syslog_exporter_properties']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_node_syslog_exporter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_syslog_exporter_properties' is set
        if ('node_syslog_exporter_properties' not in params or
                params['node_syslog_exporter_properties'] is None):
            raise ValueError("Missing the required parameter `node_syslog_exporter_properties` when calling `post_node_syslog_exporter`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'node_syslog_exporter_properties' in params:
            body_params = params['node_syslog_exporter_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/syslog/exporters', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeSyslogExporterProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_cluster_restore_status(self, **kwargs):  # noqa: E501
        """Query Restore Request Status  # noqa: E501

        Returns status information for the specified NSX cluster restore request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.query_cluster_restore_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ClusterRestoreStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.query_cluster_restore_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.query_cluster_restore_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def query_cluster_restore_status_with_http_info(self, **kwargs):  # noqa: E501
        """Query Restore Request Status  # noqa: E501

        Returns status information for the specified NSX cluster restore request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.query_cluster_restore_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ClusterRestoreStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_cluster_restore_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/restore/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterRestoreStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_appliance_management_service(self, **kwargs):  # noqa: E501
        """Read appliance management service properties  # noqa: E501

        Read appliance management service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_appliance_management_service(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_appliance_management_service_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_appliance_management_service_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_appliance_management_service_with_http_info(self, **kwargs):  # noqa: E501
        """Read appliance management service properties  # noqa: E501

        Read appliance management service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_appliance_management_service_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_appliance_management_service" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/node-mgmt', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_appliance_management_service_status(self, **kwargs):  # noqa: E501
        """Read appliance management service status  # noqa: E501

        Read appliance management service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_appliance_management_service_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_appliance_management_service_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_appliance_management_service_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_appliance_management_service_status_with_http_info(self, **kwargs):  # noqa: E501
        """Read appliance management service status  # noqa: E501

        Read appliance management service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_appliance_management_service_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_appliance_management_service_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/node-mgmt/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_appliance_management_task_properties(self, task_id, **kwargs):  # noqa: E501
        """Read task properties  # noqa: E501

        Read task properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_appliance_management_task_properties(task_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str task_id: ID of task to read (required)
        :param bool suppress_redirect: Suppress redirect status if applicable
        :return: ApplianceManagementTaskProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_appliance_management_task_properties_with_http_info(task_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_appliance_management_task_properties_with_http_info(task_id, **kwargs)  # noqa: E501
            return data

    def read_appliance_management_task_properties_with_http_info(self, task_id, **kwargs):  # noqa: E501
        """Read task properties  # noqa: E501

        Read task properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_appliance_management_task_properties_with_http_info(task_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str task_id: ID of task to read (required)
        :param bool suppress_redirect: Suppress redirect status if applicable
        :return: ApplianceManagementTaskProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_id', 'suppress_redirect']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_appliance_management_task_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'task_id' is set
        if ('task_id' not in params or
                params['task_id'] is None):
            raise ValueError("Missing the required parameter `task_id` when calling `read_appliance_management_task_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_id' in params:
            path_params['task-id'] = params['task_id']  # noqa: E501

        query_params = []
        if 'suppress_redirect' in params:
            query_params.append(('suppress_redirect', params['suppress_redirect']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/tasks/{task-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApplianceManagementTaskProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_asnyc_appliance_management_task_response(self, task_id, **kwargs):  # noqa: E501
        """Read asynchronous task response  # noqa: E501

        Read asynchronous task response  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_asnyc_appliance_management_task_response(task_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str task_id: ID of task to read (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_asnyc_appliance_management_task_response_with_http_info(task_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_asnyc_appliance_management_task_response_with_http_info(task_id, **kwargs)  # noqa: E501
            return data

    def read_asnyc_appliance_management_task_response_with_http_info(self, task_id, **kwargs):  # noqa: E501
        """Read asynchronous task response  # noqa: E501

        Read asynchronous task response  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_asnyc_appliance_management_task_response_with_http_info(task_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str task_id: ID of task to read (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_asnyc_appliance_management_task_response" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'task_id' is set
        if ('task_id' not in params or
                params['task_id'] is None):
            raise ValueError("Missing the required parameter `task_id` when calling `read_asnyc_appliance_management_task_response`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_id' in params:
            path_params['task-id'] = params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/tasks/{task-id}/response', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_auth_provider_vidm(self, **kwargs):  # noqa: E501
        """Read AAA provider vIDM properties  # noqa: E501

        Read AAA provider vIDM properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_auth_provider_vidm(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeAuthProviderVidmProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_auth_provider_vidm_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_auth_provider_vidm_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_auth_provider_vidm_with_http_info(self, **kwargs):  # noqa: E501
        """Read AAA provider vIDM properties  # noqa: E501

        Read AAA provider vIDM properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_auth_provider_vidm_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeAuthProviderVidmProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_auth_provider_vidm" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/aaa/providers/vidm', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeAuthProviderVidmProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_auth_provider_vidm_status(self, **kwargs):  # noqa: E501
        """Read AAA provider vIDM status  # noqa: E501

        Read AAA provider vIDM status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_auth_provider_vidm_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeAuthProviderVidmStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_auth_provider_vidm_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_auth_provider_vidm_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_auth_provider_vidm_status_with_http_info(self, **kwargs):  # noqa: E501
        """Read AAA provider vIDM status  # noqa: E501

        Read AAA provider vIDM status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_auth_provider_vidm_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeAuthProviderVidmStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_auth_provider_vidm_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/aaa/providers/vidm/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeAuthProviderVidmStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_cluster_config(self, **kwargs):  # noqa: E501
        """Read Cluster Configuration  # noqa: E501

        Returns information about the NSX cluster configuration. An NSX cluster has two functions or purposes, commonly referred to as \"roles.\" These two roles are control and management. Each NSX installation has a single cluster. Separate NSX clusters do not share data. In other words, a given data-plane node is attached to only one cluster, not to multiple clusters.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_cluster_config(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ClusterConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_cluster_config_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_cluster_config_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_cluster_config_with_http_info(self, **kwargs):  # noqa: E501
        """Read Cluster Configuration  # noqa: E501

        Returns information about the NSX cluster configuration. An NSX cluster has two functions or purposes, commonly referred to as \"roles.\" These two roles are control and management. Each NSX installation has a single cluster. Separate NSX clusters do not share data. In other words, a given data-plane node is attached to only one cluster, not to multiple clusters.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_cluster_config_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ClusterConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_cluster_config" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterConfig',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_cluster_node_config(self, node_id, **kwargs):  # noqa: E501
        """Read Cluster Node Configuration  # noqa: E501

        Returns information about the specified NSX cluster node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_cluster_node_config(node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: (required)
        :return: ClusterNodeConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_cluster_node_config_with_http_info(node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_cluster_node_config_with_http_info(node_id, **kwargs)  # noqa: E501
            return data

    def read_cluster_node_config_with_http_info(self, node_id, **kwargs):  # noqa: E501
        """Read Cluster Node Configuration  # noqa: E501

        Returns information about the specified NSX cluster node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_cluster_node_config_with_http_info(node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: (required)
        :return: ClusterNodeConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_cluster_node_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `read_cluster_node_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/nodes/{node-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterNodeConfig',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_cluster_node_interface(self, node_id, interface_id, **kwargs):  # noqa: E501
        """Read the node&#39;s Network Interface  # noqa: E501

        Returns detailed information about the specified interface. Interface information includes MTU, broadcast and host IP addresses, link and admin status, MAC address, network  mask, and the IP configuration method (static or DHCP).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_cluster_node_interface(node_id, interface_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: (required)
        :param str interface_id: (required)
        :param str source: Data source type.
        :return: NodeInterfaceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_cluster_node_interface_with_http_info(node_id, interface_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_cluster_node_interface_with_http_info(node_id, interface_id, **kwargs)  # noqa: E501
            return data

    def read_cluster_node_interface_with_http_info(self, node_id, interface_id, **kwargs):  # noqa: E501
        """Read the node&#39;s Network Interface  # noqa: E501

        Returns detailed information about the specified interface. Interface information includes MTU, broadcast and host IP addresses, link and admin status, MAC address, network  mask, and the IP configuration method (static or DHCP).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_cluster_node_interface_with_http_info(node_id, interface_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: (required)
        :param str interface_id: (required)
        :param str source: Data source type.
        :return: NodeInterfaceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id', 'interface_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_cluster_node_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `read_cluster_node_interface`")  # noqa: E501
        # verify the required parameter 'interface_id' is set
        if ('interface_id' not in params or
                params['interface_id'] is None):
            raise ValueError("Missing the required parameter `interface_id` when calling `read_cluster_node_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501
        if 'interface_id' in params:
            path_params['interface-id'] = params['interface_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/nodes/{node-id}/network/interfaces/{interface-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeInterfaceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_cluster_node_interface_statistics(self, node_id, interface_id, **kwargs):  # noqa: E501
        """Read the NSX Manager/Controller&#39;s Network Interface Statistics  # noqa: E501

        On the specified interface, returns the number of received (rx), transmitted (tx), and dropped packets; the number of bytes and errors received and transmitted on the interface; and the number of detected collisions.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_cluster_node_interface_statistics(node_id, interface_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: (required)
        :param str interface_id: (required)
        :param str source: Data source type.
        :return: NodeInterfaceStatisticsProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_cluster_node_interface_statistics_with_http_info(node_id, interface_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_cluster_node_interface_statistics_with_http_info(node_id, interface_id, **kwargs)  # noqa: E501
            return data

    def read_cluster_node_interface_statistics_with_http_info(self, node_id, interface_id, **kwargs):  # noqa: E501
        """Read the NSX Manager/Controller&#39;s Network Interface Statistics  # noqa: E501

        On the specified interface, returns the number of received (rx), transmitted (tx), and dropped packets; the number of bytes and errors received and transmitted on the interface; and the number of detected collisions.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_cluster_node_interface_statistics_with_http_info(node_id, interface_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: (required)
        :param str interface_id: (required)
        :param str source: Data source type.
        :return: NodeInterfaceStatisticsProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id', 'interface_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_cluster_node_interface_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `read_cluster_node_interface_statistics`")  # noqa: E501
        # verify the required parameter 'interface_id' is set
        if ('interface_id' not in params or
                params['interface_id'] is None):
            raise ValueError("Missing the required parameter `interface_id` when calling `read_cluster_node_interface_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501
        if 'interface_id' in params:
            path_params['interface-id'] = params['interface_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/nodes/{node-id}/network/interfaces/{interface-id}/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeInterfaceStatisticsProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_cluster_node_status(self, node_id, **kwargs):  # noqa: E501
        """Read Cluster Node Status  # noqa: E501

        Read Cluster Node Status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_cluster_node_status(node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: (required)
        :param str source: Data source type.
        :return: ClusterNodeStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_cluster_node_status_with_http_info(node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_cluster_node_status_with_http_info(node_id, **kwargs)  # noqa: E501
            return data

    def read_cluster_node_status_with_http_info(self, node_id, **kwargs):  # noqa: E501
        """Read Cluster Node Status  # noqa: E501

        Read Cluster Node Status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_cluster_node_status_with_http_info(node_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str node_id: (required)
        :param str source: Data source type.
        :return: ClusterNodeStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_cluster_node_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_id' is set
        if ('node_id' not in params or
                params['node_id'] is None):
            raise ValueError("Missing the required parameter `node_id` when calling `read_cluster_node_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node_id' in params:
            path_params['node-id'] = params['node_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/nodes/{node-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterNodeStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_cluster_nodes_aggregate_status(self, **kwargs):  # noqa: E501
        """Read Cluster Status  # noqa: E501

        Read Cluster Status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_cluster_nodes_aggregate_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ClustersAggregateInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_cluster_nodes_aggregate_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_cluster_nodes_aggregate_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_cluster_nodes_aggregate_status_with_http_info(self, **kwargs):  # noqa: E501
        """Read Cluster Status  # noqa: E501

        Read Cluster Status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_cluster_nodes_aggregate_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ClustersAggregateInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_cluster_nodes_aggregate_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/nodes/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClustersAggregateInfo',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_cluster_status(self, **kwargs):  # noqa: E501
        """Read Cluster Status  # noqa: E501

        Returns status information for the NSX cluster control role and management role.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_cluster_status(async=True)
        >>> result = thread.get()

        :param async bool
        :param str source: Data source type.
        :return: ClusterStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_cluster_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_cluster_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_cluster_status_with_http_info(self, **kwargs):  # noqa: E501
        """Read Cluster Status  # noqa: E501

        Returns status information for the NSX cluster control role and management role.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_cluster_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str source: Data source type.
        :return: ClusterStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_cluster_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_cminventory_service(self, **kwargs):  # noqa: E501
        """Read cm inventory service properties  # noqa: E501

        Read cm inventory service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_cminventory_service(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_cminventory_service_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_cminventory_service_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_cminventory_service_with_http_info(self, **kwargs):  # noqa: E501
        """Read cm inventory service properties  # noqa: E501

        Read cm inventory service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_cminventory_service_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_cminventory_service" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/cm-inventory', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_cminventory_service_status(self, **kwargs):  # noqa: E501
        """Read manager service status  # noqa: E501

        Read manager service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_cminventory_service_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_cminventory_service_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_cminventory_service_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_cminventory_service_status_with_http_info(self, **kwargs):  # noqa: E501
        """Read manager service status  # noqa: E501

        Read manager service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_cminventory_service_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_cminventory_service_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/cm-inventory/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_file(self, file_name, **kwargs):  # noqa: E501
        """Read file contents  # noqa: E501

        Read file contents  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_file(file_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_name: Name of the file to read (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_file_with_http_info(file_name, **kwargs)  # noqa: E501
        else:
            (data) = self.read_file_with_http_info(file_name, **kwargs)  # noqa: E501
            return data

    def read_file_with_http_info(self, file_name, **kwargs):  # noqa: E501
        """Read file contents  # noqa: E501

        Read file contents  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_file_with_http_info(file_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_name: Name of the file to read (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `read_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_name' in params:
            path_params['file-name'] = params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/file-store/{file-name}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_file_properties(self, file_name, **kwargs):  # noqa: E501
        """Read file properties  # noqa: E501

        Read file properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_file_properties(file_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_name: Name of the file to retrieve information about (required)
        :return: FileProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_file_properties_with_http_info(file_name, **kwargs)  # noqa: E501
        else:
            (data) = self.read_file_properties_with_http_info(file_name, **kwargs)  # noqa: E501
            return data

    def read_file_properties_with_http_info(self, file_name, **kwargs):  # noqa: E501
        """Read file properties  # noqa: E501

        Read file properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_file_properties_with_http_info(file_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_name: Name of the file to retrieve information about (required)
        :return: FileProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_file_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `read_file_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_name' in params:
            path_params['file-name'] = params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/file-store/{file-name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_file_thumbprint(self, file_name, **kwargs):  # noqa: E501
        """Read file thumbprint  # noqa: E501

        Read file thumbprint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_file_thumbprint(file_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_name: Name of the file for which thumbprint should be computed (required)
        :return: FileThumbprint
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_file_thumbprint_with_http_info(file_name, **kwargs)  # noqa: E501
        else:
            (data) = self.read_file_thumbprint_with_http_info(file_name, **kwargs)  # noqa: E501
            return data

    def read_file_thumbprint_with_http_info(self, file_name, **kwargs):  # noqa: E501
        """Read file thumbprint  # noqa: E501

        Read file thumbprint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_file_thumbprint_with_http_info(file_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_name: Name of the file for which thumbprint should be computed (required)
        :return: FileThumbprint
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_file_thumbprint" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `read_file_thumbprint`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_name' in params:
            path_params['file-name'] = params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/file-store/{file-name}/thumbprint', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileThumbprint',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_liagent_service(self, **kwargs):  # noqa: E501
        """Read liagent service properties  # noqa: E501

        Read liagent service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_liagent_service(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_liagent_service_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_liagent_service_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_liagent_service_with_http_info(self, **kwargs):  # noqa: E501
        """Read liagent service properties  # noqa: E501

        Read liagent service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_liagent_service_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_liagent_service" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/liagent', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_liagent_service_status(self, **kwargs):  # noqa: E501
        """Read liagent service status  # noqa: E501

        Read liagent service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_liagent_service_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_liagent_service_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_liagent_service_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_liagent_service_status_with_http_info(self, **kwargs):  # noqa: E501
        """Read liagent service status  # noqa: E501

        Read liagent service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_liagent_service_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_liagent_service_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/liagent/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_management_config(self, **kwargs):  # noqa: E501
        """Read NSX Management nodes global configuration.  # noqa: E501

        Returns the NSX Management nodes global configuration.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_management_config(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ManagementConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_management_config_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_management_config_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_management_config_with_http_info(self, **kwargs):  # noqa: E501
        """Read NSX Management nodes global configuration.  # noqa: E501

        Returns the NSX Management nodes global configuration.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_management_config_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ManagementConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_management_config" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/configs/management', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ManagementConfig',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_network_interface_statistics(self, interface_id, **kwargs):  # noqa: E501
        """Read the NSX Manager&#39;s Network Interface Statistics  # noqa: E501

        On the specified interface, returns the number of received (rx), transmitted (tx), and dropped packets; the number of bytes and errors received and transmitted on the interface; and the number of detected collisions.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_network_interface_statistics(interface_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str interface_id: ID of interface to read (required)
        :return: NodeInterfaceStatisticsProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_network_interface_statistics_with_http_info(interface_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_network_interface_statistics_with_http_info(interface_id, **kwargs)  # noqa: E501
            return data

    def read_network_interface_statistics_with_http_info(self, interface_id, **kwargs):  # noqa: E501
        """Read the NSX Manager&#39;s Network Interface Statistics  # noqa: E501

        On the specified interface, returns the number of received (rx), transmitted (tx), and dropped packets; the number of bytes and errors received and transmitted on the interface; and the number of detected collisions.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_network_interface_statistics_with_http_info(interface_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str interface_id: ID of interface to read (required)
        :return: NodeInterfaceStatisticsProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interface_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_network_interface_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'interface_id' is set
        if ('interface_id' not in params or
                params['interface_id'] is None):
            raise ValueError("Missing the required parameter `interface_id` when calling `read_network_interface_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'interface_id' in params:
            path_params['interface-id'] = params['interface_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/network/interfaces/{interface-id}/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeInterfaceStatisticsProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_network_properties(self, **kwargs):  # noqa: E501
        """Read network configuration properties  # noqa: E501

        Read network configuration properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_network_properties(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeNetworkProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_network_properties_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_network_properties_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_network_properties_with_http_info(self, **kwargs):  # noqa: E501
        """Read network configuration properties  # noqa: E501

        Read network configuration properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_network_properties_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeNetworkProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_network_properties" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/network', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeNetworkProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_node_interface(self, interface_id, **kwargs):  # noqa: E501
        """Read the NSX Manager&#39;s Network Interface  # noqa: E501

        Returns detailed information about the specified interface. Interface information includes MTU, broadcast and host IP addresses, link and admin status, MAC address, network  mask, and the IP configuration method.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_interface(interface_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str interface_id: ID of interface to read (required)
        :return: NodeNetworkInterfaceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_node_interface_with_http_info(interface_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_node_interface_with_http_info(interface_id, **kwargs)  # noqa: E501
            return data

    def read_node_interface_with_http_info(self, interface_id, **kwargs):  # noqa: E501
        """Read the NSX Manager&#39;s Network Interface  # noqa: E501

        Returns detailed information about the specified interface. Interface information includes MTU, broadcast and host IP addresses, link and admin status, MAC address, network  mask, and the IP configuration method.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_interface_with_http_info(interface_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str interface_id: ID of interface to read (required)
        :return: NodeNetworkInterfaceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interface_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_node_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'interface_id' is set
        if ('interface_id' not in params or
                params['interface_id'] is None):
            raise ValueError("Missing the required parameter `interface_id` when calling `read_node_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'interface_id' in params:
            path_params['interface-id'] = params['interface_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/network/interfaces/{interface-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeNetworkInterfaceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_node_name_servers(self, **kwargs):  # noqa: E501
        """Read the NSX Manager&#39;s Name Servers  # noqa: E501

        Returns the list of servers that the NSX Manager node uses to look up IP addresses associated with given domain names.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_name_servers(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeNameServersProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_node_name_servers_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_node_name_servers_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_node_name_servers_with_http_info(self, **kwargs):  # noqa: E501
        """Read the NSX Manager&#39;s Name Servers  # noqa: E501

        Returns the list of servers that the NSX Manager node uses to look up IP addresses associated with given domain names.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_name_servers_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeNameServersProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_node_name_servers" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/network/name-servers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeNameServersProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_node_network_route(self, route_id, **kwargs):  # noqa: E501
        """Read node network route  # noqa: E501

        Returns detailed information about a specified route in the NSX Manager routing table.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_network_route(route_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str route_id: ID of route to read (required)
        :return: NodeRouteProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_node_network_route_with_http_info(route_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_node_network_route_with_http_info(route_id, **kwargs)  # noqa: E501
            return data

    def read_node_network_route_with_http_info(self, route_id, **kwargs):  # noqa: E501
        """Read node network route  # noqa: E501

        Returns detailed information about a specified route in the NSX Manager routing table.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_network_route_with_http_info(route_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str route_id: ID of route to read (required)
        :return: NodeRouteProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['route_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_node_network_route" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'route_id' is set
        if ('route_id' not in params or
                params['route_id'] is None):
            raise ValueError("Missing the required parameter `route_id` when calling `read_node_network_route`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'route_id' in params:
            path_params['route-id'] = params['route_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/network/routes/{route-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeRouteProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_node_process(self, process_id, **kwargs):  # noqa: E501
        """Read node process  # noqa: E501

        Returns information for a specified process ID (pid).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_process(process_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str process_id: ID of process to read (required)
        :return: NodeProcessProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_node_process_with_http_info(process_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_node_process_with_http_info(process_id, **kwargs)  # noqa: E501
            return data

    def read_node_process_with_http_info(self, process_id, **kwargs):  # noqa: E501
        """Read node process  # noqa: E501

        Returns information for a specified process ID (pid).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_process_with_http_info(process_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str process_id: ID of process to read (required)
        :return: NodeProcessProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['process_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_node_process" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'process_id' is set
        if ('process_id' not in params or
                params['process_id'] is None):
            raise ValueError("Missing the required parameter `process_id` when calling `read_node_process`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'process_id' in params:
            path_params['process-id'] = params['process_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/processes/{process-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeProcessProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_node_properties(self, **kwargs):  # noqa: E501
        """Read node properties  # noqa: E501

        Returns information about the NSX Manager appliance. Information includes release number, time zone, system time, kernel version, message of the day (motd), and host name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_properties(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_node_properties_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_node_properties_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_node_properties_with_http_info(self, **kwargs):  # noqa: E501
        """Read node properties  # noqa: E501

        Returns information about the NSX Manager appliance. Information includes release number, time zone, system time, kernel version, message of the day (motd), and host name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_properties_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_node_properties" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_node_search_domains(self, **kwargs):  # noqa: E501
        """Read the NSX Manager&#39;s Search Domains  # noqa: E501

        Returns the domain list that the NSX Manager node uses to complete unqualified host names. When a host name does not include a fully qualified domain name (FQDN), the NSX Management node appends the first-listed domain name to the host name before the host name is looked up. The NSX Management node continues this for each entry in the domain list until it finds a match.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_search_domains(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeSearchDomainsProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_node_search_domains_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_node_search_domains_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_node_search_domains_with_http_info(self, **kwargs):  # noqa: E501
        """Read the NSX Manager&#39;s Search Domains  # noqa: E501

        Returns the domain list that the NSX Manager node uses to complete unqualified host names. When a host name does not include a fully qualified domain name (FQDN), the NSX Management node appends the first-listed domain name to the host name before the host name is looked up. The NSX Management node continues this for each entry in the domain list until it finds a match.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_search_domains_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeSearchDomainsProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_node_search_domains" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/network/search-domains', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeSearchDomainsProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_node_support_bundle(self, **kwargs):  # noqa: E501
        """Read node support bundle  # noqa: E501

        Read node support bundle  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_support_bundle(async=True)
        >>> result = thread.get()

        :param async bool
        :param bool all: Include all files
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_node_support_bundle_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_node_support_bundle_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_node_support_bundle_with_http_info(self, **kwargs):  # noqa: E501
        """Read node support bundle  # noqa: E501

        Read node support bundle  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_support_bundle_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param bool all: Include all files
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['all']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_node_support_bundle" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all' in params:
            query_params.append(('all', params['all']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/support-bundle', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_node_syslog_exporter(self, exporter_name, **kwargs):  # noqa: E501
        """Read node syslog exporter  # noqa: E501

        Returns information about a specific syslog collection point.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_syslog_exporter(exporter_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str exporter_name: Name of syslog exporter (required)
        :return: NodeSyslogExporterProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_node_syslog_exporter_with_http_info(exporter_name, **kwargs)  # noqa: E501
        else:
            (data) = self.read_node_syslog_exporter_with_http_info(exporter_name, **kwargs)  # noqa: E501
            return data

    def read_node_syslog_exporter_with_http_info(self, exporter_name, **kwargs):  # noqa: E501
        """Read node syslog exporter  # noqa: E501

        Returns information about a specific syslog collection point.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_syslog_exporter_with_http_info(exporter_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str exporter_name: Name of syslog exporter (required)
        :return: NodeSyslogExporterProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['exporter_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_node_syslog_exporter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'exporter_name' is set
        if ('exporter_name' not in params or
                params['exporter_name'] is None):
            raise ValueError("Missing the required parameter `exporter_name` when calling `read_node_syslog_exporter`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'exporter_name' in params:
            path_params['exporter-name'] = params['exporter_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/syslog/exporters/{exporter-name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeSyslogExporterProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_node_user(self, userid, **kwargs):  # noqa: E501
        """Read node user  # noqa: E501

        Returns information about a specified user who is configued to log in to the NSX Manager appliance   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_user(userid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str userid: User id of the user (required)
        :return: NodeUserProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_node_user_with_http_info(userid, **kwargs)  # noqa: E501
        else:
            (data) = self.read_node_user_with_http_info(userid, **kwargs)  # noqa: E501
            return data

    def read_node_user_with_http_info(self, userid, **kwargs):  # noqa: E501
        """Read node user  # noqa: E501

        Returns information about a specified user who is configued to log in to the NSX Manager appliance   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_node_user_with_http_info(userid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str userid: User id of the user (required)
        :return: NodeUserProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['userid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_node_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'userid' is set
        if ('userid' not in params or
                params['userid'] is None):
            raise ValueError("Missing the required parameter `userid` when calling `read_node_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'userid' in params:
            path_params['userid'] = params['userid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/users/{userid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeUserProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_nsx_message_bus_service(self, **kwargs):  # noqa: E501
        """Read NSX Message Bus service properties  # noqa: E501

        Read NSX Message Bus service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_nsx_message_bus_service(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_nsx_message_bus_service_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_nsx_message_bus_service_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_nsx_message_bus_service_with_http_info(self, **kwargs):  # noqa: E501
        """Read NSX Message Bus service properties  # noqa: E501

        Read NSX Message Bus service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_nsx_message_bus_service_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_nsx_message_bus_service" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/nsx-message-bus', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_nsx_message_bus_service_status(self, **kwargs):  # noqa: E501
        """Read NSX Message Bus service status  # noqa: E501

        Read NSX Message Bus service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_nsx_message_bus_service_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_nsx_message_bus_service_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_nsx_message_bus_service_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_nsx_message_bus_service_status_with_http_info(self, **kwargs):  # noqa: E501
        """Read NSX Message Bus service status  # noqa: E501

        Read NSX Message Bus service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_nsx_message_bus_service_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_nsx_message_bus_service_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/nsx-message-bus/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_nsx_upgrade_agent_service(self, **kwargs):  # noqa: E501
        """Read NSX upgrade Agent service properties  # noqa: E501

        Read NSX upgrade Agent service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_nsx_upgrade_agent_service(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_nsx_upgrade_agent_service_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_nsx_upgrade_agent_service_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_nsx_upgrade_agent_service_with_http_info(self, **kwargs):  # noqa: E501
        """Read NSX upgrade Agent service properties  # noqa: E501

        Read NSX upgrade Agent service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_nsx_upgrade_agent_service_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_nsx_upgrade_agent_service" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/nsx-upgrade-agent', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_nsx_upgrade_agent_service_status(self, **kwargs):  # noqa: E501
        """Read Nsx upgrade agent service status  # noqa: E501

        Read Nsx upgrade agent service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_nsx_upgrade_agent_service_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_nsx_upgrade_agent_service_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_nsx_upgrade_agent_service_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_nsx_upgrade_agent_service_status_with_http_info(self, **kwargs):  # noqa: E501
        """Read Nsx upgrade agent service status  # noqa: E501

        Read Nsx upgrade agent service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_nsx_upgrade_agent_service_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_nsx_upgrade_agent_service_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/nsx-upgrade-agent/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_ntp_service(self, **kwargs):  # noqa: E501
        """Read NTP service properties  # noqa: E501

        Read NTP service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ntp_service(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeNtpServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_ntp_service_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_ntp_service_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_ntp_service_with_http_info(self, **kwargs):  # noqa: E501
        """Read NTP service properties  # noqa: E501

        Read NTP service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ntp_service_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeNtpServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_ntp_service" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/ntp', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeNtpServiceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_ntp_service_status(self, **kwargs):  # noqa: E501
        """Read NTP service status  # noqa: E501

        Read NTP service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ntp_service_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_ntp_service_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_ntp_service_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_ntp_service_status_with_http_info(self, **kwargs):  # noqa: E501
        """Read NTP service status  # noqa: E501

        Read NTP service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ntp_service_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_ntp_service_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/ntp/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_proton_service(self, **kwargs):  # noqa: E501
        """Read service properties  # noqa: E501

        Read service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_proton_service(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeProtonServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_proton_service_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_proton_service_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_proton_service_with_http_info(self, **kwargs):  # noqa: E501
        """Read service properties  # noqa: E501

        Read service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_proton_service_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeProtonServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_proton_service" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/manager', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeProtonServiceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_proton_service_status(self, **kwargs):  # noqa: E501
        """Read service status  # noqa: E501

        Read service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_proton_service_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_proton_service_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_proton_service_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_proton_service_status_with_http_info(self, **kwargs):  # noqa: E501
        """Read service status  # noqa: E501

        Read service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_proton_service_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_proton_service_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/manager/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_proxy_service(self, **kwargs):  # noqa: E501
        """Read http service properties  # noqa: E501

        Read http service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_proxy_service(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeHttpServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_proxy_service_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_proxy_service_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_proxy_service_with_http_info(self, **kwargs):  # noqa: E501
        """Read http service properties  # noqa: E501

        Read http service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_proxy_service_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeHttpServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_proxy_service" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/http', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeHttpServiceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_proxy_service_status(self, **kwargs):  # noqa: E501
        """Read http service status  # noqa: E501

        Read http service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_proxy_service_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_proxy_service_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_proxy_service_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_proxy_service_status_with_http_info(self, **kwargs):  # noqa: E501
        """Read http service status  # noqa: E501

        Read http service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_proxy_service_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_proxy_service_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/http/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_rabbit_mq_service(self, **kwargs):  # noqa: E501
        """Read Rabbit MQ service properties  # noqa: E501

        Read Rabbit MQ service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_rabbit_mq_service(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_rabbit_mq_service_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_rabbit_mq_service_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_rabbit_mq_service_with_http_info(self, **kwargs):  # noqa: E501
        """Read Rabbit MQ service properties  # noqa: E501

        Read Rabbit MQ service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_rabbit_mq_service_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_rabbit_mq_service" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/mgmt-plane-bus', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_rabbit_mq_service_status(self, **kwargs):  # noqa: E501
        """Read Rabbit MQ service status  # noqa: E501

        Read Rabbit MQ service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_rabbit_mq_service_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_rabbit_mq_service_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_rabbit_mq_service_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_rabbit_mq_service_status_with_http_info(self, **kwargs):  # noqa: E501
        """Read Rabbit MQ service status  # noqa: E501

        Read Rabbit MQ service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_rabbit_mq_service_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_rabbit_mq_service_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/mgmt-plane-bus/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_repository_service(self, **kwargs):  # noqa: E501
        """Read NSX install-upgrade service properties  # noqa: E501

        Read NSX install-upgrade service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_repository_service(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeInstallUpgradeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_repository_service_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_repository_service_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_repository_service_with_http_info(self, **kwargs):  # noqa: E501
        """Read NSX install-upgrade service properties  # noqa: E501

        Read NSX install-upgrade service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_repository_service_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeInstallUpgradeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_repository_service" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/install-upgrade', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeInstallUpgradeServiceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_repository_service_status(self, **kwargs):  # noqa: E501
        """Read NSX install-upgrade service status  # noqa: E501

        Read NSX install-upgrade service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_repository_service_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_repository_service_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_repository_service_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_repository_service_status_with_http_info(self, **kwargs):  # noqa: E501
        """Read NSX install-upgrade service status  # noqa: E501

        Read NSX install-upgrade service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_repository_service_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_repository_service_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/install-upgrade/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_search_service(self, **kwargs):  # noqa: E501
        """Read NSX Search service properties  # noqa: E501

        Read NSX Search service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_search_service(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_search_service_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_search_service_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_search_service_with_http_info(self, **kwargs):  # noqa: E501
        """Read NSX Search service properties  # noqa: E501

        Read NSX Search service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_search_service_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_search_service" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_search_service_status(self, **kwargs):  # noqa: E501
        """Read NSX Search service status  # noqa: E501

        Read NSX Search service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_search_service_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_search_service_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_search_service_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_search_service_status_with_http_info(self, **kwargs):  # noqa: E501
        """Read NSX Search service status  # noqa: E501

        Read NSX Search service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_search_service_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_search_service_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/search/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_snmp_service(self, **kwargs):  # noqa: E501
        """Read SNMP service properties  # noqa: E501

        Read SNMP service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_snmp_service(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_snmp_service_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_snmp_service_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_snmp_service_with_http_info(self, **kwargs):  # noqa: E501
        """Read SNMP service properties  # noqa: E501

        Read SNMP service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_snmp_service_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_snmp_service" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/snmp', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_snmp_service_status(self, **kwargs):  # noqa: E501
        """Read SNMP service status  # noqa: E501

        Read SNMP service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_snmp_service_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_snmp_service_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_snmp_service_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_snmp_service_status_with_http_info(self, **kwargs):  # noqa: E501
        """Read SNMP service status  # noqa: E501

        Read SNMP service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_snmp_service_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_snmp_service_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/snmp/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_ssh_service(self, **kwargs):  # noqa: E501
        """Read ssh service properties  # noqa: E501

        Read ssh service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ssh_service(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeSshServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_ssh_service_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_ssh_service_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_ssh_service_with_http_info(self, **kwargs):  # noqa: E501
        """Read ssh service properties  # noqa: E501

        Read ssh service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ssh_service_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeSshServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_ssh_service" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/ssh', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeSshServiceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_ssh_service_status(self, **kwargs):  # noqa: E501
        """Read ssh service status  # noqa: E501

        Read ssh service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ssh_service_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_ssh_service_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_ssh_service_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_ssh_service_status_with_http_info(self, **kwargs):  # noqa: E501
        """Read ssh service status  # noqa: E501

        Read ssh service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_ssh_service_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_ssh_service_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/ssh/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_syslog_service(self, **kwargs):  # noqa: E501
        """Read syslog service properties  # noqa: E501

        Read syslog service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_syslog_service(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_syslog_service_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_syslog_service_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_syslog_service_with_http_info(self, **kwargs):  # noqa: E501
        """Read syslog service properties  # noqa: E501

        Read syslog service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_syslog_service_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_syslog_service" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/syslog', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_syslog_service_status(self, **kwargs):  # noqa: E501
        """Read syslog service status  # noqa: E501

        Read syslog service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_syslog_service_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_syslog_service_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.read_syslog_service_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def read_syslog_service_status_with_http_info(self, **kwargs):  # noqa: E501
        """Read syslog service status  # noqa: E501

        Read syslog service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_syslog_service_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NodeServiceStatusProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_syslog_service_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/syslog/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeServiceStatusProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def register_principal_identity(self, principal_identity, **kwargs):  # noqa: E501
        """Register a name-certificate combination.  # noqa: E501

        Associates a principal's name with a certificate that is used to authenticate.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.register_principal_identity(principal_identity, async=True)
        >>> result = thread.get()

        :param async bool
        :param PrincipalIdentity principal_identity: (required)
        :return: PrincipalIdentity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.register_principal_identity_with_http_info(principal_identity, **kwargs)  # noqa: E501
        else:
            (data) = self.register_principal_identity_with_http_info(principal_identity, **kwargs)  # noqa: E501
            return data

    def register_principal_identity_with_http_info(self, principal_identity, **kwargs):  # noqa: E501
        """Register a name-certificate combination.  # noqa: E501

        Associates a principal's name with a certificate that is used to authenticate.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.register_principal_identity_with_http_info(principal_identity, async=True)
        >>> result = thread.get()

        :param async bool
        :param PrincipalIdentity principal_identity: (required)
        :return: PrincipalIdentity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['principal_identity']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register_principal_identity" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'principal_identity' is set
        if ('principal_identity' not in params or
                params['principal_identity'] is None):
            raise ValueError("Missing the required parameter `principal_identity` when calling `register_principal_identity`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'principal_identity' in params:
            body_params = params['principal_identity']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/principal-identities', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrincipalIdentity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def request_onetime_backup_backup_to_remote(self, **kwargs):  # noqa: E501
        """Request one-time backup  # noqa: E501

        Request one-time backup. The backup will be uploaded using the same server configuration as for automatic backup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.request_onetime_backup_backup_to_remote(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.request_onetime_backup_backup_to_remote_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.request_onetime_backup_backup_to_remote_with_http_info(**kwargs)  # noqa: E501
            return data

    def request_onetime_backup_backup_to_remote_with_http_info(self, **kwargs):  # noqa: E501
        """Request one-time backup  # noqa: E501

        Request one-time backup. The backup will be uploaded using the same server configuration as for automatic backup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.request_onetime_backup_backup_to_remote_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method request_onetime_backup_backup_to_remote" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster?action=backup_to_remote', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def request_onetime_inventory_summary_summarize_inventory_to_remote(self, **kwargs):  # noqa: E501
        """Request one-time inventory summary.  # noqa: E501

        Request one-time inventory summary. The backup will be uploaded using the same server configuration as for an automatic backup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.request_onetime_inventory_summary_summarize_inventory_to_remote(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.request_onetime_inventory_summary_summarize_inventory_to_remote_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.request_onetime_inventory_summary_summarize_inventory_to_remote_with_http_info(**kwargs)  # noqa: E501
            return data

    def request_onetime_inventory_summary_summarize_inventory_to_remote_with_http_info(self, **kwargs):  # noqa: E501
        """Request one-time inventory summary.  # noqa: E501

        Request one-time inventory summary. The backup will be uploaded using the same server configuration as for an automatic backup.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.request_onetime_inventory_summary_summarize_inventory_to_remote_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method request_onetime_inventory_summary_summarize_inventory_to_remote" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster?action=summarize_inventory_to_remote', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reset_proton_service_logging_level_action_reset_manager_logging_levels(self, **kwargs):  # noqa: E501
        """Reset the logging levels to default values  # noqa: E501

        Reset the logging levels to default values  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.reset_proton_service_logging_level_action_reset_manager_logging_levels(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.reset_proton_service_logging_level_action_reset_manager_logging_levels_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.reset_proton_service_logging_level_action_reset_manager_logging_levels_with_http_info(**kwargs)  # noqa: E501
            return data

    def reset_proton_service_logging_level_action_reset_manager_logging_levels_with_http_info(self, **kwargs):  # noqa: E501
        """Reset the logging levels to default values  # noqa: E501

        Reset the logging levels to default values  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.reset_proton_service_logging_level_action_reset_manager_logging_levels_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_proton_service_logging_level_action_reset_manager_logging_levels" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/manager?action=reset-manager-logging-levels', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def restart_or_shutdown_node_restart(self, **kwargs):  # noqa: E501
        """Restart or shutdown node  # noqa: E501

        Restarts or shuts down the NSX Manager appliance.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.restart_or_shutdown_node_restart(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.restart_or_shutdown_node_restart_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.restart_or_shutdown_node_restart_with_http_info(**kwargs)  # noqa: E501
            return data

    def restart_or_shutdown_node_restart_with_http_info(self, **kwargs):  # noqa: E501
        """Restart or shutdown node  # noqa: E501

        Restarts or shuts down the NSX Manager appliance.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.restart_or_shutdown_node_restart_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method restart_or_shutdown_node_restart" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node?action=restart', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def restart_or_shutdown_node_shutdown(self, **kwargs):  # noqa: E501
        """Restart or shutdown node  # noqa: E501

        Restarts or shuts down the NSX Manager appliance.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.restart_or_shutdown_node_shutdown(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.restart_or_shutdown_node_shutdown_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.restart_or_shutdown_node_shutdown_with_http_info(**kwargs)  # noqa: E501
            return data

    def restart_or_shutdown_node_shutdown_with_http_info(self, **kwargs):  # noqa: E501
        """Restart or shutdown node  # noqa: E501

        Restarts or shuts down the NSX Manager appliance.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.restart_or_shutdown_node_shutdown_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method restart_or_shutdown_node_shutdown" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node?action=shutdown', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retry_cluster_restore_retry(self, **kwargs):  # noqa: E501
        """Retry any failed restore operation  # noqa: E501

        Retry any currently in-progress, failed restore operation. Only the last step of the multi-step restore operation would have failed,and only that step is retried. This operation is only valid when a GET cluster/restore/status returns a status with value FAILED. Otherwise, a 409 response is returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.retry_cluster_restore_retry(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ClusterRestoreStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.retry_cluster_restore_retry_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.retry_cluster_restore_retry_with_http_info(**kwargs)  # noqa: E501
            return data

    def retry_cluster_restore_retry_with_http_info(self, **kwargs):  # noqa: E501
        """Retry any failed restore operation  # noqa: E501

        Retry any currently in-progress, failed restore operation. Only the last step of the multi-step restore operation would have failed,and only that step is retried. This operation is only valid when a GET cluster/restore/status returns a status with value FAILED. Otherwise, a 409 response is returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.retry_cluster_restore_retry_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ClusterRestoreStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retry_cluster_restore_retry" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/restore?action=retry', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterRestoreStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revoke_missing_cluster_node_config_revoke_missing_nodes(self, revoke_node_request, **kwargs):  # noqa: E501
        """Revoke Missing Nodes from the Cluster  # noqa: E501

        Revoke Missing Nodes from the Cluster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.revoke_missing_cluster_node_config_revoke_missing_nodes(revoke_node_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param RevokeNodeRequest revoke_node_request: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.revoke_missing_cluster_node_config_revoke_missing_nodes_with_http_info(revoke_node_request, **kwargs)  # noqa: E501
        else:
            (data) = self.revoke_missing_cluster_node_config_revoke_missing_nodes_with_http_info(revoke_node_request, **kwargs)  # noqa: E501
            return data

    def revoke_missing_cluster_node_config_revoke_missing_nodes_with_http_info(self, revoke_node_request, **kwargs):  # noqa: E501
        """Revoke Missing Nodes from the Cluster  # noqa: E501

        Revoke Missing Nodes from the Cluster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.revoke_missing_cluster_node_config_revoke_missing_nodes_with_http_info(revoke_node_request, async=True)
        >>> result = thread.get()

        :param async bool
        :param RevokeNodeRequest revoke_node_request: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['revoke_node_request']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revoke_missing_cluster_node_config_revoke_missing_nodes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'revoke_node_request' is set
        if ('revoke_node_request' not in params or
                params['revoke_node_request'] is None):
            raise ValueError("Missing the required parameter `revoke_node_request` when calling `revoke_missing_cluster_node_config_revoke_missing_nodes`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'revoke_node_request' in params:
            body_params = params['revoke_node_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/nodes?action=revoke_missing_nodes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def self_sign_certificate_self_sign(self, csr_id, days_valid, **kwargs):  # noqa: E501
        """Self-Sign the CSR  # noqa: E501

        Self-signs the previously generated CSR. This action is similar to the import certificate action, but instead of using a public certificate signed by a CA, the self_sign POST action uses a certificate that is signed with NSX's own private key.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.self_sign_certificate_self_sign(csr_id, days_valid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str csr_id: CSR this certificate is associated with (required)
        :param int days_valid: Number of days the certificate will be valid, default 10 years (required)
        :return: Certificate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.self_sign_certificate_self_sign_with_http_info(csr_id, days_valid, **kwargs)  # noqa: E501
        else:
            (data) = self.self_sign_certificate_self_sign_with_http_info(csr_id, days_valid, **kwargs)  # noqa: E501
            return data

    def self_sign_certificate_self_sign_with_http_info(self, csr_id, days_valid, **kwargs):  # noqa: E501
        """Self-Sign the CSR  # noqa: E501

        Self-signs the previously generated CSR. This action is similar to the import certificate action, but instead of using a public certificate signed by a CA, the self_sign POST action uses a certificate that is signed with NSX's own private key.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.self_sign_certificate_self_sign_with_http_info(csr_id, days_valid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str csr_id: CSR this certificate is associated with (required)
        :param int days_valid: Number of days the certificate will be valid, default 10 years (required)
        :return: Certificate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['csr_id', 'days_valid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method self_sign_certificate_self_sign" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'csr_id' is set
        if ('csr_id' not in params or
                params['csr_id'] is None):
            raise ValueError("Missing the required parameter `csr_id` when calling `self_sign_certificate_self_sign`")  # noqa: E501
        # verify the required parameter 'days_valid' is set
        if ('days_valid' not in params or
                params['days_valid'] is None):
            raise ValueError("Missing the required parameter `days_valid` when calling `self_sign_certificate_self_sign`")  # noqa: E501

        if 'days_valid' in params and params['days_valid'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `days_valid` when calling `self_sign_certificate_self_sign`, must be a value less than or equal to `10000`")  # noqa: E501
        if 'days_valid' in params and params['days_valid'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `days_valid` when calling `self_sign_certificate_self_sign`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'csr_id' in params:
            path_params['csr-id'] = params['csr_id']  # noqa: E501

        query_params = []
        if 'days_valid' in params:
            query_params.append(('days_valid', params['days_valid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/csrs/{csr-id}?action=self_sign', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Certificate',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_node_mandatory_access_control(self, mandatory_access_control_properties, **kwargs):  # noqa: E501
        """Enable or disable  Mandatory Access Control  # noqa: E501

        Enable or disable  Mandatory Access Control  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_node_mandatory_access_control(mandatory_access_control_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param MandatoryAccessControlProperties mandatory_access_control_properties: (required)
        :return: MandatoryAccessControlProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.set_node_mandatory_access_control_with_http_info(mandatory_access_control_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.set_node_mandatory_access_control_with_http_info(mandatory_access_control_properties, **kwargs)  # noqa: E501
            return data

    def set_node_mandatory_access_control_with_http_info(self, mandatory_access_control_properties, **kwargs):  # noqa: E501
        """Enable or disable  Mandatory Access Control  # noqa: E501

        Enable or disable  Mandatory Access Control  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_node_mandatory_access_control_with_http_info(mandatory_access_control_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param MandatoryAccessControlProperties mandatory_access_control_properties: (required)
        :return: MandatoryAccessControlProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mandatory_access_control_properties']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_node_mandatory_access_control" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mandatory_access_control_properties' is set
        if ('mandatory_access_control_properties' not in params or
                params['mandatory_access_control_properties'] is None):
            raise ValueError("Missing the required parameter `mandatory_access_control_properties` when calling `set_node_mandatory_access_control`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'mandatory_access_control_properties' in params:
            body_params = params['mandatory_access_control_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/hardening-policy/mandatory-access-control', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MandatoryAccessControlProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_rabbit_mq_management_port(self, **kwargs):  # noqa: E501
        """Set RabbitMQ management port  # noqa: E501

        Set RabbitMQ management port  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_rabbit_mq_management_port(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.set_rabbit_mq_management_port_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.set_rabbit_mq_management_port_with_http_info(**kwargs)  # noqa: E501
            return data

    def set_rabbit_mq_management_port_with_http_info(self, **kwargs):  # noqa: E501
        """Set RabbitMQ management port  # noqa: E501

        Set RabbitMQ management port  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_rabbit_mq_management_port_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_rabbit_mq_management_port" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/rabbitmq-management-port', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def suspend_cluster_restore_suspend(self, **kwargs):  # noqa: E501
        """Suspend any running restore operation  # noqa: E501

        Suspend any currently running restore operation. The restore operation is made up of a number of steps. When this call is issued, any currently running step is allowed to finish (successfully or with errors), and the next step (and therefore the entire restore operation) is suspended until a subsequent resume or cancel call is issued. This operation is only valid when a GET cluster/restore/status returns a status with value RUNNING. Otherwise, a 409 response is returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.suspend_cluster_restore_suspend(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ClusterRestoreStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.suspend_cluster_restore_suspend_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.suspend_cluster_restore_suspend_with_http_info(**kwargs)  # noqa: E501
            return data

    def suspend_cluster_restore_suspend_with_http_info(self, **kwargs):  # noqa: E501
        """Suspend any running restore operation  # noqa: E501

        Suspend any currently running restore operation. The restore operation is made up of a number of steps. When this call is issued, any currently running step is allowed to finish (successfully or with errors), and the next step (and therefore the entire restore operation) is suspended until a subsequent resume or cancel call is issued. This operation is only valid when a GET cluster/restore/status returns a status with value RUNNING. Otherwise, a 409 response is returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.suspend_cluster_restore_suspend_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ClusterRestoreStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method suspend_cluster_restore_suspend" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/cluster/restore?action=suspend', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterRestoreStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_auth_provider_vidm(self, node_auth_provider_vidm_properties, **kwargs):  # noqa: E501
        """Update AAA provider vIDM properties  # noqa: E501

        Update AAA provider vIDM properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_auth_provider_vidm(node_auth_provider_vidm_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeAuthProviderVidmProperties node_auth_provider_vidm_properties: (required)
        :return: NodeAuthProviderVidmProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_auth_provider_vidm_with_http_info(node_auth_provider_vidm_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.update_auth_provider_vidm_with_http_info(node_auth_provider_vidm_properties, **kwargs)  # noqa: E501
            return data

    def update_auth_provider_vidm_with_http_info(self, node_auth_provider_vidm_properties, **kwargs):  # noqa: E501
        """Update AAA provider vIDM properties  # noqa: E501

        Update AAA provider vIDM properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_auth_provider_vidm_with_http_info(node_auth_provider_vidm_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeAuthProviderVidmProperties node_auth_provider_vidm_properties: (required)
        :return: NodeAuthProviderVidmProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_auth_provider_vidm_properties']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_auth_provider_vidm" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_auth_provider_vidm_properties' is set
        if ('node_auth_provider_vidm_properties' not in params or
                params['node_auth_provider_vidm_properties'] is None):
            raise ValueError("Missing the required parameter `node_auth_provider_vidm_properties` when calling `update_auth_provider_vidm`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'node_auth_provider_vidm_properties' in params:
            body_params = params['node_auth_provider_vidm_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/aaa/providers/vidm', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeAuthProviderVidmProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_crl(self, crl_id, crl, **kwargs):  # noqa: E501
        """Update CRL for the Given CRL ID  # noqa: E501

        Updates an existing CRL.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_crl(crl_id, crl, async=True)
        >>> result = thread.get()

        :param async bool
        :param str crl_id: ID of CRL to update (required)
        :param Crl crl: (required)
        :return: Crl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_crl_with_http_info(crl_id, crl, **kwargs)  # noqa: E501
        else:
            (data) = self.update_crl_with_http_info(crl_id, crl, **kwargs)  # noqa: E501
            return data

    def update_crl_with_http_info(self, crl_id, crl, **kwargs):  # noqa: E501
        """Update CRL for the Given CRL ID  # noqa: E501

        Updates an existing CRL.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_crl_with_http_info(crl_id, crl, async=True)
        >>> result = thread.get()

        :param async bool
        :param str crl_id: ID of CRL to update (required)
        :param Crl crl: (required)
        :return: Crl
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['crl_id', 'crl']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_crl" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'crl_id' is set
        if ('crl_id' not in params or
                params['crl_id'] is None):
            raise ValueError("Missing the required parameter `crl_id` when calling `update_crl`")  # noqa: E501
        # verify the required parameter 'crl' is set
        if ('crl' not in params or
                params['crl'] is None):
            raise ValueError("Missing the required parameter `crl` when calling `update_crl`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'crl_id' in params:
            path_params['crl-id'] = params['crl_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'crl' in params:
            body_params = params['crl']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/trust-management/crls/{crl-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Crl',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_file(self, file_name, **kwargs):  # noqa: E501
        """Replace file contents  # noqa: E501

        Replace file contents  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_file(file_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_name: Name of the file to replace (required)
        :return: FileProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_file_with_http_info(file_name, **kwargs)  # noqa: E501
        else:
            (data) = self.update_file_with_http_info(file_name, **kwargs)  # noqa: E501
            return data

    def update_file_with_http_info(self, file_name, **kwargs):  # noqa: E501
        """Replace file contents  # noqa: E501

        Replace file contents  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_file_with_http_info(file_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_name: Name of the file to replace (required)
        :return: FileProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `update_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_name' in params:
            path_params['file-name'] = params['file_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/file-store/{file-name}/data', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_management_config(self, management_config, **kwargs):  # noqa: E501
        """Update NSX Management nodes global configuration  # noqa: E501

        Modifies the NSX Management nodes global configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_management_config(management_config, async=True)
        >>> result = thread.get()

        :param async bool
        :param ManagementConfig management_config: (required)
        :return: ManagementConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_management_config_with_http_info(management_config, **kwargs)  # noqa: E501
        else:
            (data) = self.update_management_config_with_http_info(management_config, **kwargs)  # noqa: E501
            return data

    def update_management_config_with_http_info(self, management_config, **kwargs):  # noqa: E501
        """Update NSX Management nodes global configuration  # noqa: E501

        Modifies the NSX Management nodes global configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_management_config_with_http_info(management_config, async=True)
        >>> result = thread.get()

        :param async bool
        :param ManagementConfig management_config: (required)
        :return: ManagementConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['management_config']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_management_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'management_config' is set
        if ('management_config' not in params or
                params['management_config'] is None):
            raise ValueError("Missing the required parameter `management_config` when calling `update_management_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'management_config' in params:
            body_params = params['management_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/configs/management', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ManagementConfig',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_node_interface(self, interface_id, node_network_interface_properties, **kwargs):  # noqa: E501
        """Update the NSX Manager&#39;s Network Interface  # noqa: E501

        Updates the specified interface properties. You cannot change the properties <code>ip_configuration</code>, <code>ip_addresses</code>, or <code>plane</code>. NSX Manager must have a static IP address. You must use NSX CLI to configure a controller or an edge node.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_node_interface(interface_id, node_network_interface_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param str interface_id: ID of interface to update (required)
        :param NodeNetworkInterfaceProperties node_network_interface_properties: (required)
        :return: NodeNetworkInterfaceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_node_interface_with_http_info(interface_id, node_network_interface_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.update_node_interface_with_http_info(interface_id, node_network_interface_properties, **kwargs)  # noqa: E501
            return data

    def update_node_interface_with_http_info(self, interface_id, node_network_interface_properties, **kwargs):  # noqa: E501
        """Update the NSX Manager&#39;s Network Interface  # noqa: E501

        Updates the specified interface properties. You cannot change the properties <code>ip_configuration</code>, <code>ip_addresses</code>, or <code>plane</code>. NSX Manager must have a static IP address. You must use NSX CLI to configure a controller or an edge node.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_node_interface_with_http_info(interface_id, node_network_interface_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param str interface_id: ID of interface to update (required)
        :param NodeNetworkInterfaceProperties node_network_interface_properties: (required)
        :return: NodeNetworkInterfaceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interface_id', 'node_network_interface_properties']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_node_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'interface_id' is set
        if ('interface_id' not in params or
                params['interface_id'] is None):
            raise ValueError("Missing the required parameter `interface_id` when calling `update_node_interface`")  # noqa: E501
        # verify the required parameter 'node_network_interface_properties' is set
        if ('node_network_interface_properties' not in params or
                params['node_network_interface_properties'] is None):
            raise ValueError("Missing the required parameter `node_network_interface_properties` when calling `update_node_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'interface_id' in params:
            path_params['interface-id'] = params['interface_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'node_network_interface_properties' in params:
            body_params = params['node_network_interface_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/network/interfaces/{interface-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeNetworkInterfaceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_node_name_servers(self, node_name_servers_properties, **kwargs):  # noqa: E501
        """Update the NSX Manager&#39;s Name Servers  # noqa: E501

        Modifies the list of servers that the NSX Manager node uses to look up IP addresses associated with given domain names. If DHCP is configured, this method returns a 409 CONFLICT error, because DHCP manages the list of name servers.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_node_name_servers(node_name_servers_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeNameServersProperties node_name_servers_properties: (required)
        :return: NodeNameServersProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_node_name_servers_with_http_info(node_name_servers_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.update_node_name_servers_with_http_info(node_name_servers_properties, **kwargs)  # noqa: E501
            return data

    def update_node_name_servers_with_http_info(self, node_name_servers_properties, **kwargs):  # noqa: E501
        """Update the NSX Manager&#39;s Name Servers  # noqa: E501

        Modifies the list of servers that the NSX Manager node uses to look up IP addresses associated with given domain names. If DHCP is configured, this method returns a 409 CONFLICT error, because DHCP manages the list of name servers.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_node_name_servers_with_http_info(node_name_servers_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeNameServersProperties node_name_servers_properties: (required)
        :return: NodeNameServersProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_name_servers_properties']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_node_name_servers" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_name_servers_properties' is set
        if ('node_name_servers_properties' not in params or
                params['node_name_servers_properties'] is None):
            raise ValueError("Missing the required parameter `node_name_servers_properties` when calling `update_node_name_servers`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'node_name_servers_properties' in params:
            body_params = params['node_name_servers_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/network/name-servers', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeNameServersProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_node_properties(self, node_properties, **kwargs):  # noqa: E501
        """Update node properties  # noqa: E501

        Modifies NSX Manager appliance properties. Modifiable properties include the timezone, message of the day (motd), and hostname. The NSX Manager node_version, system_time, and kernel_version are read only and cannot be modified with this method.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_node_properties(node_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeProperties node_properties: (required)
        :return: NodeProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_node_properties_with_http_info(node_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.update_node_properties_with_http_info(node_properties, **kwargs)  # noqa: E501
            return data

    def update_node_properties_with_http_info(self, node_properties, **kwargs):  # noqa: E501
        """Update node properties  # noqa: E501

        Modifies NSX Manager appliance properties. Modifiable properties include the timezone, message of the day (motd), and hostname. The NSX Manager node_version, system_time, and kernel_version are read only and cannot be modified with this method.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_node_properties_with_http_info(node_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeProperties node_properties: (required)
        :return: NodeProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_properties']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_node_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_properties' is set
        if ('node_properties' not in params or
                params['node_properties'] is None):
            raise ValueError("Missing the required parameter `node_properties` when calling `update_node_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'node_properties' in params:
            body_params = params['node_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_node_search_domains(self, node_search_domains_properties, **kwargs):  # noqa: E501
        """Update the NSX Manager&#39;s Search Domains  # noqa: E501

        Modifies the list of domain names that the NSX Manager node uses to complete unqualified host names. If DHCP is configured, this method returns a 409 CONFLICT error, because DHCP manages the list of name servers.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_node_search_domains(node_search_domains_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeSearchDomainsProperties node_search_domains_properties: (required)
        :return: NodeSearchDomainsProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_node_search_domains_with_http_info(node_search_domains_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.update_node_search_domains_with_http_info(node_search_domains_properties, **kwargs)  # noqa: E501
            return data

    def update_node_search_domains_with_http_info(self, node_search_domains_properties, **kwargs):  # noqa: E501
        """Update the NSX Manager&#39;s Search Domains  # noqa: E501

        Modifies the list of domain names that the NSX Manager node uses to complete unqualified host names. If DHCP is configured, this method returns a 409 CONFLICT error, because DHCP manages the list of name servers.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_node_search_domains_with_http_info(node_search_domains_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeSearchDomainsProperties node_search_domains_properties: (required)
        :return: NodeSearchDomainsProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_search_domains_properties']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_node_search_domains" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_search_domains_properties' is set
        if ('node_search_domains_properties' not in params or
                params['node_search_domains_properties'] is None):
            raise ValueError("Missing the required parameter `node_search_domains_properties` when calling `update_node_search_domains`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'node_search_domains_properties' in params:
            body_params = params['node_search_domains_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/network/search-domains', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeSearchDomainsProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_node_user(self, userid, node_user_properties, **kwargs):  # noqa: E501
        """Update node user  # noqa: E501

        Updates attributes of an existing NSX Manager appliance user. This method cannot be used to add a new user. Modifiable attributes include the username, full name of the user, and password. If you specify a password in a PUT request, it is not returned in the response. Nor is it returned in a GET request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_node_user(userid, node_user_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param str userid: User id of the user (required)
        :param NodeUserProperties node_user_properties: (required)
        :return: NodeUserProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_node_user_with_http_info(userid, node_user_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.update_node_user_with_http_info(userid, node_user_properties, **kwargs)  # noqa: E501
            return data

    def update_node_user_with_http_info(self, userid, node_user_properties, **kwargs):  # noqa: E501
        """Update node user  # noqa: E501

        Updates attributes of an existing NSX Manager appliance user. This method cannot be used to add a new user. Modifiable attributes include the username, full name of the user, and password. If you specify a password in a PUT request, it is not returned in the response. Nor is it returned in a GET request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_node_user_with_http_info(userid, node_user_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param str userid: User id of the user (required)
        :param NodeUserProperties node_user_properties: (required)
        :return: NodeUserProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['userid', 'node_user_properties']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_node_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'userid' is set
        if ('userid' not in params or
                params['userid'] is None):
            raise ValueError("Missing the required parameter `userid` when calling `update_node_user`")  # noqa: E501
        # verify the required parameter 'node_user_properties' is set
        if ('node_user_properties' not in params or
                params['node_user_properties'] is None):
            raise ValueError("Missing the required parameter `node_user_properties` when calling `update_node_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'userid' in params:
            path_params['userid'] = params['userid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'node_user_properties' in params:
            body_params = params['node_user_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/users/{userid}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeUserProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ntp_service(self, node_ntp_service_properties, **kwargs):  # noqa: E501
        """Update NTP service properties  # noqa: E501

        Update NTP service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_ntp_service(node_ntp_service_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeNtpServiceProperties node_ntp_service_properties: (required)
        :return: NodeNtpServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_ntp_service_with_http_info(node_ntp_service_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ntp_service_with_http_info(node_ntp_service_properties, **kwargs)  # noqa: E501
            return data

    def update_ntp_service_with_http_info(self, node_ntp_service_properties, **kwargs):  # noqa: E501
        """Update NTP service properties  # noqa: E501

        Update NTP service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_ntp_service_with_http_info(node_ntp_service_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeNtpServiceProperties node_ntp_service_properties: (required)
        :return: NodeNtpServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_ntp_service_properties']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ntp_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_ntp_service_properties' is set
        if ('node_ntp_service_properties' not in params or
                params['node_ntp_service_properties'] is None):
            raise ValueError("Missing the required parameter `node_ntp_service_properties` when calling `update_ntp_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'node_ntp_service_properties' in params:
            body_params = params['node_ntp_service_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/ntp', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeNtpServiceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_proton_service(self, node_proton_service_properties, **kwargs):  # noqa: E501
        """Update service properties  # noqa: E501

        Update service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_proton_service(node_proton_service_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeProtonServiceProperties node_proton_service_properties: (required)
        :return: NodeProtonServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_proton_service_with_http_info(node_proton_service_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.update_proton_service_with_http_info(node_proton_service_properties, **kwargs)  # noqa: E501
            return data

    def update_proton_service_with_http_info(self, node_proton_service_properties, **kwargs):  # noqa: E501
        """Update service properties  # noqa: E501

        Update service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_proton_service_with_http_info(node_proton_service_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeProtonServiceProperties node_proton_service_properties: (required)
        :return: NodeProtonServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_proton_service_properties']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_proton_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_proton_service_properties' is set
        if ('node_proton_service_properties' not in params or
                params['node_proton_service_properties'] is None):
            raise ValueError("Missing the required parameter `node_proton_service_properties` when calling `update_proton_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'node_proton_service_properties' in params:
            body_params = params['node_proton_service_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/manager', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeProtonServiceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_proxy_service(self, node_http_service_properties, **kwargs):  # noqa: E501
        """Update http service properties  # noqa: E501

        Update http service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_proxy_service(node_http_service_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeHttpServiceProperties node_http_service_properties: (required)
        :return: NodeHttpServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_proxy_service_with_http_info(node_http_service_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.update_proxy_service_with_http_info(node_http_service_properties, **kwargs)  # noqa: E501
            return data

    def update_proxy_service_with_http_info(self, node_http_service_properties, **kwargs):  # noqa: E501
        """Update http service properties  # noqa: E501

        Update http service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_proxy_service_with_http_info(node_http_service_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeHttpServiceProperties node_http_service_properties: (required)
        :return: NodeHttpServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_http_service_properties']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_proxy_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_http_service_properties' is set
        if ('node_http_service_properties' not in params or
                params['node_http_service_properties'] is None):
            raise ValueError("Missing the required parameter `node_http_service_properties` when calling `update_proxy_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'node_http_service_properties' in params:
            body_params = params['node_http_service_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/http', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeHttpServiceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_repository_service(self, node_install_upgrade_service_properties, **kwargs):  # noqa: E501
        """Update NSX install-upgrade service properties  # noqa: E501

        Update NSX install-upgrade service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_repository_service(node_install_upgrade_service_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeInstallUpgradeServiceProperties node_install_upgrade_service_properties: (required)
        :return: NodeInstallUpgradeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_repository_service_with_http_info(node_install_upgrade_service_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.update_repository_service_with_http_info(node_install_upgrade_service_properties, **kwargs)  # noqa: E501
            return data

    def update_repository_service_with_http_info(self, node_install_upgrade_service_properties, **kwargs):  # noqa: E501
        """Update NSX install-upgrade service properties  # noqa: E501

        Update NSX install-upgrade service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_repository_service_with_http_info(node_install_upgrade_service_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeInstallUpgradeServiceProperties node_install_upgrade_service_properties: (required)
        :return: NodeInstallUpgradeServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_install_upgrade_service_properties']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_repository_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_install_upgrade_service_properties' is set
        if ('node_install_upgrade_service_properties' not in params or
                params['node_install_upgrade_service_properties'] is None):
            raise ValueError("Missing the required parameter `node_install_upgrade_service_properties` when calling `update_repository_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'node_install_upgrade_service_properties' in params:
            body_params = params['node_install_upgrade_service_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/install-upgrade', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeInstallUpgradeServiceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_snmp_service(self, node_snmp_service_properties, **kwargs):  # noqa: E501
        """Update SNMP service properties  # noqa: E501

        Update SNMP service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_snmp_service(node_snmp_service_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeSnmpServiceProperties node_snmp_service_properties: (required)
        :return: NodeSnmpServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_snmp_service_with_http_info(node_snmp_service_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.update_snmp_service_with_http_info(node_snmp_service_properties, **kwargs)  # noqa: E501
            return data

    def update_snmp_service_with_http_info(self, node_snmp_service_properties, **kwargs):  # noqa: E501
        """Update SNMP service properties  # noqa: E501

        Update SNMP service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_snmp_service_with_http_info(node_snmp_service_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeSnmpServiceProperties node_snmp_service_properties: (required)
        :return: NodeSnmpServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_snmp_service_properties']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_snmp_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_snmp_service_properties' is set
        if ('node_snmp_service_properties' not in params or
                params['node_snmp_service_properties'] is None):
            raise ValueError("Missing the required parameter `node_snmp_service_properties` when calling `update_snmp_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'node_snmp_service_properties' in params:
            body_params = params['node_snmp_service_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/snmp', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeSnmpServiceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ssh_service(self, node_ssh_service_properties, **kwargs):  # noqa: E501
        """Update ssh service properties  # noqa: E501

        Update ssh service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_ssh_service(node_ssh_service_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeSshServiceProperties node_ssh_service_properties: (required)
        :return: NodeSshServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_ssh_service_with_http_info(node_ssh_service_properties, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ssh_service_with_http_info(node_ssh_service_properties, **kwargs)  # noqa: E501
            return data

    def update_ssh_service_with_http_info(self, node_ssh_service_properties, **kwargs):  # noqa: E501
        """Update ssh service properties  # noqa: E501

        Update ssh service properties  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_ssh_service_with_http_info(node_ssh_service_properties, async=True)
        >>> result = thread.get()

        :param async bool
        :param NodeSshServiceProperties node_ssh_service_properties: (required)
        :return: NodeSshServiceProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['node_ssh_service_properties']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ssh_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'node_ssh_service_properties' is set
        if ('node_ssh_service_properties' not in params or
                params['node_ssh_service_properties'] is None):
            raise ValueError("Missing the required parameter `node_ssh_service_properties` when calling `update_ssh_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'node_ssh_service_properties' in params:
            body_params = params['node_ssh_service_properties']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/node/services/ssh', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeSshServiceProperties',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
