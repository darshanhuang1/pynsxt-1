# coding: utf-8

"""
    NSX API

    VMware NSX REST API  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ServicesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_dne_key_manager(self, dne_key_manager, **kwargs):  # noqa: E501
        """Add a network encryption key manager configuration  # noqa: E501

        Add a network encryption key manager configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_dne_key_manager(dne_key_manager, async=True)
        >>> result = thread.get()

        :param async bool
        :param DneKeyManager dne_key_manager: (required)
        :return: DneKeyManager
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_dne_key_manager_with_http_info(dne_key_manager, **kwargs)  # noqa: E501
        else:
            (data) = self.add_dne_key_manager_with_http_info(dne_key_manager, **kwargs)  # noqa: E501
            return data

    def add_dne_key_manager_with_http_info(self, dne_key_manager, **kwargs):  # noqa: E501
        """Add a network encryption key manager configuration  # noqa: E501

        Add a network encryption key manager configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_dne_key_manager_with_http_info(dne_key_manager, async=True)
        >>> result = thread.get()

        :param async bool
        :param DneKeyManager dne_key_manager: (required)
        :return: DneKeyManager
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dne_key_manager']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_dne_key_manager" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dne_key_manager' is set
        if ('dne_key_manager' not in params or
                params['dne_key_manager'] is None):
            raise ValueError("Missing the required parameter `dne_key_manager` when calling `add_dne_key_manager`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dne_key_manager' in params:
            body_params = params['dne_key_manager']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/key-managers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneKeyManager',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_dne_key_policy(self, dne_key_policy, **kwargs):  # noqa: E501
        """Create a network encryption key policy  # noqa: E501

        Create a network encryption key policy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_dne_key_policy(dne_key_policy, async=True)
        >>> result = thread.get()

        :param async bool
        :param DneKeyPolicy dne_key_policy: (required)
        :return: DneKeyPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_dne_key_policy_with_http_info(dne_key_policy, **kwargs)  # noqa: E501
        else:
            (data) = self.add_dne_key_policy_with_http_info(dne_key_policy, **kwargs)  # noqa: E501
            return data

    def add_dne_key_policy_with_http_info(self, dne_key_policy, **kwargs):  # noqa: E501
        """Create a network encryption key policy  # noqa: E501

        Create a network encryption key policy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_dne_key_policy_with_http_info(dne_key_policy, async=True)
        >>> result = thread.get()

        :param async bool
        :param DneKeyPolicy dne_key_policy: (required)
        :return: DneKeyPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dne_key_policy']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_dne_key_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dne_key_policy' is set
        if ('dne_key_policy' not in params or
                params['dne_key_policy'] is None):
            raise ValueError("Missing the required parameter `dne_key_policy` when calling `add_dne_key_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dne_key_policy' in params:
            body_params = params['dne_key_policy']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/key-policies', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneKeyPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_dne_rule_in_section(self, section_id, dne_rule, operation, **kwargs):  # noqa: E501
        """Add a network encryption rule in a section  # noqa: E501

        Add a network encryption rule in a section  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_dne_rule_in_section(section_id, dne_rule, operation, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param DneRule dne_rule: (required)
        :param str operation: Operation (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :return: DneRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_dne_rule_in_section_with_http_info(section_id, dne_rule, operation, **kwargs)  # noqa: E501
        else:
            (data) = self.add_dne_rule_in_section_with_http_info(section_id, dne_rule, operation, **kwargs)  # noqa: E501
            return data

    def add_dne_rule_in_section_with_http_info(self, section_id, dne_rule, operation, **kwargs):  # noqa: E501
        """Add a network encryption rule in a section  # noqa: E501

        Add a network encryption rule in a section  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_dne_rule_in_section_with_http_info(section_id, dne_rule, operation, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param DneRule dne_rule: (required)
        :param str operation: Operation (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :return: DneRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'dne_rule', 'operation', 'id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_dne_rule_in_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `add_dne_rule_in_section`")  # noqa: E501
        # verify the required parameter 'dne_rule' is set
        if ('dne_rule' not in params or
                params['dne_rule'] is None):
            raise ValueError("Missing the required parameter `dne_rule` when calling `add_dne_rule_in_section`")  # noqa: E501
        # verify the required parameter 'operation' is set
        if ('operation' not in params or
                params['operation'] is None):
            raise ValueError("Missing the required parameter `operation` when calling `add_dne_rule_in_section`")  # noqa: E501

        if ('id' in params and
                len(params['id']) > 64):
            raise ValueError("Invalid value for parameter `id` when calling `add_dne_rule_in_section`, length must be less than or equal to `64`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dne_rule' in params:
            body_params = params['dne_rule']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/sections/{section-id}/rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneRule',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_dne_rules_in_section_create_multiple(self, section_id, dne_rule_list, operation, **kwargs):  # noqa: E501
        """Add multiple rules to a network encryption section  # noqa: E501

        Add multiple rules to a network encryption section  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_dne_rules_in_section_create_multiple(section_id, dne_rule_list, operation, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param DneRuleList dne_rule_list: (required)
        :param str operation: Operation (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :return: DneRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_dne_rules_in_section_create_multiple_with_http_info(section_id, dne_rule_list, operation, **kwargs)  # noqa: E501
        else:
            (data) = self.add_dne_rules_in_section_create_multiple_with_http_info(section_id, dne_rule_list, operation, **kwargs)  # noqa: E501
            return data

    def add_dne_rules_in_section_create_multiple_with_http_info(self, section_id, dne_rule_list, operation, **kwargs):  # noqa: E501
        """Add multiple rules to a network encryption section  # noqa: E501

        Add multiple rules to a network encryption section  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_dne_rules_in_section_create_multiple_with_http_info(section_id, dne_rule_list, operation, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param DneRuleList dne_rule_list: (required)
        :param str operation: Operation (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :return: DneRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'dne_rule_list', 'operation', 'id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_dne_rules_in_section_create_multiple" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `add_dne_rules_in_section_create_multiple`")  # noqa: E501
        # verify the required parameter 'dne_rule_list' is set
        if ('dne_rule_list' not in params or
                params['dne_rule_list'] is None):
            raise ValueError("Missing the required parameter `dne_rule_list` when calling `add_dne_rules_in_section_create_multiple`")  # noqa: E501
        # verify the required parameter 'operation' is set
        if ('operation' not in params or
                params['operation'] is None):
            raise ValueError("Missing the required parameter `operation` when calling `add_dne_rules_in_section_create_multiple`")  # noqa: E501

        if ('id' in params and
                len(params['id']) > 64):
            raise ValueError("Invalid value for parameter `id` when calling `add_dne_rules_in_section_create_multiple`, length must be less than or equal to `64`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dne_rule_list' in params:
            body_params = params['dne_rule_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/sections/{section-id}/rules?action=create_multiple', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_dne_section(self, dne_section, operation, **kwargs):  # noqa: E501
        """Create a network encryption section without rules  # noqa: E501

        Create a network encryption section without rules  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_dne_section(dne_section, operation, async=True)
        >>> result = thread.get()

        :param async bool
        :param DneSection dne_section: (required)
        :param str operation: Operation (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :return: DneSection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_dne_section_with_http_info(dne_section, operation, **kwargs)  # noqa: E501
        else:
            (data) = self.add_dne_section_with_http_info(dne_section, operation, **kwargs)  # noqa: E501
            return data

    def add_dne_section_with_http_info(self, dne_section, operation, **kwargs):  # noqa: E501
        """Create a network encryption section without rules  # noqa: E501

        Create a network encryption section without rules  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_dne_section_with_http_info(dne_section, operation, async=True)
        >>> result = thread.get()

        :param async bool
        :param DneSection dne_section: (required)
        :param str operation: Operation (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :return: DneSection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dne_section', 'operation', 'id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_dne_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dne_section' is set
        if ('dne_section' not in params or
                params['dne_section'] is None):
            raise ValueError("Missing the required parameter `dne_section` when calling `add_dne_section`")  # noqa: E501
        # verify the required parameter 'operation' is set
        if ('operation' not in params or
                params['operation'] is None):
            raise ValueError("Missing the required parameter `operation` when calling `add_dne_section`")  # noqa: E501

        if ('id' in params and
                len(params['id']) > 64):
            raise ValueError("Invalid value for parameter `id` when calling `add_dne_section`, length must be less than or equal to `64`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dne_section' in params:
            body_params = params['dne_section']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/sections', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneSection',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_dne_section_with_rules_create_with_rules(self, dne_section_rule_list, operation, **kwargs):  # noqa: E501
        """Create a network encryption section with rules  # noqa: E501

        The limit on the number of rules is defined by maxItems in collection types for DneRule (DneRuleList types). When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules with a large number of rule references is not supported.  Instead, to create sections, use: POST /api/v1/network-encryption/sections  To create rules, use: POST /api/v1/network-encryption/sections/&lt;section-id&gt;/rules   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_dne_section_with_rules_create_with_rules(dne_section_rule_list, operation, async=True)
        >>> result = thread.get()

        :param async bool
        :param DneSectionRuleList dne_section_rule_list: (required)
        :param str operation: Operation (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :return: DneSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_dne_section_with_rules_create_with_rules_with_http_info(dne_section_rule_list, operation, **kwargs)  # noqa: E501
        else:
            (data) = self.add_dne_section_with_rules_create_with_rules_with_http_info(dne_section_rule_list, operation, **kwargs)  # noqa: E501
            return data

    def add_dne_section_with_rules_create_with_rules_with_http_info(self, dne_section_rule_list, operation, **kwargs):  # noqa: E501
        """Create a network encryption section with rules  # noqa: E501

        The limit on the number of rules is defined by maxItems in collection types for DneRule (DneRuleList types). When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules with a large number of rule references is not supported.  Instead, to create sections, use: POST /api/v1/network-encryption/sections  To create rules, use: POST /api/v1/network-encryption/sections/&lt;section-id&gt;/rules   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_dne_section_with_rules_create_with_rules_with_http_info(dne_section_rule_list, operation, async=True)
        >>> result = thread.get()

        :param async bool
        :param DneSectionRuleList dne_section_rule_list: (required)
        :param str operation: Operation (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :return: DneSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dne_section_rule_list', 'operation', 'id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_dne_section_with_rules_create_with_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dne_section_rule_list' is set
        if ('dne_section_rule_list' not in params or
                params['dne_section_rule_list'] is None):
            raise ValueError("Missing the required parameter `dne_section_rule_list` when calling `add_dne_section_with_rules_create_with_rules`")  # noqa: E501
        # verify the required parameter 'operation' is set
        if ('operation' not in params or
                params['operation'] is None):
            raise ValueError("Missing the required parameter `operation` when calling `add_dne_section_with_rules_create_with_rules`")  # noqa: E501

        if ('id' in params and
                len(params['id']) > 64):
            raise ValueError("Invalid value for parameter `id` when calling `add_dne_section_with_rules_create_with_rules`, length must be less than or equal to `64`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dne_section_rule_list' in params:
            body_params = params['dne_section_rule_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/sections?action=create_with_rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneSectionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_member_add_member(self, resource_reference, **kwargs):  # noqa: E501
        """Add a new object in the exclude list  # noqa: E501

        Add a new object in the exclude list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_member_add_member(resource_reference, async=True)
        >>> result = thread.get()

        :param async bool
        :param ResourceReference resource_reference: (required)
        :return: ResourceReference
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_member_add_member_with_http_info(resource_reference, **kwargs)  # noqa: E501
        else:
            (data) = self.add_member_add_member_with_http_info(resource_reference, **kwargs)  # noqa: E501
            return data

    def add_member_add_member_with_http_info(self, resource_reference, **kwargs):  # noqa: E501
        """Add a new object in the exclude list  # noqa: E501

        Add a new object in the exclude list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_member_add_member_with_http_info(resource_reference, async=True)
        >>> result = thread.get()

        :param async bool
        :param ResourceReference resource_reference: (required)
        :return: ResourceReference
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_reference']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_member_add_member" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource_reference' is set
        if ('resource_reference' not in params or
                params['resource_reference'] is None):
            raise ValueError("Missing the required parameter `resource_reference` when calling `add_member_add_member`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'resource_reference' in params:
            body_params = params['resource_reference']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/excludelist?action=add_member', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceReference',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_rule_in_section(self, section_id, firewall_rule, **kwargs):  # noqa: E501
        """Add a Single Rule in a Section  # noqa: E501

        Adds a new firewall rule in existing firewall section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_rule_in_section(section_id, firewall_rule, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param FirewallRule firewall_rule: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_rule_in_section_with_http_info(section_id, firewall_rule, **kwargs)  # noqa: E501
        else:
            (data) = self.add_rule_in_section_with_http_info(section_id, firewall_rule, **kwargs)  # noqa: E501
            return data

    def add_rule_in_section_with_http_info(self, section_id, firewall_rule, **kwargs):  # noqa: E501
        """Add a Single Rule in a Section  # noqa: E501

        Adds a new firewall rule in existing firewall section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_rule_in_section_with_http_info(section_id, firewall_rule, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param FirewallRule firewall_rule: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'firewall_rule', 'id', 'operation']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_rule_in_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `add_rule_in_section`")  # noqa: E501
        # verify the required parameter 'firewall_rule' is set
        if ('firewall_rule' not in params or
                params['firewall_rule'] is None):
            raise ValueError("Missing the required parameter `firewall_rule` when calling `add_rule_in_section`")  # noqa: E501

        if ('id' in params and
                len(params['id']) > 64):
            raise ValueError("Invalid value for parameter `id` when calling `add_rule_in_section`, length must be less than or equal to `64`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'firewall_rule' in params:
            body_params = params['firewall_rule']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}/rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallRule',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_rules_in_section_create_multiple(self, section_id, firewall_rule_list, **kwargs):  # noqa: E501
        """Add Multiple Rules in a Section  # noqa: E501

        Create multiple firewall rules in existing firewall section bounded by limit of 1000 firewall rules per section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_rules_in_section_create_multiple(section_id, firewall_rule_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param FirewallRuleList firewall_rule_list: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_rules_in_section_create_multiple_with_http_info(section_id, firewall_rule_list, **kwargs)  # noqa: E501
        else:
            (data) = self.add_rules_in_section_create_multiple_with_http_info(section_id, firewall_rule_list, **kwargs)  # noqa: E501
            return data

    def add_rules_in_section_create_multiple_with_http_info(self, section_id, firewall_rule_list, **kwargs):  # noqa: E501
        """Add Multiple Rules in a Section  # noqa: E501

        Create multiple firewall rules in existing firewall section bounded by limit of 1000 firewall rules per section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_rules_in_section_create_multiple_with_http_info(section_id, firewall_rule_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param FirewallRuleList firewall_rule_list: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'firewall_rule_list', 'id', 'operation']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_rules_in_section_create_multiple" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `add_rules_in_section_create_multiple`")  # noqa: E501
        # verify the required parameter 'firewall_rule_list' is set
        if ('firewall_rule_list' not in params or
                params['firewall_rule_list'] is None):
            raise ValueError("Missing the required parameter `firewall_rule_list` when calling `add_rules_in_section_create_multiple`")  # noqa: E501

        if ('id' in params and
                len(params['id']) > 64):
            raise ValueError("Invalid value for parameter `id` when calling `add_rules_in_section_create_multiple`, length must be less than or equal to `64`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'firewall_rule_list' in params:
            body_params = params['firewall_rule_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}/rules?action=create_multiple', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_section(self, firewall_section, **kwargs):  # noqa: E501
        """Create a New Empty Section  # noqa: E501

        Creates new empty firewall section in the system.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_section(firewall_section, async=True)
        >>> result = thread.get()

        :param async bool
        :param FirewallSection firewall_section: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_section_with_http_info(firewall_section, **kwargs)  # noqa: E501
        else:
            (data) = self.add_section_with_http_info(firewall_section, **kwargs)  # noqa: E501
            return data

    def add_section_with_http_info(self, firewall_section, **kwargs):  # noqa: E501
        """Create a New Empty Section  # noqa: E501

        Creates new empty firewall section in the system.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_section_with_http_info(firewall_section, async=True)
        >>> result = thread.get()

        :param async bool
        :param FirewallSection firewall_section: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['firewall_section', 'id', 'operation']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'firewall_section' is set
        if ('firewall_section' not in params or
                params['firewall_section'] is None):
            raise ValueError("Missing the required parameter `firewall_section` when calling `add_section`")  # noqa: E501

        if ('id' in params and
                len(params['id']) > 64):
            raise ValueError("Invalid value for parameter `id` when calling `add_section`, length must be less than or equal to `64`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'firewall_section' in params:
            body_params = params['firewall_section']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSection',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_section_with_rules_create_with_rules(self, firewall_section_rule_list, **kwargs):  # noqa: E501
        """Create a Section with Rules  # noqa: E501

        Creates a new firewall section with rules. The limit on the number of rules is defined by maxItems in collection types for FirewallRule (FirewallRuleXXXList types). When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules with a large number of rule references is not supported.  Instead, to create sections, use: POST /api/v1/firewall/sections  To create rules, use: POST /api/v1/firewall/sections/&lt;section-id&gt;/rules   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_section_with_rules_create_with_rules(firewall_section_rule_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param FirewallSectionRuleList firewall_section_rule_list: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.add_section_with_rules_create_with_rules_with_http_info(firewall_section_rule_list, **kwargs)  # noqa: E501
        else:
            (data) = self.add_section_with_rules_create_with_rules_with_http_info(firewall_section_rule_list, **kwargs)  # noqa: E501
            return data

    def add_section_with_rules_create_with_rules_with_http_info(self, firewall_section_rule_list, **kwargs):  # noqa: E501
        """Create a Section with Rules  # noqa: E501

        Creates a new firewall section with rules. The limit on the number of rules is defined by maxItems in collection types for FirewallRule (FirewallRuleXXXList types). When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules with a large number of rule references is not supported.  Instead, to create sections, use: POST /api/v1/firewall/sections  To create rules, use: POST /api/v1/firewall/sections/&lt;section-id&gt;/rules   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.add_section_with_rules_create_with_rules_with_http_info(firewall_section_rule_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param FirewallSectionRuleList firewall_section_rule_list: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['firewall_section_rule_list', 'id', 'operation']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_section_with_rules_create_with_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'firewall_section_rule_list' is set
        if ('firewall_section_rule_list' not in params or
                params['firewall_section_rule_list'] is None):
            raise ValueError("Missing the required parameter `firewall_section_rule_list` when calling `add_section_with_rules_create_with_rules`")  # noqa: E501

        if ('id' in params and
                len(params['id']) > 64):
            raise ValueError("Invalid value for parameter `id` when calling `add_section_with_rules_create_with_rules`, length must be less than or equal to `64`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'firewall_section_rule_list' in params:
            body_params = params['firewall_section_rule_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections?action=create_with_rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSectionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def check_member_if_exists_check_if_exists(self, object_id, **kwargs):  # noqa: E501
        """Check if the object a member of the exclude list  # noqa: E501

        Check if the object a member of the exclude list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.check_member_if_exists_check_if_exists(object_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str object_id: identifier of the object (required)
        :return: ResourceReference
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.check_member_if_exists_check_if_exists_with_http_info(object_id, **kwargs)  # noqa: E501
        else:
            (data) = self.check_member_if_exists_check_if_exists_with_http_info(object_id, **kwargs)  # noqa: E501
            return data

    def check_member_if_exists_check_if_exists_with_http_info(self, object_id, **kwargs):  # noqa: E501
        """Check if the object a member of the exclude list  # noqa: E501

        Check if the object a member of the exclude list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.check_member_if_exists_check_if_exists_with_http_info(object_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str object_id: identifier of the object (required)
        :return: ResourceReference
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method check_member_if_exists_check_if_exists" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if ('object_id' not in params or
                params['object_id'] is None):
            raise ValueError("Missing the required parameter `object_id` when calling `check_member_if_exists_check_if_exists`")  # noqa: E501

        if ('object_id' in params and
                len(params['object_id']) > 64):
            raise ValueError("Invalid value for parameter `object_id` when calling `check_member_if_exists_check_if_exists`, length must be less than or equal to `64`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'object_id' in params:
            query_params.append(('object_id', params['object_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/excludelist?action=check_if_exists', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceReference',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_dhcp_ip_pool(self, server_id, dhcp_ip_pool, **kwargs):  # noqa: E501
        """Create an IP pool for a DHCP server  # noqa: E501

        Create an IP pool for a DHCP server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_dhcp_ip_pool(server_id, dhcp_ip_pool, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param DhcpIpPool dhcp_ip_pool: (required)
        :return: DhcpIpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_dhcp_ip_pool_with_http_info(server_id, dhcp_ip_pool, **kwargs)  # noqa: E501
        else:
            (data) = self.create_dhcp_ip_pool_with_http_info(server_id, dhcp_ip_pool, **kwargs)  # noqa: E501
            return data

    def create_dhcp_ip_pool_with_http_info(self, server_id, dhcp_ip_pool, **kwargs):  # noqa: E501
        """Create an IP pool for a DHCP server  # noqa: E501

        Create an IP pool for a DHCP server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_dhcp_ip_pool_with_http_info(server_id, dhcp_ip_pool, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param DhcpIpPool dhcp_ip_pool: (required)
        :return: DhcpIpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'dhcp_ip_pool']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dhcp_ip_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `create_dhcp_ip_pool`")  # noqa: E501
        # verify the required parameter 'dhcp_ip_pool' is set
        if ('dhcp_ip_pool' not in params or
                params['dhcp_ip_pool'] is None):
            raise ValueError("Missing the required parameter `dhcp_ip_pool` when calling `create_dhcp_ip_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dhcp_ip_pool' in params:
            body_params = params['dhcp_ip_pool']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ip-pools', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpIpPool',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_dhcp_profile(self, dhcp_profile, **kwargs):  # noqa: E501
        """Create a DHCP server profile  # noqa: E501

        Create a DHCP server profile  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_dhcp_profile(dhcp_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param DhcpProfile dhcp_profile: (required)
        :return: DhcpProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_dhcp_profile_with_http_info(dhcp_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.create_dhcp_profile_with_http_info(dhcp_profile, **kwargs)  # noqa: E501
            return data

    def create_dhcp_profile_with_http_info(self, dhcp_profile, **kwargs):  # noqa: E501
        """Create a DHCP server profile  # noqa: E501

        Create a DHCP server profile  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_dhcp_profile_with_http_info(dhcp_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param DhcpProfile dhcp_profile: (required)
        :return: DhcpProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dhcp_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dhcp_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dhcp_profile' is set
        if ('dhcp_profile' not in params or
                params['dhcp_profile'] is None):
            raise ValueError("Missing the required parameter `dhcp_profile` when calling `create_dhcp_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dhcp_profile' in params:
            body_params = params['dhcp_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/server-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_dhcp_server(self, logical_dhcp_server, **kwargs):  # noqa: E501
        """Create a DHCP server  # noqa: E501

        Create a DHCP server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_dhcp_server(logical_dhcp_server, async=True)
        >>> result = thread.get()

        :param async bool
        :param LogicalDhcpServer logical_dhcp_server: (required)
        :return: LogicalDhcpServer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_dhcp_server_with_http_info(logical_dhcp_server, **kwargs)  # noqa: E501
        else:
            (data) = self.create_dhcp_server_with_http_info(logical_dhcp_server, **kwargs)  # noqa: E501
            return data

    def create_dhcp_server_with_http_info(self, logical_dhcp_server, **kwargs):  # noqa: E501
        """Create a DHCP server  # noqa: E501

        Create a DHCP server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_dhcp_server_with_http_info(logical_dhcp_server, async=True)
        >>> result = thread.get()

        :param async bool
        :param LogicalDhcpServer logical_dhcp_server: (required)
        :return: LogicalDhcpServer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logical_dhcp_server']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dhcp_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'logical_dhcp_server' is set
        if ('logical_dhcp_server' not in params or
                params['logical_dhcp_server'] is None):
            raise ValueError("Missing the required parameter `logical_dhcp_server` when calling `create_dhcp_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'logical_dhcp_server' in params:
            body_params = params['logical_dhcp_server']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalDhcpServer',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_dhcp_static_binding(self, server_id, dhcp_static_binding, **kwargs):  # noqa: E501
        """Create a static binding for a DHCP server  # noqa: E501

        Create a static binding for a DHCP server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_dhcp_static_binding(server_id, dhcp_static_binding, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param DhcpStaticBinding dhcp_static_binding: (required)
        :return: DhcpStaticBinding
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_dhcp_static_binding_with_http_info(server_id, dhcp_static_binding, **kwargs)  # noqa: E501
        else:
            (data) = self.create_dhcp_static_binding_with_http_info(server_id, dhcp_static_binding, **kwargs)  # noqa: E501
            return data

    def create_dhcp_static_binding_with_http_info(self, server_id, dhcp_static_binding, **kwargs):  # noqa: E501
        """Create a static binding for a DHCP server  # noqa: E501

        Create a static binding for a DHCP server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_dhcp_static_binding_with_http_info(server_id, dhcp_static_binding, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param DhcpStaticBinding dhcp_static_binding: (required)
        :return: DhcpStaticBinding
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'dhcp_static_binding']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dhcp_static_binding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `create_dhcp_static_binding`")  # noqa: E501
        # verify the required parameter 'dhcp_static_binding' is set
        if ('dhcp_static_binding' not in params or
                params['dhcp_static_binding'] is None):
            raise ValueError("Missing the required parameter `dhcp_static_binding` when calling `create_dhcp_static_binding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dhcp_static_binding' in params:
            body_params = params['dhcp_static_binding']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/static-bindings', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpStaticBinding',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_load_balancer_application_profile(self, lb_app_profile, **kwargs):  # noqa: E501
        """Create a load balancer application profile  # noqa: E501

        Create a load balancer application profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_load_balancer_application_profile(lb_app_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param LbAppProfile lb_app_profile: (required)
        :return: LbAppProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_load_balancer_application_profile_with_http_info(lb_app_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.create_load_balancer_application_profile_with_http_info(lb_app_profile, **kwargs)  # noqa: E501
            return data

    def create_load_balancer_application_profile_with_http_info(self, lb_app_profile, **kwargs):  # noqa: E501
        """Create a load balancer application profile  # noqa: E501

        Create a load balancer application profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_load_balancer_application_profile_with_http_info(lb_app_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param LbAppProfile lb_app_profile: (required)
        :return: LbAppProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lb_app_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_load_balancer_application_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lb_app_profile' is set
        if ('lb_app_profile' not in params or
                params['lb_app_profile'] is None):
            raise ValueError("Missing the required parameter `lb_app_profile` when calling `create_load_balancer_application_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'lb_app_profile' in params:
            body_params = params['lb_app_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/application-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbAppProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_load_balancer_client_ssl_profile(self, lb_client_ssl_profile, **kwargs):  # noqa: E501
        """Create a load balancer client-ssl profile  # noqa: E501

        Create a load balancer client-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_load_balancer_client_ssl_profile(lb_client_ssl_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param LbClientSslProfile lb_client_ssl_profile: (required)
        :return: LbClientSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_load_balancer_client_ssl_profile_with_http_info(lb_client_ssl_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.create_load_balancer_client_ssl_profile_with_http_info(lb_client_ssl_profile, **kwargs)  # noqa: E501
            return data

    def create_load_balancer_client_ssl_profile_with_http_info(self, lb_client_ssl_profile, **kwargs):  # noqa: E501
        """Create a load balancer client-ssl profile  # noqa: E501

        Create a load balancer client-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_load_balancer_client_ssl_profile_with_http_info(lb_client_ssl_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param LbClientSslProfile lb_client_ssl_profile: (required)
        :return: LbClientSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lb_client_ssl_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_load_balancer_client_ssl_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lb_client_ssl_profile' is set
        if ('lb_client_ssl_profile' not in params or
                params['lb_client_ssl_profile'] is None):
            raise ValueError("Missing the required parameter `lb_client_ssl_profile` when calling `create_load_balancer_client_ssl_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'lb_client_ssl_profile' in params:
            body_params = params['lb_client_ssl_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/client-ssl-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbClientSslProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_load_balancer_monitor(self, lb_monitor, **kwargs):  # noqa: E501
        """Create a load balancer monitor  # noqa: E501

        Create a load balancer monitor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_load_balancer_monitor(lb_monitor, async=True)
        >>> result = thread.get()

        :param async bool
        :param LbMonitor lb_monitor: (required)
        :return: LbMonitor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_load_balancer_monitor_with_http_info(lb_monitor, **kwargs)  # noqa: E501
        else:
            (data) = self.create_load_balancer_monitor_with_http_info(lb_monitor, **kwargs)  # noqa: E501
            return data

    def create_load_balancer_monitor_with_http_info(self, lb_monitor, **kwargs):  # noqa: E501
        """Create a load balancer monitor  # noqa: E501

        Create a load balancer monitor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_load_balancer_monitor_with_http_info(lb_monitor, async=True)
        >>> result = thread.get()

        :param async bool
        :param LbMonitor lb_monitor: (required)
        :return: LbMonitor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lb_monitor']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_load_balancer_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lb_monitor' is set
        if ('lb_monitor' not in params or
                params['lb_monitor'] is None):
            raise ValueError("Missing the required parameter `lb_monitor` when calling `create_load_balancer_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'lb_monitor' in params:
            body_params = params['lb_monitor']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/monitors', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbMonitor',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_load_balancer_persistence_profile(self, lb_persistence_profile, **kwargs):  # noqa: E501
        """Create a load balancer persistence profile  # noqa: E501

        Create a load balancer persistence profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_load_balancer_persistence_profile(lb_persistence_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param LbPersistenceProfile lb_persistence_profile: (required)
        :return: LbPersistenceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_load_balancer_persistence_profile_with_http_info(lb_persistence_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.create_load_balancer_persistence_profile_with_http_info(lb_persistence_profile, **kwargs)  # noqa: E501
            return data

    def create_load_balancer_persistence_profile_with_http_info(self, lb_persistence_profile, **kwargs):  # noqa: E501
        """Create a load balancer persistence profile  # noqa: E501

        Create a load balancer persistence profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_load_balancer_persistence_profile_with_http_info(lb_persistence_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param LbPersistenceProfile lb_persistence_profile: (required)
        :return: LbPersistenceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lb_persistence_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_load_balancer_persistence_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lb_persistence_profile' is set
        if ('lb_persistence_profile' not in params or
                params['lb_persistence_profile'] is None):
            raise ValueError("Missing the required parameter `lb_persistence_profile` when calling `create_load_balancer_persistence_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'lb_persistence_profile' in params:
            body_params = params['lb_persistence_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/persistence-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPersistenceProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_load_balancer_pool(self, lb_pool, **kwargs):  # noqa: E501
        """Create a load balancer pool  # noqa: E501

        Create a load balancer pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_load_balancer_pool(lb_pool, async=True)
        >>> result = thread.get()

        :param async bool
        :param LbPool lb_pool: (required)
        :return: LbPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_load_balancer_pool_with_http_info(lb_pool, **kwargs)  # noqa: E501
        else:
            (data) = self.create_load_balancer_pool_with_http_info(lb_pool, **kwargs)  # noqa: E501
            return data

    def create_load_balancer_pool_with_http_info(self, lb_pool, **kwargs):  # noqa: E501
        """Create a load balancer pool  # noqa: E501

        Create a load balancer pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_load_balancer_pool_with_http_info(lb_pool, async=True)
        >>> result = thread.get()

        :param async bool
        :param LbPool lb_pool: (required)
        :return: LbPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lb_pool']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_load_balancer_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lb_pool' is set
        if ('lb_pool' not in params or
                params['lb_pool'] is None):
            raise ValueError("Missing the required parameter `lb_pool` when calling `create_load_balancer_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'lb_pool' in params:
            body_params = params['lb_pool']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/pools', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPool',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_load_balancer_rule(self, lb_rule, **kwargs):  # noqa: E501
        """Create a load balancer rule  # noqa: E501

        Create a load balancer rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_load_balancer_rule(lb_rule, async=True)
        >>> result = thread.get()

        :param async bool
        :param LbRule lb_rule: (required)
        :return: LbRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_load_balancer_rule_with_http_info(lb_rule, **kwargs)  # noqa: E501
        else:
            (data) = self.create_load_balancer_rule_with_http_info(lb_rule, **kwargs)  # noqa: E501
            return data

    def create_load_balancer_rule_with_http_info(self, lb_rule, **kwargs):  # noqa: E501
        """Create a load balancer rule  # noqa: E501

        Create a load balancer rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_load_balancer_rule_with_http_info(lb_rule, async=True)
        >>> result = thread.get()

        :param async bool
        :param LbRule lb_rule: (required)
        :return: LbRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lb_rule']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_load_balancer_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lb_rule' is set
        if ('lb_rule' not in params or
                params['lb_rule'] is None):
            raise ValueError("Missing the required parameter `lb_rule` when calling `create_load_balancer_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'lb_rule' in params:
            body_params = params['lb_rule']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbRule',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_load_balancer_server_ssl_profile(self, lb_server_ssl_profile, **kwargs):  # noqa: E501
        """Create a load balancer server-ssl profile  # noqa: E501

        Create a load balancer server-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_load_balancer_server_ssl_profile(lb_server_ssl_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param LbServerSslProfile lb_server_ssl_profile: (required)
        :return: LbServerSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_load_balancer_server_ssl_profile_with_http_info(lb_server_ssl_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.create_load_balancer_server_ssl_profile_with_http_info(lb_server_ssl_profile, **kwargs)  # noqa: E501
            return data

    def create_load_balancer_server_ssl_profile_with_http_info(self, lb_server_ssl_profile, **kwargs):  # noqa: E501
        """Create a load balancer server-ssl profile  # noqa: E501

        Create a load balancer server-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_load_balancer_server_ssl_profile_with_http_info(lb_server_ssl_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param LbServerSslProfile lb_server_ssl_profile: (required)
        :return: LbServerSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lb_server_ssl_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_load_balancer_server_ssl_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lb_server_ssl_profile' is set
        if ('lb_server_ssl_profile' not in params or
                params['lb_server_ssl_profile'] is None):
            raise ValueError("Missing the required parameter `lb_server_ssl_profile` when calling `create_load_balancer_server_ssl_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'lb_server_ssl_profile' in params:
            body_params = params['lb_server_ssl_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/server-ssl-profiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbServerSslProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_load_balancer_service(self, lb_service, **kwargs):  # noqa: E501
        """Create a load balancer service  # noqa: E501

        Create a load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_load_balancer_service(lb_service, async=True)
        >>> result = thread.get()

        :param async bool
        :param LbService lb_service: (required)
        :return: LbService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_load_balancer_service_with_http_info(lb_service, **kwargs)  # noqa: E501
        else:
            (data) = self.create_load_balancer_service_with_http_info(lb_service, **kwargs)  # noqa: E501
            return data

    def create_load_balancer_service_with_http_info(self, lb_service, **kwargs):  # noqa: E501
        """Create a load balancer service  # noqa: E501

        Create a load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_load_balancer_service_with_http_info(lb_service, async=True)
        >>> result = thread.get()

        :param async bool
        :param LbService lb_service: (required)
        :return: LbService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lb_service']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_load_balancer_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lb_service' is set
        if ('lb_service' not in params or
                params['lb_service'] is None):
            raise ValueError("Missing the required parameter `lb_service` when calling `create_load_balancer_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'lb_service' in params:
            body_params = params['lb_service']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbService',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_load_balancer_virtual_server(self, lb_virtual_server, **kwargs):  # noqa: E501
        """Create a load balancer virtual server  # noqa: E501

        Create a load balancer virtual server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_load_balancer_virtual_server(lb_virtual_server, async=True)
        >>> result = thread.get()

        :param async bool
        :param LbVirtualServer lb_virtual_server: (required)
        :return: LbVirtualServer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_load_balancer_virtual_server_with_http_info(lb_virtual_server, **kwargs)  # noqa: E501
        else:
            (data) = self.create_load_balancer_virtual_server_with_http_info(lb_virtual_server, **kwargs)  # noqa: E501
            return data

    def create_load_balancer_virtual_server_with_http_info(self, lb_virtual_server, **kwargs):  # noqa: E501
        """Create a load balancer virtual server  # noqa: E501

        Create a load balancer virtual server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_load_balancer_virtual_server_with_http_info(lb_virtual_server, async=True)
        >>> result = thread.get()

        :param async bool
        :param LbVirtualServer lb_virtual_server: (required)
        :return: LbVirtualServer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lb_virtual_server']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_load_balancer_virtual_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lb_virtual_server' is set
        if ('lb_virtual_server' not in params or
                params['lb_virtual_server'] is None):
            raise ValueError("Missing the required parameter `lb_virtual_server` when calling `create_load_balancer_virtual_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'lb_virtual_server' in params:
            body_params = params['lb_virtual_server']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/virtual-servers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbVirtualServer',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_metadata_proxy(self, metadata_proxy, **kwargs):  # noqa: E501
        """Create a metadata proxy  # noqa: E501

        Create a metadata proxy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_metadata_proxy(metadata_proxy, async=True)
        >>> result = thread.get()

        :param async bool
        :param MetadataProxy metadata_proxy: (required)
        :return: MetadataProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_metadata_proxy_with_http_info(metadata_proxy, **kwargs)  # noqa: E501
        else:
            (data) = self.create_metadata_proxy_with_http_info(metadata_proxy, **kwargs)  # noqa: E501
            return data

    def create_metadata_proxy_with_http_info(self, metadata_proxy, **kwargs):  # noqa: E501
        """Create a metadata proxy  # noqa: E501

        Create a metadata proxy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_metadata_proxy_with_http_info(metadata_proxy, async=True)
        >>> result = thread.get()

        :param async bool
        :param MetadataProxy metadata_proxy: (required)
        :return: MetadataProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['metadata_proxy']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_metadata_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'metadata_proxy' is set
        if ('metadata_proxy' not in params or
                params['metadata_proxy'] is None):
            raise ValueError("Missing the required parameter `metadata_proxy` when calling `create_metadata_proxy`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'metadata_proxy' in params:
            body_params = params['metadata_proxy']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/md-proxies', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MetadataProxy',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dhcp_ip_pool(self, server_id, pool_id, **kwargs):  # noqa: E501
        """Delete a DHCP server&#39;s IP pool  # noqa: E501

        Delete a DHCP server's IP pool  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dhcp_ip_pool(server_id, pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param str pool_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_dhcp_ip_pool_with_http_info(server_id, pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dhcp_ip_pool_with_http_info(server_id, pool_id, **kwargs)  # noqa: E501
            return data

    def delete_dhcp_ip_pool_with_http_info(self, server_id, pool_id, **kwargs):  # noqa: E501
        """Delete a DHCP server&#39;s IP pool  # noqa: E501

        Delete a DHCP server's IP pool  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dhcp_ip_pool_with_http_info(server_id, pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param str pool_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'pool_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dhcp_ip_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `delete_dhcp_ip_pool`")  # noqa: E501
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `delete_dhcp_ip_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ip-pools/{pool-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dhcp_profile(self, profile_id, **kwargs):  # noqa: E501
        """Delete a DHCP server profile  # noqa: E501

        Delete a DHCP server profile  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dhcp_profile(profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_dhcp_profile_with_http_info(profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dhcp_profile_with_http_info(profile_id, **kwargs)  # noqa: E501
            return data

    def delete_dhcp_profile_with_http_info(self, profile_id, **kwargs):  # noqa: E501
        """Delete a DHCP server profile  # noqa: E501

        Delete a DHCP server profile  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dhcp_profile_with_http_info(profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dhcp_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'profile_id' is set
        if ('profile_id' not in params or
                params['profile_id'] is None):
            raise ValueError("Missing the required parameter `profile_id` when calling `delete_dhcp_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'profile_id' in params:
            path_params['profile-id'] = params['profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/server-profiles/{profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dhcp_server(self, server_id, **kwargs):  # noqa: E501
        """Delete a DHCP server  # noqa: E501

        Delete a DHCP server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dhcp_server(server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_dhcp_server_with_http_info(server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dhcp_server_with_http_info(server_id, **kwargs)  # noqa: E501
            return data

    def delete_dhcp_server_with_http_info(self, server_id, **kwargs):  # noqa: E501
        """Delete a DHCP server  # noqa: E501

        Delete a DHCP server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dhcp_server_with_http_info(server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dhcp_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `delete_dhcp_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dhcp_static_binding(self, server_id, binding_id, **kwargs):  # noqa: E501
        """Delete a static binding  # noqa: E501

        Delete a static binding  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dhcp_static_binding(server_id, binding_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param str binding_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_dhcp_static_binding_with_http_info(server_id, binding_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dhcp_static_binding_with_http_info(server_id, binding_id, **kwargs)  # noqa: E501
            return data

    def delete_dhcp_static_binding_with_http_info(self, server_id, binding_id, **kwargs):  # noqa: E501
        """Delete a static binding  # noqa: E501

        Delete a static binding  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dhcp_static_binding_with_http_info(server_id, binding_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param str binding_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'binding_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dhcp_static_binding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `delete_dhcp_static_binding`")  # noqa: E501
        # verify the required parameter 'binding_id' is set
        if ('binding_id' not in params or
                params['binding_id'] is None):
            raise ValueError("Missing the required parameter `binding_id` when calling `delete_dhcp_static_binding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501
        if 'binding_id' in params:
            path_params['binding-id'] = params['binding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/static-bindings/{binding-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dne_key_manager(self, key_manager_id, **kwargs):  # noqa: E501
        """Delete an attached network encryption key manager  # noqa: E501

        Delete an attached network encryption key manager  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dne_key_manager(key_manager_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str key_manager_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_dne_key_manager_with_http_info(key_manager_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dne_key_manager_with_http_info(key_manager_id, **kwargs)  # noqa: E501
            return data

    def delete_dne_key_manager_with_http_info(self, key_manager_id, **kwargs):  # noqa: E501
        """Delete an attached network encryption key manager  # noqa: E501

        Delete an attached network encryption key manager  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dne_key_manager_with_http_info(key_manager_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str key_manager_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['key_manager_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dne_key_manager" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_manager_id' is set
        if ('key_manager_id' not in params or
                params['key_manager_id'] is None):
            raise ValueError("Missing the required parameter `key_manager_id` when calling `delete_dne_key_manager`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'key_manager_id' in params:
            path_params['key-manager-id'] = params['key_manager_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/key-managers/{key-manager-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dne_key_policy(self, key_policy_id, **kwargs):  # noqa: E501
        """Delete a specific network encryption key policy  # noqa: E501

        Delete a specific network encryption key policy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dne_key_policy(key_policy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str key_policy_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_dne_key_policy_with_http_info(key_policy_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dne_key_policy_with_http_info(key_policy_id, **kwargs)  # noqa: E501
            return data

    def delete_dne_key_policy_with_http_info(self, key_policy_id, **kwargs):  # noqa: E501
        """Delete a specific network encryption key policy  # noqa: E501

        Delete a specific network encryption key policy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dne_key_policy_with_http_info(key_policy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str key_policy_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['key_policy_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dne_key_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_policy_id' is set
        if ('key_policy_id' not in params or
                params['key_policy_id'] is None):
            raise ValueError("Missing the required parameter `key_policy_id` when calling `delete_dne_key_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'key_policy_id' in params:
            path_params['key-policy-id'] = params['key_policy_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/key-policies/{key-policy-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dne_rule(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Delete a specific network encryption rule  # noqa: E501

        Delete a specific network encryption rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dne_rule(section_id, rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_dne_rule_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dne_rule_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
            return data

    def delete_dne_rule_with_http_info(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Delete a specific network encryption rule  # noqa: E501

        Delete a specific network encryption rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dne_rule_with_http_info(section_id, rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'rule_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dne_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `delete_dne_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `delete_dne_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/sections/{section-id}/rules/{rule-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dne_section(self, section_id, operation, **kwargs):  # noqa: E501
        """Delete a network encryption section and its rules  # noqa: E501

        Delete a network encryption section and its rules  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dne_section(section_id, operation, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str operation: Operation (required)
        :param bool cascade: Flag to cascade delete of this object to all it's child objects.
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_dne_section_with_http_info(section_id, operation, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dne_section_with_http_info(section_id, operation, **kwargs)  # noqa: E501
            return data

    def delete_dne_section_with_http_info(self, section_id, operation, **kwargs):  # noqa: E501
        """Delete a network encryption section and its rules  # noqa: E501

        Delete a network encryption section and its rules  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_dne_section_with_http_info(section_id, operation, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str operation: Operation (required)
        :param bool cascade: Flag to cascade delete of this object to all it's child objects.
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'operation', 'cascade', 'id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dne_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `delete_dne_section`")  # noqa: E501
        # verify the required parameter 'operation' is set
        if ('operation' not in params or
                params['operation'] is None):
            raise ValueError("Missing the required parameter `operation` when calling `delete_dne_section`")  # noqa: E501

        if ('id' in params and
                len(params['id']) > 64):
            raise ValueError("Invalid value for parameter `id` when calling `delete_dne_section`, length must be less than or equal to `64`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'cascade' in params:
            query_params.append(('cascade', params['cascade']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/sections/{section-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_load_balancer_application_profile(self, application_profile_id, **kwargs):  # noqa: E501
        """Delete a load balancer application profile  # noqa: E501

        Delete a load balancer application profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_load_balancer_application_profile(application_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str application_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_load_balancer_application_profile_with_http_info(application_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_load_balancer_application_profile_with_http_info(application_profile_id, **kwargs)  # noqa: E501
            return data

    def delete_load_balancer_application_profile_with_http_info(self, application_profile_id, **kwargs):  # noqa: E501
        """Delete a load balancer application profile  # noqa: E501

        Delete a load balancer application profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_load_balancer_application_profile_with_http_info(application_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str application_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_load_balancer_application_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_profile_id' is set
        if ('application_profile_id' not in params or
                params['application_profile_id'] is None):
            raise ValueError("Missing the required parameter `application_profile_id` when calling `delete_load_balancer_application_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_profile_id' in params:
            path_params['application-profile-id'] = params['application_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/application-profiles/{application-profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_load_balancer_client_ssl_profile(self, client_ssl_profile_id, **kwargs):  # noqa: E501
        """Delete a load balancer client-ssl profile  # noqa: E501

        Delete a load balancer client-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_load_balancer_client_ssl_profile(client_ssl_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str client_ssl_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, **kwargs)  # noqa: E501
            return data

    def delete_load_balancer_client_ssl_profile_with_http_info(self, client_ssl_profile_id, **kwargs):  # noqa: E501
        """Delete a load balancer client-ssl profile  # noqa: E501

        Delete a load balancer client-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str client_ssl_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_ssl_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_load_balancer_client_ssl_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_ssl_profile_id' is set
        if ('client_ssl_profile_id' not in params or
                params['client_ssl_profile_id'] is None):
            raise ValueError("Missing the required parameter `client_ssl_profile_id` when calling `delete_load_balancer_client_ssl_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_ssl_profile_id' in params:
            path_params['client-ssl-profile-id'] = params['client_ssl_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/client-ssl-profiles/{client-ssl-profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_load_balancer_monitor(self, monitor_id, **kwargs):  # noqa: E501
        """Delete a load balancer monitor  # noqa: E501

        Delete a load balancer monitor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_load_balancer_monitor(monitor_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str monitor_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_load_balancer_monitor_with_http_info(monitor_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_load_balancer_monitor_with_http_info(monitor_id, **kwargs)  # noqa: E501
            return data

    def delete_load_balancer_monitor_with_http_info(self, monitor_id, **kwargs):  # noqa: E501
        """Delete a load balancer monitor  # noqa: E501

        Delete a load balancer monitor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_load_balancer_monitor_with_http_info(monitor_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str monitor_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['monitor_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_load_balancer_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'monitor_id' is set
        if ('monitor_id' not in params or
                params['monitor_id'] is None):
            raise ValueError("Missing the required parameter `monitor_id` when calling `delete_load_balancer_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'monitor_id' in params:
            path_params['monitor-id'] = params['monitor_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/monitors/{monitor-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_load_balancer_persistence_profile(self, persistence_profile_id, **kwargs):  # noqa: E501
        """Delete a load balancer persistence profile  # noqa: E501

        Delete a load balancer persistence profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_load_balancer_persistence_profile(persistence_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str persistence_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_load_balancer_persistence_profile_with_http_info(persistence_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_load_balancer_persistence_profile_with_http_info(persistence_profile_id, **kwargs)  # noqa: E501
            return data

    def delete_load_balancer_persistence_profile_with_http_info(self, persistence_profile_id, **kwargs):  # noqa: E501
        """Delete a load balancer persistence profile  # noqa: E501

        Delete a load balancer persistence profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_load_balancer_persistence_profile_with_http_info(persistence_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str persistence_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['persistence_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_load_balancer_persistence_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'persistence_profile_id' is set
        if ('persistence_profile_id' not in params or
                params['persistence_profile_id'] is None):
            raise ValueError("Missing the required parameter `persistence_profile_id` when calling `delete_load_balancer_persistence_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'persistence_profile_id' in params:
            path_params['persistence-profile-id'] = params['persistence_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/persistence-profiles/{persistence-profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_load_balancer_pool(self, pool_id, **kwargs):  # noqa: E501
        """Delete a load balancer pool  # noqa: E501

        Delete a load balancer pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_load_balancer_pool(pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_load_balancer_pool_with_http_info(pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_load_balancer_pool_with_http_info(pool_id, **kwargs)  # noqa: E501
            return data

    def delete_load_balancer_pool_with_http_info(self, pool_id, **kwargs):  # noqa: E501
        """Delete a load balancer pool  # noqa: E501

        Delete a load balancer pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_load_balancer_pool_with_http_info(pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pool_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_load_balancer_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `delete_load_balancer_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/pools/{pool-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_load_balancer_rule(self, rule_id, **kwargs):  # noqa: E501
        """Delete a load balancer rule  # noqa: E501

        Delete a load balancer rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_load_balancer_rule(rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rule_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_load_balancer_rule_with_http_info(rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_load_balancer_rule_with_http_info(rule_id, **kwargs)  # noqa: E501
            return data

    def delete_load_balancer_rule_with_http_info(self, rule_id, **kwargs):  # noqa: E501
        """Delete a load balancer rule  # noqa: E501

        Delete a load balancer rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_load_balancer_rule_with_http_info(rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rule_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_load_balancer_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `delete_load_balancer_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/rules/{rule-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_load_balancer_server_ssl_profile(self, server_ssl_profile_id, **kwargs):  # noqa: E501
        """Delete a load balancer server-ssl profile  # noqa: E501

        Delete a load balancer server-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_load_balancer_server_ssl_profile(server_ssl_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_ssl_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, **kwargs)  # noqa: E501
            return data

    def delete_load_balancer_server_ssl_profile_with_http_info(self, server_ssl_profile_id, **kwargs):  # noqa: E501
        """Delete a load balancer server-ssl profile  # noqa: E501

        Delete a load balancer server-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_ssl_profile_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_ssl_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_load_balancer_server_ssl_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_ssl_profile_id' is set
        if ('server_ssl_profile_id' not in params or
                params['server_ssl_profile_id'] is None):
            raise ValueError("Missing the required parameter `server_ssl_profile_id` when calling `delete_load_balancer_server_ssl_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_ssl_profile_id' in params:
            path_params['server-ssl-profile-id'] = params['server_ssl_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/server-ssl-profiles/{server-ssl-profile-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_load_balancer_service(self, service_id, **kwargs):  # noqa: E501
        """Delete a load balancer service  # noqa: E501

        Delete a load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_load_balancer_service(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_load_balancer_service_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_load_balancer_service_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def delete_load_balancer_service_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Delete a load balancer service  # noqa: E501

        Delete a load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_load_balancer_service_with_http_info(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_load_balancer_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `delete_load_balancer_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_load_balancer_virtual_server(self, virtual_server_id, **kwargs):  # noqa: E501
        """Delete a load balancer virtual server  # noqa: E501

        Delete a load balancer virtual server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_load_balancer_virtual_server(virtual_server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str virtual_server_id: (required)
        :param bool delete_associated_rules: Delete associated rules
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_load_balancer_virtual_server_with_http_info(virtual_server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_load_balancer_virtual_server_with_http_info(virtual_server_id, **kwargs)  # noqa: E501
            return data

    def delete_load_balancer_virtual_server_with_http_info(self, virtual_server_id, **kwargs):  # noqa: E501
        """Delete a load balancer virtual server  # noqa: E501

        Delete a load balancer virtual server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_load_balancer_virtual_server_with_http_info(virtual_server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str virtual_server_id: (required)
        :param bool delete_associated_rules: Delete associated rules
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['virtual_server_id', 'delete_associated_rules']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_load_balancer_virtual_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'virtual_server_id' is set
        if ('virtual_server_id' not in params or
                params['virtual_server_id'] is None):
            raise ValueError("Missing the required parameter `virtual_server_id` when calling `delete_load_balancer_virtual_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'virtual_server_id' in params:
            path_params['virtual-server-id'] = params['virtual_server_id']  # noqa: E501

        query_params = []
        if 'delete_associated_rules' in params:
            query_params.append(('delete_associated_rules', params['delete_associated_rules']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/virtual-servers/{virtual-server-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_metadata_proxy(self, proxy_id, **kwargs):  # noqa: E501
        """Delete a metadata proxy  # noqa: E501

        Delete a metadata proxy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_metadata_proxy(proxy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str proxy_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_metadata_proxy_with_http_info(proxy_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_metadata_proxy_with_http_info(proxy_id, **kwargs)  # noqa: E501
            return data

    def delete_metadata_proxy_with_http_info(self, proxy_id, **kwargs):  # noqa: E501
        """Delete a metadata proxy  # noqa: E501

        Delete a metadata proxy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_metadata_proxy_with_http_info(proxy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str proxy_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proxy_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_metadata_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proxy_id' is set
        if ('proxy_id' not in params or
                params['proxy_id'] is None):
            raise ValueError("Missing the required parameter `proxy_id` when calling `delete_metadata_proxy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proxy_id' in params:
            path_params['proxy-id'] = params['proxy_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/md-proxies/{proxy-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_rule(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Delete an Existing Rule  # noqa: E501

        Delete existing firewall rule in a firewall section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_rule(section_id, rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_rule_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_rule_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
            return data

    def delete_rule_with_http_info(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Delete an Existing Rule  # noqa: E501

        Delete existing firewall rule in a firewall section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_rule_with_http_info(section_id, rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'rule_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `delete_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `delete_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}/rules/{rule-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_section(self, section_id, **kwargs):  # noqa: E501
        """Delete an Existing Section and Its Associated Rules  # noqa: E501

        Removes firewall section from the system. Firewall section with rules can only be deleted by passing \"cascade=true\" parameter.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_section(section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param bool cascade: Flag to cascade delete of this object to all it's child objects.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_section_with_http_info(section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_section_with_http_info(section_id, **kwargs)  # noqa: E501
            return data

    def delete_section_with_http_info(self, section_id, **kwargs):  # noqa: E501
        """Delete an Existing Section and Its Associated Rules  # noqa: E501

        Removes firewall section from the system. Firewall section with rules can only be deleted by passing \"cascade=true\" parameter.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_section_with_http_info(section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param bool cascade: Flag to cascade delete of this object to all it's child objects.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'cascade']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `delete_section`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'cascade' in params:
            query_params.append(('cascade', params['cascade']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dhcp_lease_info(self, server_id, **kwargs):  # noqa: E501
        """Get lease info of a given dhcp server id  # noqa: E501

        Get lease info of a given dhcp server id. If a \"pool_id\" is specified, the lease info of the pool are returned. If an \"address\" is specified, only the lease info the this address is returned. The \"address\" can be a single IP, an ip-range, or a mac address. \"pool_id\" and \"address\" are mutually excluded. Either a \"pool_id\" or an \"address\" can be provided, but not both.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dhcp_lease_info(server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param str address: can be an ip address, or an ip range, or a mac address
        :param str pool_id: The uuid of dhcp ip pool
        :param str source: Data source type.
        :return: DhcpLeases
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_dhcp_lease_info_with_http_info(server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dhcp_lease_info_with_http_info(server_id, **kwargs)  # noqa: E501
            return data

    def get_dhcp_lease_info_with_http_info(self, server_id, **kwargs):  # noqa: E501
        """Get lease info of a given dhcp server id  # noqa: E501

        Get lease info of a given dhcp server id. If a \"pool_id\" is specified, the lease info of the pool are returned. If an \"address\" is specified, only the lease info the this address is returned. The \"address\" can be a single IP, an ip-range, or a mac address. \"pool_id\" and \"address\" are mutually excluded. Either a \"pool_id\" or an \"address\" can be provided, but not both.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dhcp_lease_info_with_http_info(server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param str address: can be an ip address, or an ip range, or a mac address
        :param str pool_id: The uuid of dhcp ip pool
        :param str source: Data source type.
        :return: DhcpLeases
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'address', 'pool_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dhcp_lease_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `get_dhcp_lease_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []
        if 'address' in params:
            query_params.append(('address', params['address']))  # noqa: E501
        if 'pool_id' in params:
            query_params.append(('pool_id', params['pool_id']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/leases', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpLeases',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dhcp_statistics(self, server_id, **kwargs):  # noqa: E501
        """Get DHCP statistics with given dhcp server id  # noqa: E501

        Returns the statistics of the given dhcp server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dhcp_statistics(server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :return: DhcpStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_dhcp_statistics_with_http_info(server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dhcp_statistics_with_http_info(server_id, **kwargs)  # noqa: E501
            return data

    def get_dhcp_statistics_with_http_info(self, server_id, **kwargs):  # noqa: E501
        """Get DHCP statistics with given dhcp server id  # noqa: E501

        Returns the statistics of the given dhcp server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dhcp_statistics_with_http_info(server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :return: DhcpStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dhcp_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `get_dhcp_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpStatistics',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dhcp_status(self, server_id, **kwargs):  # noqa: E501
        """Get DHCP service status with given dhcp server id  # noqa: E501

        Returns the service status of the given dhcp server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dhcp_status(server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :return: DhcpServerStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_dhcp_status_with_http_info(server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dhcp_status_with_http_info(server_id, **kwargs)  # noqa: E501
            return data

    def get_dhcp_status_with_http_info(self, server_id, **kwargs):  # noqa: E501
        """Get DHCP service status with given dhcp server id  # noqa: E501

        Returns the service status of the given dhcp server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dhcp_status_with_http_info(server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :return: DhcpServerStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dhcp_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `get_dhcp_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpServerStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dne_global_config(self, **kwargs):  # noqa: E501
        """Get the global configuration of network encryption service  # noqa: E501

        Get the global configuration of network encryption service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_global_config(async=True)
        >>> result = thread.get()

        :param async bool
        :return: DneGlobalConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_dne_global_config_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_dne_global_config_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_dne_global_config_with_http_info(self, **kwargs):  # noqa: E501
        """Get the global configuration of network encryption service  # noqa: E501

        Get the global configuration of network encryption service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_global_config_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: DneGlobalConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dne_global_config" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneGlobalConfig',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dne_key_manager(self, key_manager_id, **kwargs):  # noqa: E501
        """Get configuration for a specific network encryption key manager  # noqa: E501

        Get configuration for a specific network encryption key manager  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_key_manager(key_manager_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str key_manager_id: (required)
        :return: DneKeyManager
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_dne_key_manager_with_http_info(key_manager_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dne_key_manager_with_http_info(key_manager_id, **kwargs)  # noqa: E501
            return data

    def get_dne_key_manager_with_http_info(self, key_manager_id, **kwargs):  # noqa: E501
        """Get configuration for a specific network encryption key manager  # noqa: E501

        Get configuration for a specific network encryption key manager  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_key_manager_with_http_info(key_manager_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str key_manager_id: (required)
        :return: DneKeyManager
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['key_manager_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dne_key_manager" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_manager_id' is set
        if ('key_manager_id' not in params or
                params['key_manager_id'] is None):
            raise ValueError("Missing the required parameter `key_manager_id` when calling `get_dne_key_manager`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'key_manager_id' in params:
            path_params['key-manager-id'] = params['key_manager_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/key-managers/{key-manager-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneKeyManager',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dne_key_policy(self, key_policy_id, **kwargs):  # noqa: E501
        """Get a specific network encryption key policy  # noqa: E501

        Get a specific network encryption key policy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_key_policy(key_policy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str key_policy_id: (required)
        :return: DneKeyPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_dne_key_policy_with_http_info(key_policy_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dne_key_policy_with_http_info(key_policy_id, **kwargs)  # noqa: E501
            return data

    def get_dne_key_policy_with_http_info(self, key_policy_id, **kwargs):  # noqa: E501
        """Get a specific network encryption key policy  # noqa: E501

        Get a specific network encryption key policy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_key_policy_with_http_info(key_policy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str key_policy_id: (required)
        :return: DneKeyPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['key_policy_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dne_key_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_policy_id' is set
        if ('key_policy_id' not in params or
                params['key_policy_id'] is None):
            raise ValueError("Missing the required parameter `key_policy_id` when calling `get_dne_key_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'key_policy_id' in params:
            path_params['key-policy-id'] = params['key_policy_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/key-policies/{key-policy-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneKeyPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dne_key_policy_stats(self, key_policy_id, **kwargs):  # noqa: E501
        """Get the statistics for a network encryption key policy  # noqa: E501

        Get the statistics for a network encryption key policy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_key_policy_stats(key_policy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str key_policy_id: (required)
        :param str source: Data source type.
        :return: DneKeyPolicyStats
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_dne_key_policy_stats_with_http_info(key_policy_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dne_key_policy_stats_with_http_info(key_policy_id, **kwargs)  # noqa: E501
            return data

    def get_dne_key_policy_stats_with_http_info(self, key_policy_id, **kwargs):  # noqa: E501
        """Get the statistics for a network encryption key policy  # noqa: E501

        Get the statistics for a network encryption key policy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_key_policy_stats_with_http_info(key_policy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str key_policy_id: (required)
        :param str source: Data source type.
        :return: DneKeyPolicyStats
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['key_policy_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dne_key_policy_stats" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_policy_id' is set
        if ('key_policy_id' not in params or
                params['key_policy_id'] is None):
            raise ValueError("Missing the required parameter `key_policy_id` when calling `get_dne_key_policy_stats`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'key_policy_id' in params:
            path_params['key-policy-id'] = params['key_policy_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/key-policies/{key-policy-id}/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneKeyPolicyStats',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dne_rule(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Get a specific rule in a network encryption section  # noqa: E501

        Get a specific rule in a network encryption section  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_rule(section_id, rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :return: DneRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_dne_rule_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dne_rule_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
            return data

    def get_dne_rule_with_http_info(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Get a specific rule in a network encryption section  # noqa: E501

        Get a specific rule in a network encryption section  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_rule_with_http_info(section_id, rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :return: DneRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'rule_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dne_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_dne_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `get_dne_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/sections/{section-id}/rules/{rule-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneRule',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dne_rule_state(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Get the realized State of a network encryption rule  # noqa: E501

        Get the realized State of a network encryption rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_rule_state(section_id, rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :param int barrier_id:
        :return: DneRuleState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_dne_rule_state_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dne_rule_state_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
            return data

    def get_dne_rule_state_with_http_info(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Get the realized State of a network encryption rule  # noqa: E501

        Get the realized State of a network encryption rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_rule_state_with_http_info(section_id, rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :param int barrier_id:
        :return: DneRuleState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'rule_id', 'barrier_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dne_rule_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_dne_rule_state`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `get_dne_rule_state`")  # noqa: E501

        if 'barrier_id' in params and params['barrier_id'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `barrier_id` when calling `get_dne_rule_state`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []
        if 'barrier_id' in params:
            query_params.append(('barrier_id', params['barrier_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/sections/{section-id}/rules/{rule-id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneRuleState',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dne_rule_stats(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Get the statistics for a network encryption rule  # noqa: E501

        Get the statistics for a network encryption rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_rule_stats(section_id, rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :param str source: Data source type.
        :return: DneRuleStats
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_dne_rule_stats_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dne_rule_stats_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
            return data

    def get_dne_rule_stats_with_http_info(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Get the statistics for a network encryption rule  # noqa: E501

        Get the statistics for a network encryption rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_rule_stats_with_http_info(section_id, rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :param str source: Data source type.
        :return: DneRuleStats
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'rule_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dne_rule_stats" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_dne_rule_stats`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `get_dne_rule_stats`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/sections/{section-id}/rules/{rule-id}/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneRuleStats',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dne_rules(self, section_id, **kwargs):  # noqa: E501
        """Get the rules of a network encryption section  # noqa: E501

        Get the rules of a network encryption section  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_rules(section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str applied_tos: AppliedTo's  referenced by this section or section's DNE Rules .
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str destinations: Destinations referenced by this section's DNE Rules .
        :param str filter_type: Filter type
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str key_policy_id: key policy identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str services: NSService referenced by this section's DNE Rules .
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str sources: Sources referenced by this section's DNE Rules .
        :return: DneRuleListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_dne_rules_with_http_info(section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dne_rules_with_http_info(section_id, **kwargs)  # noqa: E501
            return data

    def get_dne_rules_with_http_info(self, section_id, **kwargs):  # noqa: E501
        """Get the rules of a network encryption section  # noqa: E501

        Get the rules of a network encryption section  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_rules_with_http_info(section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str applied_tos: AppliedTo's  referenced by this section or section's DNE Rules .
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str destinations: Destinations referenced by this section's DNE Rules .
        :param str filter_type: Filter type
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str key_policy_id: key policy identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str services: NSService referenced by this section's DNE Rules .
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str sources: Sources referenced by this section's DNE Rules .
        :return: DneRuleListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'applied_tos', 'cursor', 'destinations', 'filter_type', 'included_fields', 'key_policy_id', 'page_size', 'services', 'sort_ascending', 'sort_by', 'sources']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dne_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_dne_rules`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_dne_rules`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_dne_rules`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'applied_tos' in params:
            query_params.append(('applied_tos', params['applied_tos']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'destinations' in params:
            query_params.append(('destinations', params['destinations']))  # noqa: E501
        if 'filter_type' in params:
            query_params.append(('filter_type', params['filter_type']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'key_policy_id' in params:
            query_params.append(('key_policy_id', params['key_policy_id']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'services' in params:
            query_params.append(('services', params['services']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'sources' in params:
            query_params.append(('sources', params['sources']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/sections/{section-id}/rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneRuleListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dne_rules_by_key_policy(self, keypolicy_id, **kwargs):  # noqa: E501
        """Get all network encryption rules attached to a specific key policy  # noqa: E501

        Get all network encryption rules attached to a specific key policy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_rules_by_key_policy(keypolicy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str keypolicy_id: (required)
        :param str applied_tos: AppliedTo's  referenced by this section or section's DNE Rules .
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str destinations: Destinations referenced by this section's DNE Rules .
        :param str filter_type: Filter type
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str key_policy_id: key policy identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str services: NSService referenced by this section's DNE Rules .
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str sources: Sources referenced by this section's DNE Rules .
        :return: DneRuleListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_dne_rules_by_key_policy_with_http_info(keypolicy_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dne_rules_by_key_policy_with_http_info(keypolicy_id, **kwargs)  # noqa: E501
            return data

    def get_dne_rules_by_key_policy_with_http_info(self, keypolicy_id, **kwargs):  # noqa: E501
        """Get all network encryption rules attached to a specific key policy  # noqa: E501

        Get all network encryption rules attached to a specific key policy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_rules_by_key_policy_with_http_info(keypolicy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str keypolicy_id: (required)
        :param str applied_tos: AppliedTo's  referenced by this section or section's DNE Rules .
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str destinations: Destinations referenced by this section's DNE Rules .
        :param str filter_type: Filter type
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str key_policy_id: key policy identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str services: NSService referenced by this section's DNE Rules .
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str sources: Sources referenced by this section's DNE Rules .
        :return: DneRuleListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['keypolicy_id', 'applied_tos', 'cursor', 'destinations', 'filter_type', 'included_fields', 'key_policy_id', 'page_size', 'services', 'sort_ascending', 'sort_by', 'sources']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dne_rules_by_key_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'keypolicy_id' is set
        if ('keypolicy_id' not in params or
                params['keypolicy_id'] is None):
            raise ValueError("Missing the required parameter `keypolicy_id` when calling `get_dne_rules_by_key_policy`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_dne_rules_by_key_policy`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_dne_rules_by_key_policy`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'keypolicy_id' in params:
            path_params['keypolicy-id'] = params['keypolicy_id']  # noqa: E501

        query_params = []
        if 'applied_tos' in params:
            query_params.append(('applied_tos', params['applied_tos']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'destinations' in params:
            query_params.append(('destinations', params['destinations']))  # noqa: E501
        if 'filter_type' in params:
            query_params.append(('filter_type', params['filter_type']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'key_policy_id' in params:
            query_params.append(('key_policy_id', params['key_policy_id']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'services' in params:
            query_params.append(('services', params['services']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'sources' in params:
            query_params.append(('sources', params['sources']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/key-policies/{keypolicy-id}/rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneRuleListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dne_section(self, section_id, **kwargs):  # noqa: E501
        """Get a specific network encryption section  # noqa: E501

        Get a specific network encryption section  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_section(section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :return: DneSection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_dne_section_with_http_info(section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dne_section_with_http_info(section_id, **kwargs)  # noqa: E501
            return data

    def get_dne_section_with_http_info(self, section_id, **kwargs):  # noqa: E501
        """Get a specific network encryption section  # noqa: E501

        Get a specific network encryption section  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_section_with_http_info(section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :return: DneSection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dne_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_dne_section`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/sections/{section-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneSection',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dne_section_state(self, section_id, **kwargs):  # noqa: E501
        """Get the realized state of a network encryption section  # noqa: E501

        Get the realized state of a network encryption section  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_section_state(section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param int barrier_id:
        :return: DneSectionState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_dne_section_state_with_http_info(section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dne_section_state_with_http_info(section_id, **kwargs)  # noqa: E501
            return data

    def get_dne_section_state_with_http_info(self, section_id, **kwargs):  # noqa: E501
        """Get the realized state of a network encryption section  # noqa: E501

        Get the realized state of a network encryption section  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_section_state_with_http_info(section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param int barrier_id:
        :return: DneSectionState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'barrier_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dne_section_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_dne_section_state`")  # noqa: E501

        if 'barrier_id' in params and params['barrier_id'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `barrier_id` when calling `get_dne_section_state`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'barrier_id' in params:
            query_params.append(('barrier_id', params['barrier_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/sections/{section-id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneSectionState',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dne_section_with_rules_list_with_rules(self, section_id, **kwargs):  # noqa: E501
        """Get a specific network encryption section and its rules  # noqa: E501

        When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules with a large number rule references is not supported.  Instead, to get network encryption rules, use: GET /api/v1/network-encryption/sections/&lt;section-id&gt;/rules with the appropriate page size.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_section_with_rules_list_with_rules(section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :return: DneSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_dne_section_with_rules_list_with_rules_with_http_info(section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dne_section_with_rules_list_with_rules_with_http_info(section_id, **kwargs)  # noqa: E501
            return data

    def get_dne_section_with_rules_list_with_rules_with_http_info(self, section_id, **kwargs):  # noqa: E501
        """Get a specific network encryption section and its rules  # noqa: E501

        When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules with a large number rule references is not supported.  Instead, to get network encryption rules, use: GET /api/v1/network-encryption/sections/&lt;section-id&gt;/rules with the appropriate page size.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_dne_section_with_rules_list_with_rules_with_http_info(section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :return: DneSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dne_section_with_rules_list_with_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_dne_section_with_rules_list_with_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/sections/{section-id}?action=list_with_rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneSectionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_exclude_list(self, **kwargs):  # noqa: E501
        """Get list of entities in exclude list  # noqa: E501

        Get list of entities in exclude list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_exclude_list(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ExcludeList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_exclude_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_exclude_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_exclude_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get list of entities in exclude list  # noqa: E501

        Get list of entities in exclude list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_exclude_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ExcludeList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_exclude_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/excludelist', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExcludeList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_firewall_section_stats(self, section_id, **kwargs):  # noqa: E501
        """Get Firewall section level statistics section  # noqa: E501

        Get aggregated statistics for all rules for a given firewall section. The API only supports access to cached (source=cached) statistical data collected offline in the system. Data includes total number of packets, bytes and sessions counters for a firewall rule and overall session count for all firewall rules on transport nodes or edge nodes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_firewall_section_stats(section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str source: Data source type.
        :return: FirewallStatsList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_firewall_section_stats_with_http_info(section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_firewall_section_stats_with_http_info(section_id, **kwargs)  # noqa: E501
            return data

    def get_firewall_section_stats_with_http_info(self, section_id, **kwargs):  # noqa: E501
        """Get Firewall section level statistics section  # noqa: E501

        Get aggregated statistics for all rules for a given firewall section. The API only supports access to cached (source=cached) statistical data collected offline in the system. Data includes total number of packets, bytes and sessions counters for a firewall rule and overall session count for all firewall rules on transport nodes or edge nodes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_firewall_section_stats_with_http_info(section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str source: Data source type.
        :return: FirewallStatsList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_firewall_section_stats" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_firewall_section_stats`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}/rules/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallStatsList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_firewall_stats(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Get Firewall rule level statistics  # noqa: E501

        Get aggregated statistics for a rule for given firewall section. The API only supports access to cached (source=cached) statistical data collected offline in the system. Data includes total number of packets, bytes and sessions counters for a firewall rule and overall session count for all firewall rules on transport nodes or edge nodes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_firewall_stats(section_id, rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :param str source: Data source type.
        :return: FirewallStats
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_firewall_stats_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_firewall_stats_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
            return data

    def get_firewall_stats_with_http_info(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Get Firewall rule level statistics  # noqa: E501

        Get aggregated statistics for a rule for given firewall section. The API only supports access to cached (source=cached) statistical data collected offline in the system. Data includes total number of packets, bytes and sessions counters for a firewall rule and overall session count for all firewall rules on transport nodes or edge nodes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_firewall_stats_with_http_info(section_id, rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :param str source: Data source type.
        :return: FirewallStats
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'rule_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_firewall_stats" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_firewall_stats`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `get_firewall_stats`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}/rules/{rule-id}/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallStats',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_firewall_status(self, context_type, **kwargs):  # noqa: E501
        """Get firewall global status for dfw context  # noqa: E501

        Get firewall global status for dfw context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_firewall_status(context_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str context_type: (required)
        :return: FirewallStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_firewall_status_with_http_info(context_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_firewall_status_with_http_info(context_type, **kwargs)  # noqa: E501
            return data

    def get_firewall_status_with_http_info(self, context_type, **kwargs):  # noqa: E501
        """Get firewall global status for dfw context  # noqa: E501

        Get firewall global status for dfw context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_firewall_status_with_http_info(context_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str context_type: (required)
        :return: FirewallStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['context_type']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_firewall_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'context_type' is set
        if ('context_type' not in params or
                params['context_type'] is None):
            raise ValueError("Missing the required parameter `context_type` when calling `get_firewall_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'context_type' in params:
            path_params['context-type'] = params['context_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/status/{context-type}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_load_balancer_pool_statistics(self, service_id, pool_id, **kwargs):  # noqa: E501
        """Get the statistics of load balancer pool  # noqa: E501

        Returns the statistics of the given load balancer pool by given load balancer serives id and load balancer pool id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_load_balancer_pool_statistics(service_id, pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param str pool_id: (required)
        :param str source: Data source type.
        :return: LbPoolStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_load_balancer_pool_statistics_with_http_info(service_id, pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_load_balancer_pool_statistics_with_http_info(service_id, pool_id, **kwargs)  # noqa: E501
            return data

    def get_load_balancer_pool_statistics_with_http_info(self, service_id, pool_id, **kwargs):  # noqa: E501
        """Get the statistics of load balancer pool  # noqa: E501

        Returns the statistics of the given load balancer pool by given load balancer serives id and load balancer pool id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_load_balancer_pool_statistics_with_http_info(service_id, pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param str pool_id: (required)
        :param str source: Data source type.
        :return: LbPoolStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'pool_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_load_balancer_pool_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_load_balancer_pool_statistics`")  # noqa: E501
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `get_load_balancer_pool_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/pools/{pool-id}/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPoolStatistics',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_load_balancer_pool_status(self, service_id, pool_id, **kwargs):  # noqa: E501
        """Get the status of load balancer pool  # noqa: E501

        Returns the status of the given load balancer pool by given load balancer serives id and load balancer pool id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_load_balancer_pool_status(service_id, pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param str pool_id: (required)
        :param str source: Data source type.
        :return: LbPoolStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_load_balancer_pool_status_with_http_info(service_id, pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_load_balancer_pool_status_with_http_info(service_id, pool_id, **kwargs)  # noqa: E501
            return data

    def get_load_balancer_pool_status_with_http_info(self, service_id, pool_id, **kwargs):  # noqa: E501
        """Get the status of load balancer pool  # noqa: E501

        Returns the status of the given load balancer pool by given load balancer serives id and load balancer pool id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_load_balancer_pool_status_with_http_info(service_id, pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param str pool_id: (required)
        :param str source: Data source type.
        :return: LbPoolStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'pool_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_load_balancer_pool_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_load_balancer_pool_status`")  # noqa: E501
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `get_load_balancer_pool_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/pools/{pool-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPoolStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_load_balancer_service_statistics(self, service_id, **kwargs):  # noqa: E501
        """Get the statistics of load balancer service  # noqa: E501

        Returns the statistics of the given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_load_balancer_service_statistics(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbServiceStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_load_balancer_service_statistics_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_load_balancer_service_statistics_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def get_load_balancer_service_statistics_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get the statistics of load balancer service  # noqa: E501

        Returns the statistics of the given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_load_balancer_service_statistics_with_http_info(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbServiceStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_load_balancer_service_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_load_balancer_service_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbServiceStatistics',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_load_balancer_service_status(self, service_id, **kwargs):  # noqa: E501
        """Get the status of the given load balancer service  # noqa: E501

        Returns the status of the given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_load_balancer_service_status(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbServiceStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_load_balancer_service_status_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_load_balancer_service_status_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def get_load_balancer_service_status_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get the status of the given load balancer service  # noqa: E501

        Returns the status of the given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_load_balancer_service_status_with_http_info(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbServiceStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_load_balancer_service_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_load_balancer_service_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbServiceStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_load_balancer_virtual_server_statistics(self, service_id, virtual_server_id, **kwargs):  # noqa: E501
        """Get the statistics of the given load balancer virtual server  # noqa: E501

        Returns the statistics of the load balancer virtual server by given load  balancer serives id and load balancer virtual server id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_load_balancer_virtual_server_statistics(service_id, virtual_server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param str virtual_server_id: (required)
        :param str source: Data source type.
        :return: LbVirtualServerStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_load_balancer_virtual_server_statistics_with_http_info(service_id, virtual_server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_load_balancer_virtual_server_statistics_with_http_info(service_id, virtual_server_id, **kwargs)  # noqa: E501
            return data

    def get_load_balancer_virtual_server_statistics_with_http_info(self, service_id, virtual_server_id, **kwargs):  # noqa: E501
        """Get the statistics of the given load balancer virtual server  # noqa: E501

        Returns the statistics of the load balancer virtual server by given load  balancer serives id and load balancer virtual server id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_load_balancer_virtual_server_statistics_with_http_info(service_id, virtual_server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param str virtual_server_id: (required)
        :param str source: Data source type.
        :return: LbVirtualServerStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'virtual_server_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_load_balancer_virtual_server_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_load_balancer_virtual_server_statistics`")  # noqa: E501
        # verify the required parameter 'virtual_server_id' is set
        if ('virtual_server_id' not in params or
                params['virtual_server_id'] is None):
            raise ValueError("Missing the required parameter `virtual_server_id` when calling `get_load_balancer_virtual_server_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'virtual_server_id' in params:
            path_params['virtual-server-id'] = params['virtual_server_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/virtual-servers/{virtual-server-id}/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbVirtualServerStatistics',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_load_balancer_virtual_server_status(self, service_id, virtual_server_id, **kwargs):  # noqa: E501
        """Get the status of the load balancer virtual server  # noqa: E501

        Returns the status of the virtual server by given load balancer serives id and load balancer virtual server id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_load_balancer_virtual_server_status(service_id, virtual_server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param str virtual_server_id: (required)
        :param str source: Data source type.
        :return: LbVirtualServerStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_load_balancer_virtual_server_status_with_http_info(service_id, virtual_server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_load_balancer_virtual_server_status_with_http_info(service_id, virtual_server_id, **kwargs)  # noqa: E501
            return data

    def get_load_balancer_virtual_server_status_with_http_info(self, service_id, virtual_server_id, **kwargs):  # noqa: E501
        """Get the status of the load balancer virtual server  # noqa: E501

        Returns the status of the virtual server by given load balancer serives id and load balancer virtual server id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_load_balancer_virtual_server_status_with_http_info(service_id, virtual_server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param str virtual_server_id: (required)
        :param str source: Data source type.
        :return: LbVirtualServerStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'virtual_server_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_load_balancer_virtual_server_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `get_load_balancer_virtual_server_status`")  # noqa: E501
        # verify the required parameter 'virtual_server_id' is set
        if ('virtual_server_id' not in params or
                params['virtual_server_id'] is None):
            raise ValueError("Missing the required parameter `virtual_server_id` when calling `get_load_balancer_virtual_server_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501
        if 'virtual_server_id' in params:
            path_params['virtual-server-id'] = params['virtual_server_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/virtual-servers/{virtual-server-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbVirtualServerStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_metadata_proxy_statistics(self, proxy_id, **kwargs):  # noqa: E501
        """Get Metadata Proxy statistics with given proxy id  # noqa: E501

        Returns the statistics of the given metatada proxy. If no logical switch is provided, all staticstics of all the logical switches the proxy was attached will be returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_metadata_proxy_statistics(proxy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str proxy_id: (required)
        :param str logical_switch_id: The uuid of logical switch
        :param str source: Data source type.
        :return: MetadataProxyStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_metadata_proxy_statistics_with_http_info(proxy_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_metadata_proxy_statistics_with_http_info(proxy_id, **kwargs)  # noqa: E501
            return data

    def get_metadata_proxy_statistics_with_http_info(self, proxy_id, **kwargs):  # noqa: E501
        """Get Metadata Proxy statistics with given proxy id  # noqa: E501

        Returns the statistics of the given metatada proxy. If no logical switch is provided, all staticstics of all the logical switches the proxy was attached will be returned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_metadata_proxy_statistics_with_http_info(proxy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str proxy_id: (required)
        :param str logical_switch_id: The uuid of logical switch
        :param str source: Data source type.
        :return: MetadataProxyStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proxy_id', 'logical_switch_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_metadata_proxy_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proxy_id' is set
        if ('proxy_id' not in params or
                params['proxy_id'] is None):
            raise ValueError("Missing the required parameter `proxy_id` when calling `get_metadata_proxy_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proxy_id' in params:
            path_params['proxy-id'] = params['proxy_id']  # noqa: E501

        query_params = []
        if 'logical_switch_id' in params:
            query_params.append(('logical_switch_id', params['logical_switch_id']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/md-proxies/{proxy-id}/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MetadataProxyStatistics',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_metadata_proxy_status(self, proxy_id, logical_switch_id, **kwargs):  # noqa: E501
        """Get Metadata Proxy status with given proxy id and attached logical switch.  # noqa: E501

        Returns the status of the given metadata proxy and attached logical switch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_metadata_proxy_status(proxy_id, logical_switch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str proxy_id: (required)
        :param str logical_switch_id: (required)
        :return: MetadataProxyStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_metadata_proxy_status_with_http_info(proxy_id, logical_switch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_metadata_proxy_status_with_http_info(proxy_id, logical_switch_id, **kwargs)  # noqa: E501
            return data

    def get_metadata_proxy_status_with_http_info(self, proxy_id, logical_switch_id, **kwargs):  # noqa: E501
        """Get Metadata Proxy status with given proxy id and attached logical switch.  # noqa: E501

        Returns the status of the given metadata proxy and attached logical switch.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_metadata_proxy_status_with_http_info(proxy_id, logical_switch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str proxy_id: (required)
        :param str logical_switch_id: (required)
        :return: MetadataProxyStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proxy_id', 'logical_switch_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_metadata_proxy_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proxy_id' is set
        if ('proxy_id' not in params or
                params['proxy_id'] is None):
            raise ValueError("Missing the required parameter `proxy_id` when calling `get_metadata_proxy_status`")  # noqa: E501
        # verify the required parameter 'logical_switch_id' is set
        if ('logical_switch_id' not in params or
                params['logical_switch_id'] is None):
            raise ValueError("Missing the required parameter `logical_switch_id` when calling `get_metadata_proxy_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proxy_id' in params:
            path_params['proxy-id'] = params['proxy_id']  # noqa: E501
        if 'logical_switch_id' in params:
            path_params['logical-switch-id'] = params['logical_switch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/md-proxies/{proxy-id}/{logical-switch-id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MetadataProxyStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_network_encryption_status(self, **kwargs):  # noqa: E501
        """Get the network encryption status for a given context  # noqa: E501

        Get the network encryption status for a given context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_network_encryption_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NetworkEncryptionStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_network_encryption_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_network_encryption_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_network_encryption_status_with_http_info(self, **kwargs):  # noqa: E501
        """Get the network encryption status for a given context  # noqa: E501

        Get the network encryption status for a given context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_network_encryption_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: NetworkEncryptionStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_network_encryption_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetworkEncryptionStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_rule(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Read an Existing Rule  # noqa: E501

        Return existing firewall rule information in a firewall section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_rule(section_id, rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :return: FirewallRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_rule_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_rule_with_http_info(section_id, rule_id, **kwargs)  # noqa: E501
            return data

    def get_rule_with_http_info(self, section_id, rule_id, **kwargs):  # noqa: E501
        """Read an Existing Rule  # noqa: E501

        Return existing firewall rule information in a firewall section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_rule_with_http_info(section_id, rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :return: FirewallRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'rule_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `get_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}/rules/{rule-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallRule',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_rule_state(self, rule_id, **kwargs):  # noqa: E501
        """Get the Realized State of a Firewall Rule  # noqa: E501

        Return realized state information of a firewall rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_rule_state(rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rule_id: (required)
        :param int barrier_id:
        :return: RuleState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_rule_state_with_http_info(rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_rule_state_with_http_info(rule_id, **kwargs)  # noqa: E501
            return data

    def get_rule_state_with_http_info(self, rule_id, **kwargs):  # noqa: E501
        """Get the Realized State of a Firewall Rule  # noqa: E501

        Return realized state information of a firewall rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_rule_state_with_http_info(rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rule_id: (required)
        :param int barrier_id:
        :return: RuleState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_id', 'barrier_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_rule_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `get_rule_state`")  # noqa: E501

        if 'barrier_id' in params and params['barrier_id'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `barrier_id` when calling `get_rule_state`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []
        if 'barrier_id' in params:
            query_params.append(('barrier_id', params['barrier_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/rules/{rule-id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuleState',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_rules(self, section_id, **kwargs):  # noqa: E501
        """Get All the Rules for a Section  # noqa: E501

        Return all firewall rule(s) information for a given firewall section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_rules(section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str applied_tos: AppliedTo's  referenced by this section or section's Firewall Rules .
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str destinations: Destinations referenced by this section's Firewall Rules .
        :param str filter_type: Filter type
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str services: NSService referenced by this section's Firewall Rules .
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str sources: Sources referenced by this section's Firewall Rules .
        :return: FirewallRuleListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_rules_with_http_info(section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_rules_with_http_info(section_id, **kwargs)  # noqa: E501
            return data

    def get_rules_with_http_info(self, section_id, **kwargs):  # noqa: E501
        """Get All the Rules for a Section  # noqa: E501

        Return all firewall rule(s) information for a given firewall section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_rules_with_http_info(section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str applied_tos: AppliedTo's  referenced by this section or section's Firewall Rules .
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str destinations: Destinations referenced by this section's Firewall Rules .
        :param str filter_type: Filter type
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str services: NSService referenced by this section's Firewall Rules .
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str sources: Sources referenced by this section's Firewall Rules .
        :return: FirewallRuleListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'applied_tos', 'cursor', 'destinations', 'filter_type', 'included_fields', 'page_size', 'services', 'sort_ascending', 'sort_by', 'sources']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_rules`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_rules`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `get_rules`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'applied_tos' in params:
            query_params.append(('applied_tos', params['applied_tos']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'destinations' in params:
            query_params.append(('destinations', params['destinations']))  # noqa: E501
        if 'filter_type' in params:
            query_params.append(('filter_type', params['filter_type']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'services' in params:
            query_params.append(('services', params['services']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'sources' in params:
            query_params.append(('sources', params['sources']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}/rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallRuleListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_section(self, section_id, **kwargs):  # noqa: E501
        """Get an Existing Section  # noqa: E501

        Returns information about firewall section for the identifier.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_section(section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :return: FirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_section_with_http_info(section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_section_with_http_info(section_id, **kwargs)  # noqa: E501
            return data

    def get_section_with_http_info(self, section_id, **kwargs):  # noqa: E501
        """Get an Existing Section  # noqa: E501

        Returns information about firewall section for the identifier.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_section_with_http_info(section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :return: FirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_section`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSection',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_section_state(self, section_id, **kwargs):  # noqa: E501
        """Get the Realized State of a Firewall Section  # noqa: E501

        Return realized state information of a firewall section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_section_state(section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param int barrier_id:
        :return: FirewallSectionState
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_section_state_with_http_info(section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_section_state_with_http_info(section_id, **kwargs)  # noqa: E501
            return data

    def get_section_state_with_http_info(self, section_id, **kwargs):  # noqa: E501
        """Get the Realized State of a Firewall Section  # noqa: E501

        Return realized state information of a firewall section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_section_state_with_http_info(section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param int barrier_id:
        :return: FirewallSectionState
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'barrier_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_section_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_section_state`")  # noqa: E501

        if 'barrier_id' in params and params['barrier_id'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `barrier_id` when calling `get_section_state`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'barrier_id' in params:
            query_params.append(('barrier_id', params['barrier_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSectionState',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_section_with_rules_list_with_rules(self, section_id, **kwargs):  # noqa: E501
        """Get an Existing Section, Including Rules  # noqa: E501

        Returns firewall section information with rules for a section identifier. When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules with a large number rule references is not supported.  Instead, to read firewall rules, use: GET /api/v1/firewall/sections/&lt;section-id&gt;/rules with the appropriate page_size.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_section_with_rules_list_with_rules(section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :return: FirewallSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_section_with_rules_list_with_rules_with_http_info(section_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_section_with_rules_list_with_rules_with_http_info(section_id, **kwargs)  # noqa: E501
            return data

    def get_section_with_rules_list_with_rules_with_http_info(self, section_id, **kwargs):  # noqa: E501
        """Get an Existing Section, Including Rules  # noqa: E501

        Returns firewall section information with rules for a section identifier. When invoked on a section with a large number of rules, this API is supported only at low rates of invocation (not more than 4-5 times per minute). The typical latency of this API with about 1024 rules is about 4-5 seconds. This API should not be invoked with large payloads at automation speeds. More than 50 rules with a large number rule references is not supported.  Instead, to read firewall rules, use: GET /api/v1/firewall/sections/&lt;section-id&gt;/rules with the appropriate page_size.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_section_with_rules_list_with_rules_with_http_info(section_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :return: FirewallSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_section_with_rules_list_with_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `get_section_with_rules_list_with_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}?action=list_with_rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSectionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_dhcp_ip_pools(self, server_id, **kwargs):  # noqa: E501
        """Get a paginated list of a DHCP server&#39;s IP pools  # noqa: E501

        Get a paginated list of a DHCP server's IP pools  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_dhcp_ip_pools(server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DhcpIpPoolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_dhcp_ip_pools_with_http_info(server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_dhcp_ip_pools_with_http_info(server_id, **kwargs)  # noqa: E501
            return data

    def list_dhcp_ip_pools_with_http_info(self, server_id, **kwargs):  # noqa: E501
        """Get a paginated list of a DHCP server&#39;s IP pools  # noqa: E501

        Get a paginated list of a DHCP server's IP pools  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_dhcp_ip_pools_with_http_info(server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DhcpIpPoolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_dhcp_ip_pools" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `list_dhcp_ip_pools`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_dhcp_ip_pools`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_dhcp_ip_pools`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ip-pools', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpIpPoolListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_dhcp_profiles(self, **kwargs):  # noqa: E501
        """Get a paginated list of DHCP server profiles  # noqa: E501

        Get a paginated list of DHCP server profiles  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_dhcp_profiles(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DhcpProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_dhcp_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_dhcp_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_dhcp_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """Get a paginated list of DHCP server profiles  # noqa: E501

        Get a paginated list of DHCP server profiles  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_dhcp_profiles_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DhcpProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_dhcp_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_dhcp_profiles`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_dhcp_profiles`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/server-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpProfileListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_dhcp_servers(self, **kwargs):  # noqa: E501
        """Get a paginated list of DHCP servers  # noqa: E501

        Get a paginated list of DHCP servers  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_dhcp_servers(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LogicalDhcpServerListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_dhcp_servers_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_dhcp_servers_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_dhcp_servers_with_http_info(self, **kwargs):  # noqa: E501
        """Get a paginated list of DHCP servers  # noqa: E501

        Get a paginated list of DHCP servers  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_dhcp_servers_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LogicalDhcpServerListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_dhcp_servers" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_dhcp_servers`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_dhcp_servers`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalDhcpServerListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_dhcp_static_bindings(self, server_id, **kwargs):  # noqa: E501
        """Get a paginated list of a DHCP server&#39;s static bindings  # noqa: E501

        Get a paginated list of a DHCP server's static bindings  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_dhcp_static_bindings(server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DhcpStaticBindingListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_dhcp_static_bindings_with_http_info(server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_dhcp_static_bindings_with_http_info(server_id, **kwargs)  # noqa: E501
            return data

    def list_dhcp_static_bindings_with_http_info(self, server_id, **kwargs):  # noqa: E501
        """Get a paginated list of a DHCP server&#39;s static bindings  # noqa: E501

        Get a paginated list of a DHCP server's static bindings  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_dhcp_static_bindings_with_http_info(server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DhcpStaticBindingListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_dhcp_static_bindings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `list_dhcp_static_bindings`")  # noqa: E501

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_dhcp_static_bindings`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_dhcp_static_bindings`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/static-bindings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpStaticBindingListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_dne_key_managers(self, **kwargs):  # noqa: E501
        """Get all configured instances of network encryption key managers  # noqa: E501

        Get all configured instances of network encryption key managers  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_dne_key_managers(async=True)
        >>> result = thread.get()

        :param async bool
        :return: DneKeyManagerListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_dne_key_managers_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_dne_key_managers_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_dne_key_managers_with_http_info(self, **kwargs):  # noqa: E501
        """Get all configured instances of network encryption key managers  # noqa: E501

        Get all configured instances of network encryption key managers  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_dne_key_managers_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: DneKeyManagerListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_dne_key_managers" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/key-managers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneKeyManagerListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_dne_key_policies(self, **kwargs):  # noqa: E501
        """Get all network encryption key policies  # noqa: E501

        Get all network encryption key policies  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_dne_key_policies(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str encrypt_algorithm: DNE key encryption algorithm
        :param str encrypt_type: Key policy encryption type
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str mac_algorithm: MAC algorithm type
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DneKeyPolicyListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_dne_key_policies_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_dne_key_policies_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_dne_key_policies_with_http_info(self, **kwargs):  # noqa: E501
        """Get all network encryption key policies  # noqa: E501

        Get all network encryption key policies  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_dne_key_policies_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str encrypt_algorithm: DNE key encryption algorithm
        :param str encrypt_type: Key policy encryption type
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str mac_algorithm: MAC algorithm type
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: DneKeyPolicyListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'encrypt_algorithm', 'encrypt_type', 'included_fields', 'mac_algorithm', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_dne_key_policies" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_dne_key_policies`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_dne_key_policies`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'encrypt_algorithm' in params:
            query_params.append(('encrypt_algorithm', params['encrypt_algorithm']))  # noqa: E501
        if 'encrypt_type' in params:
            query_params.append(('encrypt_type', params['encrypt_type']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'mac_algorithm' in params:
            query_params.append(('mac_algorithm', params['mac_algorithm']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/key-policies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneKeyPolicyListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_dne_sections(self, **kwargs):  # noqa: E501
        """Get network encryption sections  # noqa: E501

        Get network encryption sections  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_dne_sections(async=True)
        >>> result = thread.get()

        :param async bool
        :param str applied_tos: AppliedTo's  referenced by this section or section's DNE Rules .
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str destinations: Destinations referenced by this section's DNE Rules .
        :param str filter_type: Filter type
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str key_policy_id: key policy identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str services: NSService referenced by this section's DNE Rules .
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str sources: Sources referenced by this section's DNE Rules .
        :param str type: Section Type
        :return: DneSectionListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_dne_sections_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_dne_sections_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_dne_sections_with_http_info(self, **kwargs):  # noqa: E501
        """Get network encryption sections  # noqa: E501

        Get network encryption sections  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_dne_sections_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str applied_tos: AppliedTo's  referenced by this section or section's DNE Rules .
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str destinations: Destinations referenced by this section's DNE Rules .
        :param str filter_type: Filter type
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param str key_policy_id: key policy identifier
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str services: NSService referenced by this section's DNE Rules .
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str sources: Sources referenced by this section's DNE Rules .
        :param str type: Section Type
        :return: DneSectionListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['applied_tos', 'cursor', 'destinations', 'filter_type', 'included_fields', 'key_policy_id', 'page_size', 'services', 'sort_ascending', 'sort_by', 'sources', 'type']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_dne_sections" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_dne_sections`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_dne_sections`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'applied_tos' in params:
            query_params.append(('applied_tos', params['applied_tos']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'destinations' in params:
            query_params.append(('destinations', params['destinations']))  # noqa: E501
        if 'filter_type' in params:
            query_params.append(('filter_type', params['filter_type']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'key_policy_id' in params:
            query_params.append(('key_policy_id', params['key_policy_id']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'services' in params:
            query_params.append(('services', params['services']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'sources' in params:
            query_params.append(('sources', params['sources']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/sections', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneSectionListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_firewall_status(self, **kwargs):  # noqa: E501
        """List all firewall status for supported contexts  # noqa: E501

        List all firewall status for supported contexts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_firewall_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: FirewallStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_firewall_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_firewall_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_firewall_status_with_http_info(self, **kwargs):  # noqa: E501
        """List all firewall status for supported contexts  # noqa: E501

        List all firewall status for supported contexts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_firewall_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: FirewallStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_firewall_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallStatusListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_application_profiles(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer application profiles  # noqa: E501

        Retrieve a paginated list of load balancer application profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_application_profiles(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str type: application profile type
        :return: LbAppProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_load_balancer_application_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_application_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_load_balancer_application_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer application profiles  # noqa: E501

        Retrieve a paginated list of load balancer application profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_application_profiles_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str type: application profile type
        :return: LbAppProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'type']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_application_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_load_balancer_application_profiles`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_load_balancer_application_profiles`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/application-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbAppProfileListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_client_ssl_profiles(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer client-ssl profiles  # noqa: E501

        Retrieve a paginated list of load balancer client-ssl profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_client_ssl_profiles(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbClientSslProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_load_balancer_client_ssl_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_client_ssl_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_load_balancer_client_ssl_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer client-ssl profiles  # noqa: E501

        Retrieve a paginated list of load balancer client-ssl profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_client_ssl_profiles_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbClientSslProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_client_ssl_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_load_balancer_client_ssl_profiles`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_load_balancer_client_ssl_profiles`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/client-ssl-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbClientSslProfileListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_monitors(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer monitors  # noqa: E501

        Retrieve a paginated list of load balancer monitors.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_monitors(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str type: monitor query type
        :return: LbMonitorListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_load_balancer_monitors_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_monitors_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_load_balancer_monitors_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer monitors  # noqa: E501

        Retrieve a paginated list of load balancer monitors.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_monitors_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str type: monitor query type
        :return: LbMonitorListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'type']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_monitors" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_load_balancer_monitors`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_load_balancer_monitors`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/monitors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbMonitorListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_persistence_profiles(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer persistence profiles  # noqa: E501

        Retrieve a paginated list of load balancer persistence profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_persistence_profiles(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str type: persistence profile type
        :return: LbPersistenceProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_load_balancer_persistence_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_persistence_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_load_balancer_persistence_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer persistence profiles  # noqa: E501

        Retrieve a paginated list of load balancer persistence profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_persistence_profiles_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str type: persistence profile type
        :return: LbPersistenceProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by', 'type']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_persistence_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_load_balancer_persistence_profiles`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_load_balancer_persistence_profiles`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/persistence-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPersistenceProfileListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_pool_statistics(self, service_id, **kwargs):  # noqa: E501
        """Get the statistics list of load balancer pools  # noqa: E501

        Returns the statistics list of load balancer pools in given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_pool_statistics(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbPoolStatisticsListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_load_balancer_pool_statistics_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_pool_statistics_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def list_load_balancer_pool_statistics_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get the statistics list of load balancer pools  # noqa: E501

        Returns the statistics list of load balancer pools in given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_pool_statistics_with_http_info(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbPoolStatisticsListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_pool_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `list_load_balancer_pool_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/pools/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPoolStatisticsListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_pool_statuses(self, service_id, **kwargs):  # noqa: E501
        """Get the status list of load balancer pools  # noqa: E501

        Returns the status list of load balancer pools in given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_pool_statuses(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbPoolStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_load_balancer_pool_statuses_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_pool_statuses_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def list_load_balancer_pool_statuses_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get the status list of load balancer pools  # noqa: E501

        Returns the status list of load balancer pools in given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_pool_statuses_with_http_info(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbPoolStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_pool_statuses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `list_load_balancer_pool_statuses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/pools/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPoolStatusListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_pools(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer pools  # noqa: E501

        Retrieve a paginated list of load balancer pools.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_pools(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbPoolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_load_balancer_pools_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_pools_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_load_balancer_pools_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer pools  # noqa: E501

        Retrieve a paginated list of load balancer pools.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_pools_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbPoolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_pools" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_load_balancer_pools`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_load_balancer_pools`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/pools', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPoolListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_rules(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer rules  # noqa: E501

        Retrieve a paginated list of load balancer rules.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_rules(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbRuleListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_load_balancer_rules_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_rules_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_load_balancer_rules_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer rules  # noqa: E501

        Retrieve a paginated list of load balancer rules.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_rules_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbRuleListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_rules" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_load_balancer_rules`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_load_balancer_rules`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbRuleListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_server_ssl_profiles(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer server-ssl profiles  # noqa: E501

        Retrieve a paginated list of load balancer server-ssl profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_server_ssl_profiles(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbServerSslProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_load_balancer_server_ssl_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_server_ssl_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_load_balancer_server_ssl_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer server-ssl profiles  # noqa: E501

        Retrieve a paginated list of load balancer server-ssl profiles.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_server_ssl_profiles_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbServerSslProfileListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_server_ssl_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_load_balancer_server_ssl_profiles`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_load_balancer_server_ssl_profiles`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/server-ssl-profiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbServerSslProfileListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_services(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer services  # noqa: E501

        Retrieve a paginated list of load balancer services.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_services(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbServiceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_load_balancer_services_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_services_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_load_balancer_services_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer services  # noqa: E501

        Retrieve a paginated list of load balancer services.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_services_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbServiceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_services" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_load_balancer_services`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_load_balancer_services`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbServiceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_ssl_ciphers_and_protocols(self, **kwargs):  # noqa: E501
        """Retrieve a list of supported SSL ciphers and protocols  # noqa: E501

        Retrieve a list of supported SSL ciphers and protocols.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_ssl_ciphers_and_protocols(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbSslCipherAndProtocolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_load_balancer_ssl_ciphers_and_protocols_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_ssl_ciphers_and_protocols_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_load_balancer_ssl_ciphers_and_protocols_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a list of supported SSL ciphers and protocols  # noqa: E501

        Retrieve a list of supported SSL ciphers and protocols.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_ssl_ciphers_and_protocols_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbSslCipherAndProtocolListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_ssl_ciphers_and_protocols" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_load_balancer_ssl_ciphers_and_protocols`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_load_balancer_ssl_ciphers_and_protocols`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/ssl/ciphers-and-protocols', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbSslCipherAndProtocolListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_virtual_server_statuses(self, service_id, **kwargs):  # noqa: E501
        """Get the status list of virtual servers in given load balancer service  # noqa: E501

        Returns the status list of virtual servers in given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_virtual_server_statuses(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbVirtualServerStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_load_balancer_virtual_server_statuses_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_virtual_server_statuses_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def list_load_balancer_virtual_server_statuses_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get the status list of virtual servers in given load balancer service  # noqa: E501

        Returns the status list of virtual servers in given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_virtual_server_statuses_with_http_info(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbVirtualServerStatusListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_virtual_server_statuses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `list_load_balancer_virtual_server_statuses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/virtual-servers/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbVirtualServerStatusListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_virtual_servers(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer virtual servers  # noqa: E501

        Retrieve a paginated list of load balancer virtual servers.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_virtual_servers(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbVirtualServerListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_load_balancer_virtual_servers_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_virtual_servers_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_load_balancer_virtual_servers_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a paginated list of load balancer virtual servers  # noqa: E501

        Retrieve a paginated list of load balancer virtual servers.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_virtual_servers_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: LbVirtualServerListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_virtual_servers" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_load_balancer_virtual_servers`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_load_balancer_virtual_servers`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/virtual-servers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbVirtualServerListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_load_balancer_virtual_servers_statistics(self, service_id, **kwargs):  # noqa: E501
        """Get the statistics list of virtual servers  # noqa: E501

        Returns the statistics list of virtual servers in given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_virtual_servers_statistics(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbVirtualServerStatisticsListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_load_balancer_virtual_servers_statistics_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_load_balancer_virtual_servers_statistics_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def list_load_balancer_virtual_servers_statistics_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get the statistics list of virtual servers  # noqa: E501

        Returns the statistics list of virtual servers in given load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_load_balancer_virtual_servers_statistics_with_http_info(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param str source: Data source type.
        :return: LbVirtualServerStatisticsListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'source']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_load_balancer_virtual_servers_statistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `list_load_balancer_virtual_servers_statistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}/virtual-servers/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbVirtualServerStatisticsListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_metadata_proxy(self, **kwargs):  # noqa: E501
        """Get a paginated list of metadata proxies  # noqa: E501

        Get a paginated list of metadata proxies  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_metadata_proxy(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: MetadataProxyListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_metadata_proxy_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_metadata_proxy_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_metadata_proxy_with_http_info(self, **kwargs):  # noqa: E501
        """Get a paginated list of metadata proxies  # noqa: E501

        Get a paginated list of metadata proxies  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_metadata_proxy_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :return: MetadataProxyListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cursor', 'included_fields', 'page_size', 'sort_ascending', 'sort_by']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_metadata_proxy" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_metadata_proxy`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_metadata_proxy`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/md-proxies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MetadataProxyListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_sections(self, **kwargs):  # noqa: E501
        """List All Firewall Sections  # noqa: E501

        List all firewall section in paginated form. A default page size is limited to 1000 firewall sections. By default list of section is filtered by LAYER3 type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_sections(async=True)
        >>> result = thread.get()

        :param async bool
        :param str applied_tos: AppliedTo's  referenced by this section or section's Firewall Rules .
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str destinations: Destinations referenced by this section's Firewall Rules .
        :param str exclude_applied_to_type: Resource type valid for use as AppliedTo filter in section API
        :param str filter_type: Filter type
        :param str include_applied_to_type: Resource type valid for use as AppliedTo filter in section API
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str services: NSService referenced by this section's Firewall Rules .
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str sources: Sources referenced by this section's Firewall Rules .
        :param str type: Section Type
        :return: FirewallSectionListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.list_sections_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_sections_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_sections_with_http_info(self, **kwargs):  # noqa: E501
        """List All Firewall Sections  # noqa: E501

        List all firewall section in paginated form. A default page size is limited to 1000 firewall sections. By default list of section is filtered by LAYER3 type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.list_sections_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str applied_tos: AppliedTo's  referenced by this section or section's Firewall Rules .
        :param str cursor: Opaque cursor to be used for getting next page of records (supplied by current result page)
        :param str destinations: Destinations referenced by this section's Firewall Rules .
        :param str exclude_applied_to_type: Resource type valid for use as AppliedTo filter in section API
        :param str filter_type: Filter type
        :param str include_applied_to_type: Resource type valid for use as AppliedTo filter in section API
        :param str included_fields: Comma separated list of fields that should be included to result of query
        :param int page_size: Maximum number of results to return in this page (server may return fewer)
        :param str services: NSService referenced by this section's Firewall Rules .
        :param bool sort_ascending:
        :param str sort_by: Field by which records are sorted
        :param str sources: Sources referenced by this section's Firewall Rules .
        :param str type: Section Type
        :return: FirewallSectionListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['applied_tos', 'cursor', 'destinations', 'exclude_applied_to_type', 'filter_type', 'include_applied_to_type', 'included_fields', 'page_size', 'services', 'sort_ascending', 'sort_by', 'sources', 'type']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_sections" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 1000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_sections`, must be a value less than or equal to `1000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_sections`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'applied_tos' in params:
            query_params.append(('applied_tos', params['applied_tos']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'destinations' in params:
            query_params.append(('destinations', params['destinations']))  # noqa: E501
        if 'exclude_applied_to_type' in params:
            query_params.append(('exclude_applied_to_type', params['exclude_applied_to_type']))  # noqa: E501
        if 'filter_type' in params:
            query_params.append(('filter_type', params['filter_type']))  # noqa: E501
        if 'include_applied_to_type' in params:
            query_params.append(('include_applied_to_type', params['include_applied_to_type']))  # noqa: E501
        if 'included_fields' in params:
            query_params.append(('included_fields', params['included_fields']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'services' in params:
            query_params.append(('services', params['services']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'sources' in params:
            query_params.append(('sources', params['sources']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSectionListResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def perform_pool_member_action(self, pool_id, pool_member_setting_list, action, **kwargs):  # noqa: E501
        """Add, remove, or modify load balancer pool members  # noqa: E501

        For ADD_MEMBERS, pool members will be created and added to load balancer pool. This action is only valid for static pool members. For REMOVE_MEMBERS, pool members will be removed from load balancer pool via IP and port in pool member settings. This action is only valid for static pool members. For UPDATE_MEMBERS, pool members admin state will be updated. This action is valid for both static pool members and dynamic pool members. For dynamic pool members, this update will be stored in customized_members field in load balancer pool member group.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.perform_pool_member_action(pool_id, pool_member_setting_list, action, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: (required)
        :param PoolMemberSettingList pool_member_setting_list: (required)
        :param str action: Specifies addition, removal and modification action (required)
        :return: LbPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.perform_pool_member_action_with_http_info(pool_id, pool_member_setting_list, action, **kwargs)  # noqa: E501
        else:
            (data) = self.perform_pool_member_action_with_http_info(pool_id, pool_member_setting_list, action, **kwargs)  # noqa: E501
            return data

    def perform_pool_member_action_with_http_info(self, pool_id, pool_member_setting_list, action, **kwargs):  # noqa: E501
        """Add, remove, or modify load balancer pool members  # noqa: E501

        For ADD_MEMBERS, pool members will be created and added to load balancer pool. This action is only valid for static pool members. For REMOVE_MEMBERS, pool members will be removed from load balancer pool via IP and port in pool member settings. This action is only valid for static pool members. For UPDATE_MEMBERS, pool members admin state will be updated. This action is valid for both static pool members and dynamic pool members. For dynamic pool members, this update will be stored in customized_members field in load balancer pool member group.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.perform_pool_member_action_with_http_info(pool_id, pool_member_setting_list, action, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: (required)
        :param PoolMemberSettingList pool_member_setting_list: (required)
        :param str action: Specifies addition, removal and modification action (required)
        :return: LbPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pool_id', 'pool_member_setting_list', 'action']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method perform_pool_member_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `perform_pool_member_action`")  # noqa: E501
        # verify the required parameter 'pool_member_setting_list' is set
        if ('pool_member_setting_list' not in params or
                params['pool_member_setting_list'] is None):
            raise ValueError("Missing the required parameter `pool_member_setting_list` when calling `perform_pool_member_action`")  # noqa: E501
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `perform_pool_member_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pool_member_setting_list' in params:
            body_params = params['pool_member_setting_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/pools/{pool-id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPool',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_dhcp_ip_pool(self, server_id, pool_id, **kwargs):  # noqa: E501
        """Get a DHCP server&#39;s IP pool with the specified pool ID  # noqa: E501

        Get a DHCP server's IP pool with the specified pool ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_dhcp_ip_pool(server_id, pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param str pool_id: (required)
        :return: DhcpIpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_dhcp_ip_pool_with_http_info(server_id, pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_dhcp_ip_pool_with_http_info(server_id, pool_id, **kwargs)  # noqa: E501
            return data

    def read_dhcp_ip_pool_with_http_info(self, server_id, pool_id, **kwargs):  # noqa: E501
        """Get a DHCP server&#39;s IP pool with the specified pool ID  # noqa: E501

        Get a DHCP server's IP pool with the specified pool ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_dhcp_ip_pool_with_http_info(server_id, pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param str pool_id: (required)
        :return: DhcpIpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'pool_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_dhcp_ip_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `read_dhcp_ip_pool`")  # noqa: E501
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `read_dhcp_ip_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ip-pools/{pool-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpIpPool',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_dhcp_profile(self, profile_id, **kwargs):  # noqa: E501
        """Get a DHCP server profile  # noqa: E501

        Get a DHCP server profile  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_dhcp_profile(profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str profile_id: (required)
        :return: DhcpProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_dhcp_profile_with_http_info(profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_dhcp_profile_with_http_info(profile_id, **kwargs)  # noqa: E501
            return data

    def read_dhcp_profile_with_http_info(self, profile_id, **kwargs):  # noqa: E501
        """Get a DHCP server profile  # noqa: E501

        Get a DHCP server profile  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_dhcp_profile_with_http_info(profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str profile_id: (required)
        :return: DhcpProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_dhcp_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'profile_id' is set
        if ('profile_id' not in params or
                params['profile_id'] is None):
            raise ValueError("Missing the required parameter `profile_id` when calling `read_dhcp_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'profile_id' in params:
            path_params['profile-id'] = params['profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/server-profiles/{profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_dhcp_server(self, server_id, **kwargs):  # noqa: E501
        """Get a DHCP server  # noqa: E501

        Get a DHCP server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_dhcp_server(server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :return: LogicalDhcpServer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_dhcp_server_with_http_info(server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_dhcp_server_with_http_info(server_id, **kwargs)  # noqa: E501
            return data

    def read_dhcp_server_with_http_info(self, server_id, **kwargs):  # noqa: E501
        """Get a DHCP server  # noqa: E501

        Get a DHCP server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_dhcp_server_with_http_info(server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :return: LogicalDhcpServer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_dhcp_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `read_dhcp_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalDhcpServer',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_dhcp_static_binding(self, server_id, binding_id, **kwargs):  # noqa: E501
        """Get a DHCP server&#39;s static binding with the specified binding ID  # noqa: E501

        Get a DHCP server's static binding with the specified binding ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_dhcp_static_binding(server_id, binding_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param str binding_id: (required)
        :return: DhcpStaticBinding
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_dhcp_static_binding_with_http_info(server_id, binding_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_dhcp_static_binding_with_http_info(server_id, binding_id, **kwargs)  # noqa: E501
            return data

    def read_dhcp_static_binding_with_http_info(self, server_id, binding_id, **kwargs):  # noqa: E501
        """Get a DHCP server&#39;s static binding with the specified binding ID  # noqa: E501

        Get a DHCP server's static binding with the specified binding ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_dhcp_static_binding_with_http_info(server_id, binding_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param str binding_id: (required)
        :return: DhcpStaticBinding
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'binding_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_dhcp_static_binding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `read_dhcp_static_binding`")  # noqa: E501
        # verify the required parameter 'binding_id' is set
        if ('binding_id' not in params or
                params['binding_id'] is None):
            raise ValueError("Missing the required parameter `binding_id` when calling `read_dhcp_static_binding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501
        if 'binding_id' in params:
            path_params['binding-id'] = params['binding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/static-bindings/{binding-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpStaticBinding',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_application_profile(self, application_profile_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer application profile  # noqa: E501

        Retrieve a load balancer application profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_load_balancer_application_profile(application_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str application_profile_id: (required)
        :return: LbAppProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_load_balancer_application_profile_with_http_info(application_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_application_profile_with_http_info(application_profile_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_application_profile_with_http_info(self, application_profile_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer application profile  # noqa: E501

        Retrieve a load balancer application profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_load_balancer_application_profile_with_http_info(application_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str application_profile_id: (required)
        :return: LbAppProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_application_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_profile_id' is set
        if ('application_profile_id' not in params or
                params['application_profile_id'] is None):
            raise ValueError("Missing the required parameter `application_profile_id` when calling `read_load_balancer_application_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_profile_id' in params:
            path_params['application-profile-id'] = params['application_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/application-profiles/{application-profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbAppProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_client_ssl_profile(self, client_ssl_profile_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer client-ssl profile  # noqa: E501

        Retrieve a load balancer client-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_load_balancer_client_ssl_profile(client_ssl_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str client_ssl_profile_id: (required)
        :return: LbClientSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_client_ssl_profile_with_http_info(self, client_ssl_profile_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer client-ssl profile  # noqa: E501

        Retrieve a load balancer client-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str client_ssl_profile_id: (required)
        :return: LbClientSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_ssl_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_client_ssl_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_ssl_profile_id' is set
        if ('client_ssl_profile_id' not in params or
                params['client_ssl_profile_id'] is None):
            raise ValueError("Missing the required parameter `client_ssl_profile_id` when calling `read_load_balancer_client_ssl_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_ssl_profile_id' in params:
            path_params['client-ssl-profile-id'] = params['client_ssl_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/client-ssl-profiles/{client-ssl-profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbClientSslProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_monitor(self, monitor_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer monitor  # noqa: E501

        Retrieve a load balancer monitor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_load_balancer_monitor(monitor_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str monitor_id: (required)
        :return: LbMonitor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_load_balancer_monitor_with_http_info(monitor_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_monitor_with_http_info(monitor_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_monitor_with_http_info(self, monitor_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer monitor  # noqa: E501

        Retrieve a load balancer monitor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_load_balancer_monitor_with_http_info(monitor_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str monitor_id: (required)
        :return: LbMonitor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['monitor_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'monitor_id' is set
        if ('monitor_id' not in params or
                params['monitor_id'] is None):
            raise ValueError("Missing the required parameter `monitor_id` when calling `read_load_balancer_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'monitor_id' in params:
            path_params['monitor-id'] = params['monitor_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/monitors/{monitor-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbMonitor',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_persistence_profile(self, persistence_profile_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer persistence profile  # noqa: E501

        Retrieve a load balancer persistence profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_load_balancer_persistence_profile(persistence_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str persistence_profile_id: (required)
        :return: LbPersistenceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_load_balancer_persistence_profile_with_http_info(persistence_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_persistence_profile_with_http_info(persistence_profile_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_persistence_profile_with_http_info(self, persistence_profile_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer persistence profile  # noqa: E501

        Retrieve a load balancer persistence profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_load_balancer_persistence_profile_with_http_info(persistence_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str persistence_profile_id: (required)
        :return: LbPersistenceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['persistence_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_persistence_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'persistence_profile_id' is set
        if ('persistence_profile_id' not in params or
                params['persistence_profile_id'] is None):
            raise ValueError("Missing the required parameter `persistence_profile_id` when calling `read_load_balancer_persistence_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'persistence_profile_id' in params:
            path_params['persistence-profile-id'] = params['persistence_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/persistence-profiles/{persistence-profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPersistenceProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_pool(self, pool_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer pool  # noqa: E501

        Retrieve a load balancer pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_load_balancer_pool(pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: (required)
        :return: LbPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_load_balancer_pool_with_http_info(pool_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_pool_with_http_info(pool_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_pool_with_http_info(self, pool_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer pool  # noqa: E501

        Retrieve a load balancer pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_load_balancer_pool_with_http_info(pool_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: (required)
        :return: LbPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pool_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `read_load_balancer_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/pools/{pool-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPool',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_rule(self, rule_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer rule  # noqa: E501

        Retrieve a load balancer rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_load_balancer_rule(rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rule_id: (required)
        :return: LbRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_load_balancer_rule_with_http_info(rule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_rule_with_http_info(rule_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_rule_with_http_info(self, rule_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer rule  # noqa: E501

        Retrieve a load balancer rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_load_balancer_rule_with_http_info(rule_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rule_id: (required)
        :return: LbRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `read_load_balancer_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/rules/{rule-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbRule',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_server_ssl_profile(self, server_ssl_profile_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer server-ssl profile  # noqa: E501

        Retrieve a load balancer server-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_load_balancer_server_ssl_profile(server_ssl_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_ssl_profile_id: (required)
        :return: LbServerSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_server_ssl_profile_with_http_info(self, server_ssl_profile_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer server-ssl profile  # noqa: E501

        Retrieve a load balancer server-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_ssl_profile_id: (required)
        :return: LbServerSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_ssl_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_server_ssl_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_ssl_profile_id' is set
        if ('server_ssl_profile_id' not in params or
                params['server_ssl_profile_id'] is None):
            raise ValueError("Missing the required parameter `server_ssl_profile_id` when calling `read_load_balancer_server_ssl_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_ssl_profile_id' in params:
            path_params['server-ssl-profile-id'] = params['server_ssl_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/server-ssl-profiles/{server-ssl-profile-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbServerSslProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_service(self, service_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer service  # noqa: E501

        Retrieve a load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_load_balancer_service(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :return: LbService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_load_balancer_service_with_http_info(service_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_service_with_http_info(service_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_service_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer service  # noqa: E501

        Retrieve a load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_load_balancer_service_with_http_info(service_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :return: LbService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `read_load_balancer_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbService',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_load_balancer_virtual_server(self, virtual_server_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer virtual server  # noqa: E501

        Retrieve a load balancer virtual server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_load_balancer_virtual_server(virtual_server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str virtual_server_id: (required)
        :return: LbVirtualServer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_load_balancer_virtual_server_with_http_info(virtual_server_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_load_balancer_virtual_server_with_http_info(virtual_server_id, **kwargs)  # noqa: E501
            return data

    def read_load_balancer_virtual_server_with_http_info(self, virtual_server_id, **kwargs):  # noqa: E501
        """Retrieve a load balancer virtual server  # noqa: E501

        Retrieve a load balancer virtual server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_load_balancer_virtual_server_with_http_info(virtual_server_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str virtual_server_id: (required)
        :return: LbVirtualServer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['virtual_server_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_load_balancer_virtual_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'virtual_server_id' is set
        if ('virtual_server_id' not in params or
                params['virtual_server_id'] is None):
            raise ValueError("Missing the required parameter `virtual_server_id` when calling `read_load_balancer_virtual_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'virtual_server_id' in params:
            path_params['virtual-server-id'] = params['virtual_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/virtual-servers/{virtual-server-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbVirtualServer',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def read_metadata_proxy(self, proxy_id, **kwargs):  # noqa: E501
        """Get a metadata proxy  # noqa: E501

        Get a metadata proxy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_metadata_proxy(proxy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str proxy_id: (required)
        :return: MetadataProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.read_metadata_proxy_with_http_info(proxy_id, **kwargs)  # noqa: E501
        else:
            (data) = self.read_metadata_proxy_with_http_info(proxy_id, **kwargs)  # noqa: E501
            return data

    def read_metadata_proxy_with_http_info(self, proxy_id, **kwargs):  # noqa: E501
        """Get a metadata proxy  # noqa: E501

        Get a metadata proxy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.read_metadata_proxy_with_http_info(proxy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str proxy_id: (required)
        :return: MetadataProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proxy_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_metadata_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proxy_id' is set
        if ('proxy_id' not in params or
                params['proxy_id'] is None):
            raise ValueError("Missing the required parameter `proxy_id` when calling `read_metadata_proxy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proxy_id' in params:
            path_params['proxy-id'] = params['proxy_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/md-proxies/{proxy-id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MetadataProxy',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_member_remove_member(self, object_id, **kwargs):  # noqa: E501
        """Remove an existing object from the exclude list  # noqa: E501

        Remove an existing object from the exclude list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remove_member_remove_member(object_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str object_id: identifier of the object (required)
        :return: ResourceReference
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remove_member_remove_member_with_http_info(object_id, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_member_remove_member_with_http_info(object_id, **kwargs)  # noqa: E501
            return data

    def remove_member_remove_member_with_http_info(self, object_id, **kwargs):  # noqa: E501
        """Remove an existing object from the exclude list  # noqa: E501

        Remove an existing object from the exclude list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remove_member_remove_member_with_http_info(object_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str object_id: identifier of the object (required)
        :return: ResourceReference
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_member_remove_member" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if ('object_id' not in params or
                params['object_id'] is None):
            raise ValueError("Missing the required parameter `object_id` when calling `remove_member_remove_member`")  # noqa: E501

        if ('object_id' in params and
                len(params['object_id']) > 64):
            raise ValueError("Invalid value for parameter `object_id` when calling `remove_member_remove_member`, length must be less than or equal to `64`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'object_id' in params:
            query_params.append(('object_id', params['object_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/excludelist?action=remove_member', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceReference',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reset_default_dne_key_policy_to_system_default(self, encrypt_type, **kwargs):  # noqa: E501
        """Reset default network encryption key policy to system default for a specific encryption type  # noqa: E501

        Reset default network encryption key policy to system default for a specific encryption type  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.reset_default_dne_key_policy_to_system_default(encrypt_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str encrypt_type: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.reset_default_dne_key_policy_to_system_default_with_http_info(encrypt_type, **kwargs)  # noqa: E501
        else:
            (data) = self.reset_default_dne_key_policy_to_system_default_with_http_info(encrypt_type, **kwargs)  # noqa: E501
            return data

    def reset_default_dne_key_policy_to_system_default_with_http_info(self, encrypt_type, **kwargs):  # noqa: E501
        """Reset default network encryption key policy to system default for a specific encryption type  # noqa: E501

        Reset default network encryption key policy to system default for a specific encryption type  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.reset_default_dne_key_policy_to_system_default_with_http_info(encrypt_type, async=True)
        >>> result = thread.get()

        :param async bool
        :param str encrypt_type: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['encrypt_type']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_default_dne_key_policy_to_system_default" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'encrypt_type' is set
        if ('encrypt_type' not in params or
                params['encrypt_type'] is None):
            raise ValueError("Missing the required parameter `encrypt_type` when calling `reset_default_dne_key_policy_to_system_default`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'encrypt_type' in params:
            path_params['encrypt-type'] = params['encrypt_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/key-policies/reset/{encrypt-type}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reset_firewall_rule_stats_reset(self, category, **kwargs):  # noqa: E501
        """Reset firewall rule statistics  # noqa: E501

        Sets firewall rule statistics counter to zero. This operation is supported for given category, for example: L3DFW i.e. for all layer3 firewall (transport nodes only) rules or L3EDGE i.e. for all layer3 edge firewall (edge nodes only) rules.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.reset_firewall_rule_stats_reset(category, async=True)
        >>> result = thread.get()

        :param async bool
        :param str category: Aggregation Statistic Category (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.reset_firewall_rule_stats_reset_with_http_info(category, **kwargs)  # noqa: E501
        else:
            (data) = self.reset_firewall_rule_stats_reset_with_http_info(category, **kwargs)  # noqa: E501
            return data

    def reset_firewall_rule_stats_reset_with_http_info(self, category, **kwargs):  # noqa: E501
        """Reset firewall rule statistics  # noqa: E501

        Sets firewall rule statistics counter to zero. This operation is supported for given category, for example: L3DFW i.e. for all layer3 firewall (transport nodes only) rules or L3EDGE i.e. for all layer3 edge firewall (edge nodes only) rules.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.reset_firewall_rule_stats_reset_with_http_info(category, async=True)
        >>> result = thread.get()

        :param async bool
        :param str category: Aggregation Statistic Category (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_firewall_rule_stats_reset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'category' is set
        if ('category' not in params or
                params['category'] is None):
            raise ValueError("Missing the required parameter `category` when calling `reset_firewall_rule_stats_reset`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/stats?action=reset', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revise_dne_rule_revise(self, section_id, rule_id, dne_rule, operation, **kwargs):  # noqa: E501
        """Update or reorder a rule in a network encryption section  # noqa: E501

        Update or reorder a rule in a network encryption section  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.revise_dne_rule_revise(section_id, rule_id, dne_rule, operation, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :param DneRule dne_rule: (required)
        :param str operation: Operation (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :return: DneRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.revise_dne_rule_revise_with_http_info(section_id, rule_id, dne_rule, operation, **kwargs)  # noqa: E501
        else:
            (data) = self.revise_dne_rule_revise_with_http_info(section_id, rule_id, dne_rule, operation, **kwargs)  # noqa: E501
            return data

    def revise_dne_rule_revise_with_http_info(self, section_id, rule_id, dne_rule, operation, **kwargs):  # noqa: E501
        """Update or reorder a rule in a network encryption section  # noqa: E501

        Update or reorder a rule in a network encryption section  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.revise_dne_rule_revise_with_http_info(section_id, rule_id, dne_rule, operation, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :param DneRule dne_rule: (required)
        :param str operation: Operation (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :return: DneRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'rule_id', 'dne_rule', 'operation', 'id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revise_dne_rule_revise" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `revise_dne_rule_revise`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `revise_dne_rule_revise`")  # noqa: E501
        # verify the required parameter 'dne_rule' is set
        if ('dne_rule' not in params or
                params['dne_rule'] is None):
            raise ValueError("Missing the required parameter `dne_rule` when calling `revise_dne_rule_revise`")  # noqa: E501
        # verify the required parameter 'operation' is set
        if ('operation' not in params or
                params['operation'] is None):
            raise ValueError("Missing the required parameter `operation` when calling `revise_dne_rule_revise`")  # noqa: E501

        if ('id' in params and
                len(params['id']) > 64):
            raise ValueError("Invalid value for parameter `id` when calling `revise_dne_rule_revise`, length must be less than or equal to `64`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dne_rule' in params:
            body_params = params['dne_rule']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/sections/{section-id}/rules/{rule-id}?action=revise', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneRule',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revise_dne_section_revise(self, section_id, dne_section, operation, **kwargs):  # noqa: E501
        """Update a network encryption section and/or its position  # noqa: E501

        Update a network encryption section and/or its position  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.revise_dne_section_revise(section_id, dne_section, operation, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param DneSection dne_section: (required)
        :param str operation: Operation (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :return: DneSection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.revise_dne_section_revise_with_http_info(section_id, dne_section, operation, **kwargs)  # noqa: E501
        else:
            (data) = self.revise_dne_section_revise_with_http_info(section_id, dne_section, operation, **kwargs)  # noqa: E501
            return data

    def revise_dne_section_revise_with_http_info(self, section_id, dne_section, operation, **kwargs):  # noqa: E501
        """Update a network encryption section and/or its position  # noqa: E501

        Update a network encryption section and/or its position  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.revise_dne_section_revise_with_http_info(section_id, dne_section, operation, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param DneSection dne_section: (required)
        :param str operation: Operation (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :return: DneSection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'dne_section', 'operation', 'id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revise_dne_section_revise" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `revise_dne_section_revise`")  # noqa: E501
        # verify the required parameter 'dne_section' is set
        if ('dne_section' not in params or
                params['dne_section'] is None):
            raise ValueError("Missing the required parameter `dne_section` when calling `revise_dne_section_revise`")  # noqa: E501
        # verify the required parameter 'operation' is set
        if ('operation' not in params or
                params['operation'] is None):
            raise ValueError("Missing the required parameter `operation` when calling `revise_dne_section_revise`")  # noqa: E501

        if ('id' in params and
                len(params['id']) > 64):
            raise ValueError("Invalid value for parameter `id` when calling `revise_dne_section_revise`, length must be less than or equal to `64`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dne_section' in params:
            body_params = params['dne_section']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/sections/{section-id}?action=revise', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneSection',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revise_dne_section_with_rules_revise_with_rules(self, section_id, dne_section_rule_list, operation, **kwargs):  # noqa: E501
        """Update a network encryption section, its rules or position  # noqa: E501

        This API can be called for a section with or without rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to move a section above or below another section, use: POST /api/v1/network-encryption/sections/&lt;section-id&gt;?action=revise  To modify rules, use: PUT /api/v1/network-encryption/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt;   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.revise_dne_section_with_rules_revise_with_rules(section_id, dne_section_rule_list, operation, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param DneSectionRuleList dne_section_rule_list: (required)
        :param str operation: Operation (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :return: DneSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.revise_dne_section_with_rules_revise_with_rules_with_http_info(section_id, dne_section_rule_list, operation, **kwargs)  # noqa: E501
        else:
            (data) = self.revise_dne_section_with_rules_revise_with_rules_with_http_info(section_id, dne_section_rule_list, operation, **kwargs)  # noqa: E501
            return data

    def revise_dne_section_with_rules_revise_with_rules_with_http_info(self, section_id, dne_section_rule_list, operation, **kwargs):  # noqa: E501
        """Update a network encryption section, its rules or position  # noqa: E501

        This API can be called for a section with or without rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to move a section above or below another section, use: POST /api/v1/network-encryption/sections/&lt;section-id&gt;?action=revise  To modify rules, use: PUT /api/v1/network-encryption/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt;   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.revise_dne_section_with_rules_revise_with_rules_with_http_info(section_id, dne_section_rule_list, operation, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param DneSectionRuleList dne_section_rule_list: (required)
        :param str operation: Operation (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :return: DneSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'dne_section_rule_list', 'operation', 'id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revise_dne_section_with_rules_revise_with_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `revise_dne_section_with_rules_revise_with_rules`")  # noqa: E501
        # verify the required parameter 'dne_section_rule_list' is set
        if ('dne_section_rule_list' not in params or
                params['dne_section_rule_list'] is None):
            raise ValueError("Missing the required parameter `dne_section_rule_list` when calling `revise_dne_section_with_rules_revise_with_rules`")  # noqa: E501
        # verify the required parameter 'operation' is set
        if ('operation' not in params or
                params['operation'] is None):
            raise ValueError("Missing the required parameter `operation` when calling `revise_dne_section_with_rules_revise_with_rules`")  # noqa: E501

        if ('id' in params and
                len(params['id']) > 64):
            raise ValueError("Invalid value for parameter `id` when calling `revise_dne_section_with_rules_revise_with_rules`, length must be less than or equal to `64`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dne_section_rule_list' in params:
            body_params = params['dne_section_rule_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/sections/{section-id}?action=revise_with_rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneSectionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revise_rule_revise(self, section_id, rule_id, firewall_rule, **kwargs):  # noqa: E501
        """Update an Existing Rule and Reorder the Rule  # noqa: E501

        Modifies existing firewall rule along with relative position among other firewall rules inside a firewall section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.revise_rule_revise(section_id, rule_id, firewall_rule, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :param FirewallRule firewall_rule: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.revise_rule_revise_with_http_info(section_id, rule_id, firewall_rule, **kwargs)  # noqa: E501
        else:
            (data) = self.revise_rule_revise_with_http_info(section_id, rule_id, firewall_rule, **kwargs)  # noqa: E501
            return data

    def revise_rule_revise_with_http_info(self, section_id, rule_id, firewall_rule, **kwargs):  # noqa: E501
        """Update an Existing Rule and Reorder the Rule  # noqa: E501

        Modifies existing firewall rule along with relative position among other firewall rules inside a firewall section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.revise_rule_revise_with_http_info(section_id, rule_id, firewall_rule, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :param FirewallRule firewall_rule: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'rule_id', 'firewall_rule', 'id', 'operation']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revise_rule_revise" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `revise_rule_revise`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `revise_rule_revise`")  # noqa: E501
        # verify the required parameter 'firewall_rule' is set
        if ('firewall_rule' not in params or
                params['firewall_rule'] is None):
            raise ValueError("Missing the required parameter `firewall_rule` when calling `revise_rule_revise`")  # noqa: E501

        if ('id' in params and
                len(params['id']) > 64):
            raise ValueError("Invalid value for parameter `id` when calling `revise_rule_revise`, length must be less than or equal to `64`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'firewall_rule' in params:
            body_params = params['firewall_rule']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}/rules/{rule-id}?action=revise', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallRule',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revise_section_revise(self, section_id, firewall_section, **kwargs):  # noqa: E501
        """Update an Existing Section, Including Its Position  # noqa: E501

        Modifies an existing firewall section along with its relative position among other firewall sections in the system.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.revise_section_revise(section_id, firewall_section, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param FirewallSection firewall_section: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.revise_section_revise_with_http_info(section_id, firewall_section, **kwargs)  # noqa: E501
        else:
            (data) = self.revise_section_revise_with_http_info(section_id, firewall_section, **kwargs)  # noqa: E501
            return data

    def revise_section_revise_with_http_info(self, section_id, firewall_section, **kwargs):  # noqa: E501
        """Update an Existing Section, Including Its Position  # noqa: E501

        Modifies an existing firewall section along with its relative position among other firewall sections in the system.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.revise_section_revise_with_http_info(section_id, firewall_section, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param FirewallSection firewall_section: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'firewall_section', 'id', 'operation']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revise_section_revise" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `revise_section_revise`")  # noqa: E501
        # verify the required parameter 'firewall_section' is set
        if ('firewall_section' not in params or
                params['firewall_section'] is None):
            raise ValueError("Missing the required parameter `firewall_section` when calling `revise_section_revise`")  # noqa: E501

        if ('id' in params and
                len(params['id']) > 64):
            raise ValueError("Invalid value for parameter `id` when calling `revise_section_revise`, length must be less than or equal to `64`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'firewall_section' in params:
            body_params = params['firewall_section']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}?action=revise', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSection',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revise_section_with_rules_revise_with_rules(self, section_id, firewall_section_rule_list, **kwargs):  # noqa: E501
        """Update an Existing Section with Rules  # noqa: E501

        Modifies an existing firewall section along with its relative position among other firewall sections with rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to move a section above or below another section, use: POST /api/v1/firewall/sections/&lt;section-id&gt;?action=revise  To modify rules, use: PUT /api/v1/firewall/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt;   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.revise_section_with_rules_revise_with_rules(section_id, firewall_section_rule_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param FirewallSectionRuleList firewall_section_rule_list: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.revise_section_with_rules_revise_with_rules_with_http_info(section_id, firewall_section_rule_list, **kwargs)  # noqa: E501
        else:
            (data) = self.revise_section_with_rules_revise_with_rules_with_http_info(section_id, firewall_section_rule_list, **kwargs)  # noqa: E501
            return data

    def revise_section_with_rules_revise_with_rules_with_http_info(self, section_id, firewall_section_rule_list, **kwargs):  # noqa: E501
        """Update an Existing Section with Rules  # noqa: E501

        Modifies an existing firewall section along with its relative position among other firewall sections with rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to move a section above or below another section, use: POST /api/v1/firewall/sections/&lt;section-id&gt;?action=revise  To modify rules, use: PUT /api/v1/firewall/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt;   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.revise_section_with_rules_revise_with_rules_with_http_info(section_id, firewall_section_rule_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param FirewallSectionRuleList firewall_section_rule_list: (required)
        :param str id: Identifier of the anchor rule or section. This is a required field in case operation like 'insert_before' and 'insert_after'.
        :param str operation: Operation
        :return: FirewallSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'firewall_section_rule_list', 'id', 'operation']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revise_section_with_rules_revise_with_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `revise_section_with_rules_revise_with_rules`")  # noqa: E501
        # verify the required parameter 'firewall_section_rule_list' is set
        if ('firewall_section_rule_list' not in params or
                params['firewall_section_rule_list'] is None):
            raise ValueError("Missing the required parameter `firewall_section_rule_list` when calling `revise_section_with_rules_revise_with_rules`")  # noqa: E501

        if ('id' in params and
                len(params['id']) > 64):
            raise ValueError("Invalid value for parameter `id` when calling `revise_section_with_rules_revise_with_rules`, length must be less than or equal to `64`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'firewall_section_rule_list' in params:
            body_params = params['firewall_section_rule_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}?action=revise_with_rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSectionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revoke_dne_key_policy_revoke(self, key_policy_id, **kwargs):  # noqa: E501
        """Manually revoke a network encryption key policy for ungraceful re-key  # noqa: E501

        Manually revoke a network encryption key policy for ungraceful re-key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.revoke_dne_key_policy_revoke(key_policy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str key_policy_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.revoke_dne_key_policy_revoke_with_http_info(key_policy_id, **kwargs)  # noqa: E501
        else:
            (data) = self.revoke_dne_key_policy_revoke_with_http_info(key_policy_id, **kwargs)  # noqa: E501
            return data

    def revoke_dne_key_policy_revoke_with_http_info(self, key_policy_id, **kwargs):  # noqa: E501
        """Manually revoke a network encryption key policy for ungraceful re-key  # noqa: E501

        Manually revoke a network encryption key policy for ungraceful re-key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.revoke_dne_key_policy_revoke_with_http_info(key_policy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str key_policy_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['key_policy_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revoke_dne_key_policy_revoke" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_policy_id' is set
        if ('key_policy_id' not in params or
                params['key_policy_id'] is None):
            raise ValueError("Missing the required parameter `key_policy_id` when calling `revoke_dne_key_policy_revoke`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'key_policy_id' in params:
            path_params['key-policy-id'] = params['key_policy_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/key-policies/{key-policy-id}?action=revoke', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def rotate_dne_key_policy_rotate(self, key_policy_id, **kwargs):  # noqa: E501
        """Manually rotate a network encryption key policy for graceful re-key  # noqa: E501

        Manually rotate a network encryption key policy for graceful re-key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.rotate_dne_key_policy_rotate(key_policy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str key_policy_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.rotate_dne_key_policy_rotate_with_http_info(key_policy_id, **kwargs)  # noqa: E501
        else:
            (data) = self.rotate_dne_key_policy_rotate_with_http_info(key_policy_id, **kwargs)  # noqa: E501
            return data

    def rotate_dne_key_policy_rotate_with_http_info(self, key_policy_id, **kwargs):  # noqa: E501
        """Manually rotate a network encryption key policy for graceful re-key  # noqa: E501

        Manually rotate a network encryption key policy for graceful re-key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.rotate_dne_key_policy_rotate_with_http_info(key_policy_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str key_policy_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['key_policy_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rotate_dne_key_policy_rotate" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_policy_id' is set
        if ('key_policy_id' not in params or
                params['key_policy_id'] is None):
            raise ValueError("Missing the required parameter `key_policy_id` when calling `rotate_dne_key_policy_rotate`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'key_policy_id' in params:
            path_params['key-policy-id'] = params['key_policy_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/key-policies/{key-policy-id}?action=rotate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dhcp_ip_pool(self, server_id, pool_id, dhcp_ip_pool, **kwargs):  # noqa: E501
        """Update a DHCP server&#39;s IP pool  # noqa: E501

        Update a DHCP server's IP pool  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dhcp_ip_pool(server_id, pool_id, dhcp_ip_pool, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param str pool_id: (required)
        :param DhcpIpPool dhcp_ip_pool: (required)
        :return: DhcpIpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dhcp_ip_pool_with_http_info(server_id, pool_id, dhcp_ip_pool, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dhcp_ip_pool_with_http_info(server_id, pool_id, dhcp_ip_pool, **kwargs)  # noqa: E501
            return data

    def update_dhcp_ip_pool_with_http_info(self, server_id, pool_id, dhcp_ip_pool, **kwargs):  # noqa: E501
        """Update a DHCP server&#39;s IP pool  # noqa: E501

        Update a DHCP server's IP pool  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dhcp_ip_pool_with_http_info(server_id, pool_id, dhcp_ip_pool, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param str pool_id: (required)
        :param DhcpIpPool dhcp_ip_pool: (required)
        :return: DhcpIpPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'pool_id', 'dhcp_ip_pool']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dhcp_ip_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `update_dhcp_ip_pool`")  # noqa: E501
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `update_dhcp_ip_pool`")  # noqa: E501
        # verify the required parameter 'dhcp_ip_pool' is set
        if ('dhcp_ip_pool' not in params or
                params['dhcp_ip_pool'] is None):
            raise ValueError("Missing the required parameter `dhcp_ip_pool` when calling `update_dhcp_ip_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dhcp_ip_pool' in params:
            body_params = params['dhcp_ip_pool']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/ip-pools/{pool-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpIpPool',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dhcp_profile(self, profile_id, dhcp_profile, **kwargs):  # noqa: E501
        """Update a DHCP server profile  # noqa: E501

        Update a DHCP server profile  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dhcp_profile(profile_id, dhcp_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str profile_id: (required)
        :param DhcpProfile dhcp_profile: (required)
        :return: DhcpProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dhcp_profile_with_http_info(profile_id, dhcp_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dhcp_profile_with_http_info(profile_id, dhcp_profile, **kwargs)  # noqa: E501
            return data

    def update_dhcp_profile_with_http_info(self, profile_id, dhcp_profile, **kwargs):  # noqa: E501
        """Update a DHCP server profile  # noqa: E501

        Update a DHCP server profile  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dhcp_profile_with_http_info(profile_id, dhcp_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str profile_id: (required)
        :param DhcpProfile dhcp_profile: (required)
        :return: DhcpProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['profile_id', 'dhcp_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dhcp_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'profile_id' is set
        if ('profile_id' not in params or
                params['profile_id'] is None):
            raise ValueError("Missing the required parameter `profile_id` when calling `update_dhcp_profile`")  # noqa: E501
        # verify the required parameter 'dhcp_profile' is set
        if ('dhcp_profile' not in params or
                params['dhcp_profile'] is None):
            raise ValueError("Missing the required parameter `dhcp_profile` when calling `update_dhcp_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'profile_id' in params:
            path_params['profile-id'] = params['profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dhcp_profile' in params:
            body_params = params['dhcp_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/server-profiles/{profile-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dhcp_server(self, server_id, logical_dhcp_server, **kwargs):  # noqa: E501
        """Update a DHCP server  # noqa: E501

        Update a DHCP server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dhcp_server(server_id, logical_dhcp_server, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param LogicalDhcpServer logical_dhcp_server: (required)
        :return: LogicalDhcpServer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dhcp_server_with_http_info(server_id, logical_dhcp_server, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dhcp_server_with_http_info(server_id, logical_dhcp_server, **kwargs)  # noqa: E501
            return data

    def update_dhcp_server_with_http_info(self, server_id, logical_dhcp_server, **kwargs):  # noqa: E501
        """Update a DHCP server  # noqa: E501

        Update a DHCP server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dhcp_server_with_http_info(server_id, logical_dhcp_server, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param LogicalDhcpServer logical_dhcp_server: (required)
        :return: LogicalDhcpServer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'logical_dhcp_server']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dhcp_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `update_dhcp_server`")  # noqa: E501
        # verify the required parameter 'logical_dhcp_server' is set
        if ('logical_dhcp_server' not in params or
                params['logical_dhcp_server'] is None):
            raise ValueError("Missing the required parameter `logical_dhcp_server` when calling `update_dhcp_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'logical_dhcp_server' in params:
            body_params = params['logical_dhcp_server']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogicalDhcpServer',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dhcp_static_binding(self, server_id, binding_id, dhcp_static_binding, **kwargs):  # noqa: E501
        """Update a DHCP server&#39;s static binding  # noqa: E501

        Update a DHCP server's static binding  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dhcp_static_binding(server_id, binding_id, dhcp_static_binding, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param str binding_id: (required)
        :param DhcpStaticBinding dhcp_static_binding: (required)
        :return: DhcpStaticBinding
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dhcp_static_binding_with_http_info(server_id, binding_id, dhcp_static_binding, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dhcp_static_binding_with_http_info(server_id, binding_id, dhcp_static_binding, **kwargs)  # noqa: E501
            return data

    def update_dhcp_static_binding_with_http_info(self, server_id, binding_id, dhcp_static_binding, **kwargs):  # noqa: E501
        """Update a DHCP server&#39;s static binding  # noqa: E501

        Update a DHCP server's static binding  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dhcp_static_binding_with_http_info(server_id, binding_id, dhcp_static_binding, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_id: (required)
        :param str binding_id: (required)
        :param DhcpStaticBinding dhcp_static_binding: (required)
        :return: DhcpStaticBinding
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_id', 'binding_id', 'dhcp_static_binding']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dhcp_static_binding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_id' is set
        if ('server_id' not in params or
                params['server_id'] is None):
            raise ValueError("Missing the required parameter `server_id` when calling `update_dhcp_static_binding`")  # noqa: E501
        # verify the required parameter 'binding_id' is set
        if ('binding_id' not in params or
                params['binding_id'] is None):
            raise ValueError("Missing the required parameter `binding_id` when calling `update_dhcp_static_binding`")  # noqa: E501
        # verify the required parameter 'dhcp_static_binding' is set
        if ('dhcp_static_binding' not in params or
                params['dhcp_static_binding'] is None):
            raise ValueError("Missing the required parameter `dhcp_static_binding` when calling `update_dhcp_static_binding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_id' in params:
            path_params['server-id'] = params['server_id']  # noqa: E501
        if 'binding_id' in params:
            path_params['binding-id'] = params['binding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dhcp_static_binding' in params:
            body_params = params['dhcp_static_binding']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/dhcp/servers/{server-id}/static-bindings/{binding-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DhcpStaticBinding',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dne_global_config(self, dne_global_config, **kwargs):  # noqa: E501
        """Update the global configuration of network encryption service  # noqa: E501

        Update the global configuration of network encryption service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dne_global_config(dne_global_config, async=True)
        >>> result = thread.get()

        :param async bool
        :param DneGlobalConfig dne_global_config: (required)
        :return: DneGlobalConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dne_global_config_with_http_info(dne_global_config, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dne_global_config_with_http_info(dne_global_config, **kwargs)  # noqa: E501
            return data

    def update_dne_global_config_with_http_info(self, dne_global_config, **kwargs):  # noqa: E501
        """Update the global configuration of network encryption service  # noqa: E501

        Update the global configuration of network encryption service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dne_global_config_with_http_info(dne_global_config, async=True)
        >>> result = thread.get()

        :param async bool
        :param DneGlobalConfig dne_global_config: (required)
        :return: DneGlobalConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dne_global_config']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dne_global_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dne_global_config' is set
        if ('dne_global_config' not in params or
                params['dne_global_config'] is None):
            raise ValueError("Missing the required parameter `dne_global_config` when calling `update_dne_global_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dne_global_config' in params:
            body_params = params['dne_global_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneGlobalConfig',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dne_key_manager(self, key_manager_id, dne_key_manager, **kwargs):  # noqa: E501
        """Update a specific network encryption key manager configuration  # noqa: E501

        Update a specific network encryption key manager configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dne_key_manager(key_manager_id, dne_key_manager, async=True)
        >>> result = thread.get()

        :param async bool
        :param str key_manager_id: (required)
        :param DneKeyManager dne_key_manager: (required)
        :return: DneKeyManager
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dne_key_manager_with_http_info(key_manager_id, dne_key_manager, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dne_key_manager_with_http_info(key_manager_id, dne_key_manager, **kwargs)  # noqa: E501
            return data

    def update_dne_key_manager_with_http_info(self, key_manager_id, dne_key_manager, **kwargs):  # noqa: E501
        """Update a specific network encryption key manager configuration  # noqa: E501

        Update a specific network encryption key manager configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dne_key_manager_with_http_info(key_manager_id, dne_key_manager, async=True)
        >>> result = thread.get()

        :param async bool
        :param str key_manager_id: (required)
        :param DneKeyManager dne_key_manager: (required)
        :return: DneKeyManager
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['key_manager_id', 'dne_key_manager']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dne_key_manager" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_manager_id' is set
        if ('key_manager_id' not in params or
                params['key_manager_id'] is None):
            raise ValueError("Missing the required parameter `key_manager_id` when calling `update_dne_key_manager`")  # noqa: E501
        # verify the required parameter 'dne_key_manager' is set
        if ('dne_key_manager' not in params or
                params['dne_key_manager'] is None):
            raise ValueError("Missing the required parameter `dne_key_manager` when calling `update_dne_key_manager`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'key_manager_id' in params:
            path_params['key-manager-id'] = params['key_manager_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dne_key_manager' in params:
            body_params = params['dne_key_manager']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/key-managers/{key-manager-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneKeyManager',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dne_key_policy(self, key_policy_id, dne_key_policy, **kwargs):  # noqa: E501
        """Update a network encryption key policy  # noqa: E501

        Update a network encryption key policy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dne_key_policy(key_policy_id, dne_key_policy, async=True)
        >>> result = thread.get()

        :param async bool
        :param str key_policy_id: (required)
        :param DneKeyPolicy dne_key_policy: (required)
        :return: DneKeyPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dne_key_policy_with_http_info(key_policy_id, dne_key_policy, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dne_key_policy_with_http_info(key_policy_id, dne_key_policy, **kwargs)  # noqa: E501
            return data

    def update_dne_key_policy_with_http_info(self, key_policy_id, dne_key_policy, **kwargs):  # noqa: E501
        """Update a network encryption key policy  # noqa: E501

        Update a network encryption key policy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dne_key_policy_with_http_info(key_policy_id, dne_key_policy, async=True)
        >>> result = thread.get()

        :param async bool
        :param str key_policy_id: (required)
        :param DneKeyPolicy dne_key_policy: (required)
        :return: DneKeyPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['key_policy_id', 'dne_key_policy']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dne_key_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_policy_id' is set
        if ('key_policy_id' not in params or
                params['key_policy_id'] is None):
            raise ValueError("Missing the required parameter `key_policy_id` when calling `update_dne_key_policy`")  # noqa: E501
        # verify the required parameter 'dne_key_policy' is set
        if ('dne_key_policy' not in params or
                params['dne_key_policy'] is None):
            raise ValueError("Missing the required parameter `dne_key_policy` when calling `update_dne_key_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'key_policy_id' in params:
            path_params['key-policy-id'] = params['key_policy_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dne_key_policy' in params:
            body_params = params['dne_key_policy']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/key-policies/{key-policy-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneKeyPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dne_rule(self, section_id, rule_id, dne_rule, **kwargs):  # noqa: E501
        """Update a specific rule in a network encryption section  # noqa: E501

        Update a specific rule in a network encryption section  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dne_rule(section_id, rule_id, dne_rule, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :param DneRule dne_rule: (required)
        :return: DneRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dne_rule_with_http_info(section_id, rule_id, dne_rule, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dne_rule_with_http_info(section_id, rule_id, dne_rule, **kwargs)  # noqa: E501
            return data

    def update_dne_rule_with_http_info(self, section_id, rule_id, dne_rule, **kwargs):  # noqa: E501
        """Update a specific rule in a network encryption section  # noqa: E501

        Update a specific rule in a network encryption section  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dne_rule_with_http_info(section_id, rule_id, dne_rule, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :param DneRule dne_rule: (required)
        :return: DneRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'rule_id', 'dne_rule']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dne_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `update_dne_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `update_dne_rule`")  # noqa: E501
        # verify the required parameter 'dne_rule' is set
        if ('dne_rule' not in params or
                params['dne_rule'] is None):
            raise ValueError("Missing the required parameter `dne_rule` when calling `update_dne_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dne_rule' in params:
            body_params = params['dne_rule']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/sections/{section-id}/rules/{rule-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneRule',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dne_section(self, section_id, dne_section, **kwargs):  # noqa: E501
        """Update a network encryption section  # noqa: E501

        Update the section but not its rules.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dne_section(section_id, dne_section, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param DneSection dne_section: (required)
        :return: DneSection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dne_section_with_http_info(section_id, dne_section, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dne_section_with_http_info(section_id, dne_section, **kwargs)  # noqa: E501
            return data

    def update_dne_section_with_http_info(self, section_id, dne_section, **kwargs):  # noqa: E501
        """Update a network encryption section  # noqa: E501

        Update the section but not its rules.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dne_section_with_http_info(section_id, dne_section, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param DneSection dne_section: (required)
        :return: DneSection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'dne_section']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dne_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `update_dne_section`")  # noqa: E501
        # verify the required parameter 'dne_section' is set
        if ('dne_section' not in params or
                params['dne_section'] is None):
            raise ValueError("Missing the required parameter `dne_section` when calling `update_dne_section`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dne_section' in params:
            body_params = params['dne_section']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/sections/{section-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneSection',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dne_section_with_rules_update_with_rules(self, section_id, dne_section_rule_list, **kwargs):  # noqa: E501
        """Update a network encryption section and its rules  # noqa: E501

        This API returns an error if the section does not have rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to update rule content, use: PUT /api/v1/network-enryption/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt;   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dne_section_with_rules_update_with_rules(section_id, dne_section_rule_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param DneSectionRuleList dne_section_rule_list: (required)
        :return: DneSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dne_section_with_rules_update_with_rules_with_http_info(section_id, dne_section_rule_list, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dne_section_with_rules_update_with_rules_with_http_info(section_id, dne_section_rule_list, **kwargs)  # noqa: E501
            return data

    def update_dne_section_with_rules_update_with_rules_with_http_info(self, section_id, dne_section_rule_list, **kwargs):  # noqa: E501
        """Update a network encryption section and its rules  # noqa: E501

        This API returns an error if the section does not have rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to update rule content, use: PUT /api/v1/network-enryption/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt;   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dne_section_with_rules_update_with_rules_with_http_info(section_id, dne_section_rule_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param DneSectionRuleList dne_section_rule_list: (required)
        :return: DneSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'dne_section_rule_list']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dne_section_with_rules_update_with_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `update_dne_section_with_rules_update_with_rules`")  # noqa: E501
        # verify the required parameter 'dne_section_rule_list' is set
        if ('dne_section_rule_list' not in params or
                params['dne_section_rule_list'] is None):
            raise ValueError("Missing the required parameter `dne_section_rule_list` when calling `update_dne_section_with_rules_update_with_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dne_section_rule_list' in params:
            body_params = params['dne_section_rule_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/sections/{section-id}?action=update_with_rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DneSectionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_exclude_list(self, exclude_list, **kwargs):  # noqa: E501
        """Modify exclude list  # noqa: E501

        Modify exclude list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_exclude_list(exclude_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param ExcludeList exclude_list: (required)
        :return: ExcludeList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_exclude_list_with_http_info(exclude_list, **kwargs)  # noqa: E501
        else:
            (data) = self.update_exclude_list_with_http_info(exclude_list, **kwargs)  # noqa: E501
            return data

    def update_exclude_list_with_http_info(self, exclude_list, **kwargs):  # noqa: E501
        """Modify exclude list  # noqa: E501

        Modify exclude list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_exclude_list_with_http_info(exclude_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param ExcludeList exclude_list: (required)
        :return: ExcludeList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['exclude_list']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_exclude_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'exclude_list' is set
        if ('exclude_list' not in params or
                params['exclude_list'] is None):
            raise ValueError("Missing the required parameter `exclude_list` when calling `update_exclude_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'exclude_list' in params:
            body_params = params['exclude_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/excludelist', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExcludeList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_firewall_status(self, context_type, firewall_status, **kwargs):  # noqa: E501
        """Update global firewall status for dfw context  # noqa: E501

        Update global firewall status for dfw context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_firewall_status(context_type, firewall_status, async=True)
        >>> result = thread.get()

        :param async bool
        :param str context_type: (required)
        :param FirewallStatus firewall_status: (required)
        :return: FirewallStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_firewall_status_with_http_info(context_type, firewall_status, **kwargs)  # noqa: E501
        else:
            (data) = self.update_firewall_status_with_http_info(context_type, firewall_status, **kwargs)  # noqa: E501
            return data

    def update_firewall_status_with_http_info(self, context_type, firewall_status, **kwargs):  # noqa: E501
        """Update global firewall status for dfw context  # noqa: E501

        Update global firewall status for dfw context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_firewall_status_with_http_info(context_type, firewall_status, async=True)
        >>> result = thread.get()

        :param async bool
        :param str context_type: (required)
        :param FirewallStatus firewall_status: (required)
        :return: FirewallStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['context_type', 'firewall_status']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_firewall_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'context_type' is set
        if ('context_type' not in params or
                params['context_type'] is None):
            raise ValueError("Missing the required parameter `context_type` when calling `update_firewall_status`")  # noqa: E501
        # verify the required parameter 'firewall_status' is set
        if ('firewall_status' not in params or
                params['firewall_status'] is None):
            raise ValueError("Missing the required parameter `firewall_status` when calling `update_firewall_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'context_type' in params:
            path_params['context-type'] = params['context_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'firewall_status' in params:
            body_params = params['firewall_status']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/status/{context-type}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_load_balancer_application_profile(self, application_profile_id, lb_app_profile, **kwargs):  # noqa: E501
        """Update a load balancer application profile  # noqa: E501

        Update a load balancer application profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_load_balancer_application_profile(application_profile_id, lb_app_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str application_profile_id: (required)
        :param LbAppProfile lb_app_profile: (required)
        :return: LbAppProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_load_balancer_application_profile_with_http_info(application_profile_id, lb_app_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.update_load_balancer_application_profile_with_http_info(application_profile_id, lb_app_profile, **kwargs)  # noqa: E501
            return data

    def update_load_balancer_application_profile_with_http_info(self, application_profile_id, lb_app_profile, **kwargs):  # noqa: E501
        """Update a load balancer application profile  # noqa: E501

        Update a load balancer application profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_load_balancer_application_profile_with_http_info(application_profile_id, lb_app_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str application_profile_id: (required)
        :param LbAppProfile lb_app_profile: (required)
        :return: LbAppProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_profile_id', 'lb_app_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_load_balancer_application_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_profile_id' is set
        if ('application_profile_id' not in params or
                params['application_profile_id'] is None):
            raise ValueError("Missing the required parameter `application_profile_id` when calling `update_load_balancer_application_profile`")  # noqa: E501
        # verify the required parameter 'lb_app_profile' is set
        if ('lb_app_profile' not in params or
                params['lb_app_profile'] is None):
            raise ValueError("Missing the required parameter `lb_app_profile` when calling `update_load_balancer_application_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_profile_id' in params:
            path_params['application-profile-id'] = params['application_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'lb_app_profile' in params:
            body_params = params['lb_app_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/application-profiles/{application-profile-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbAppProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_load_balancer_client_ssl_profile(self, client_ssl_profile_id, lb_client_ssl_profile, **kwargs):  # noqa: E501
        """Update a load balancer client-ssl profile  # noqa: E501

        Update a load balancer client-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_load_balancer_client_ssl_profile(client_ssl_profile_id, lb_client_ssl_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str client_ssl_profile_id: (required)
        :param LbClientSslProfile lb_client_ssl_profile: (required)
        :return: LbClientSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, lb_client_ssl_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.update_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, lb_client_ssl_profile, **kwargs)  # noqa: E501
            return data

    def update_load_balancer_client_ssl_profile_with_http_info(self, client_ssl_profile_id, lb_client_ssl_profile, **kwargs):  # noqa: E501
        """Update a load balancer client-ssl profile  # noqa: E501

        Update a load balancer client-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_load_balancer_client_ssl_profile_with_http_info(client_ssl_profile_id, lb_client_ssl_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str client_ssl_profile_id: (required)
        :param LbClientSslProfile lb_client_ssl_profile: (required)
        :return: LbClientSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_ssl_profile_id', 'lb_client_ssl_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_load_balancer_client_ssl_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_ssl_profile_id' is set
        if ('client_ssl_profile_id' not in params or
                params['client_ssl_profile_id'] is None):
            raise ValueError("Missing the required parameter `client_ssl_profile_id` when calling `update_load_balancer_client_ssl_profile`")  # noqa: E501
        # verify the required parameter 'lb_client_ssl_profile' is set
        if ('lb_client_ssl_profile' not in params or
                params['lb_client_ssl_profile'] is None):
            raise ValueError("Missing the required parameter `lb_client_ssl_profile` when calling `update_load_balancer_client_ssl_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'client_ssl_profile_id' in params:
            path_params['client-ssl-profile-id'] = params['client_ssl_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'lb_client_ssl_profile' in params:
            body_params = params['lb_client_ssl_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/client-ssl-profiles/{client-ssl-profile-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbClientSslProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_load_balancer_monitor(self, monitor_id, lb_monitor, **kwargs):  # noqa: E501
        """Update a load balancer monitor  # noqa: E501

        Update a load balancer monitor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_load_balancer_monitor(monitor_id, lb_monitor, async=True)
        >>> result = thread.get()

        :param async bool
        :param str monitor_id: (required)
        :param LbMonitor lb_monitor: (required)
        :return: LbMonitor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_load_balancer_monitor_with_http_info(monitor_id, lb_monitor, **kwargs)  # noqa: E501
        else:
            (data) = self.update_load_balancer_monitor_with_http_info(monitor_id, lb_monitor, **kwargs)  # noqa: E501
            return data

    def update_load_balancer_monitor_with_http_info(self, monitor_id, lb_monitor, **kwargs):  # noqa: E501
        """Update a load balancer monitor  # noqa: E501

        Update a load balancer monitor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_load_balancer_monitor_with_http_info(monitor_id, lb_monitor, async=True)
        >>> result = thread.get()

        :param async bool
        :param str monitor_id: (required)
        :param LbMonitor lb_monitor: (required)
        :return: LbMonitor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['monitor_id', 'lb_monitor']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_load_balancer_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'monitor_id' is set
        if ('monitor_id' not in params or
                params['monitor_id'] is None):
            raise ValueError("Missing the required parameter `monitor_id` when calling `update_load_balancer_monitor`")  # noqa: E501
        # verify the required parameter 'lb_monitor' is set
        if ('lb_monitor' not in params or
                params['lb_monitor'] is None):
            raise ValueError("Missing the required parameter `lb_monitor` when calling `update_load_balancer_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'monitor_id' in params:
            path_params['monitor-id'] = params['monitor_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'lb_monitor' in params:
            body_params = params['lb_monitor']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/monitors/{monitor-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbMonitor',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_load_balancer_persistence_profile(self, persistence_profile_id, lb_persistence_profile, **kwargs):  # noqa: E501
        """Update a load balancer persistence profile  # noqa: E501

        Update a load balancer persistence profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_load_balancer_persistence_profile(persistence_profile_id, lb_persistence_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str persistence_profile_id: (required)
        :param LbPersistenceProfile lb_persistence_profile: (required)
        :return: LbPersistenceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_load_balancer_persistence_profile_with_http_info(persistence_profile_id, lb_persistence_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.update_load_balancer_persistence_profile_with_http_info(persistence_profile_id, lb_persistence_profile, **kwargs)  # noqa: E501
            return data

    def update_load_balancer_persistence_profile_with_http_info(self, persistence_profile_id, lb_persistence_profile, **kwargs):  # noqa: E501
        """Update a load balancer persistence profile  # noqa: E501

        Update a load balancer persistence profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_load_balancer_persistence_profile_with_http_info(persistence_profile_id, lb_persistence_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str persistence_profile_id: (required)
        :param LbPersistenceProfile lb_persistence_profile: (required)
        :return: LbPersistenceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['persistence_profile_id', 'lb_persistence_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_load_balancer_persistence_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'persistence_profile_id' is set
        if ('persistence_profile_id' not in params or
                params['persistence_profile_id'] is None):
            raise ValueError("Missing the required parameter `persistence_profile_id` when calling `update_load_balancer_persistence_profile`")  # noqa: E501
        # verify the required parameter 'lb_persistence_profile' is set
        if ('lb_persistence_profile' not in params or
                params['lb_persistence_profile'] is None):
            raise ValueError("Missing the required parameter `lb_persistence_profile` when calling `update_load_balancer_persistence_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'persistence_profile_id' in params:
            path_params['persistence-profile-id'] = params['persistence_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'lb_persistence_profile' in params:
            body_params = params['lb_persistence_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/persistence-profiles/{persistence-profile-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPersistenceProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_load_balancer_pool(self, pool_id, lb_pool, **kwargs):  # noqa: E501
        """Update a load balancer pool  # noqa: E501

        Update a load balancer pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_load_balancer_pool(pool_id, lb_pool, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: (required)
        :param LbPool lb_pool: (required)
        :return: LbPool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_load_balancer_pool_with_http_info(pool_id, lb_pool, **kwargs)  # noqa: E501
        else:
            (data) = self.update_load_balancer_pool_with_http_info(pool_id, lb_pool, **kwargs)  # noqa: E501
            return data

    def update_load_balancer_pool_with_http_info(self, pool_id, lb_pool, **kwargs):  # noqa: E501
        """Update a load balancer pool  # noqa: E501

        Update a load balancer pool.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_load_balancer_pool_with_http_info(pool_id, lb_pool, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pool_id: (required)
        :param LbPool lb_pool: (required)
        :return: LbPool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pool_id', 'lb_pool']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_load_balancer_pool" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pool_id' is set
        if ('pool_id' not in params or
                params['pool_id'] is None):
            raise ValueError("Missing the required parameter `pool_id` when calling `update_load_balancer_pool`")  # noqa: E501
        # verify the required parameter 'lb_pool' is set
        if ('lb_pool' not in params or
                params['lb_pool'] is None):
            raise ValueError("Missing the required parameter `lb_pool` when calling `update_load_balancer_pool`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pool_id' in params:
            path_params['pool-id'] = params['pool_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'lb_pool' in params:
            body_params = params['lb_pool']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/pools/{pool-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbPool',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_load_balancer_rule(self, rule_id, lb_rule, **kwargs):  # noqa: E501
        """Update a load balancer rule  # noqa: E501

        Update a load balancer rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_load_balancer_rule(rule_id, lb_rule, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rule_id: (required)
        :param LbRule lb_rule: (required)
        :return: LbRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_load_balancer_rule_with_http_info(rule_id, lb_rule, **kwargs)  # noqa: E501
        else:
            (data) = self.update_load_balancer_rule_with_http_info(rule_id, lb_rule, **kwargs)  # noqa: E501
            return data

    def update_load_balancer_rule_with_http_info(self, rule_id, lb_rule, **kwargs):  # noqa: E501
        """Update a load balancer rule  # noqa: E501

        Update a load balancer rule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_load_balancer_rule_with_http_info(rule_id, lb_rule, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rule_id: (required)
        :param LbRule lb_rule: (required)
        :return: LbRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_id', 'lb_rule']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_load_balancer_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `update_load_balancer_rule`")  # noqa: E501
        # verify the required parameter 'lb_rule' is set
        if ('lb_rule' not in params or
                params['lb_rule'] is None):
            raise ValueError("Missing the required parameter `lb_rule` when calling `update_load_balancer_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'lb_rule' in params:
            body_params = params['lb_rule']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/rules/{rule-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbRule',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_load_balancer_server_ssl_profile(self, server_ssl_profile_id, lb_server_ssl_profile, **kwargs):  # noqa: E501
        """Update a load balancer server-ssl profile  # noqa: E501

        Update a load balancer server-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_load_balancer_server_ssl_profile(server_ssl_profile_id, lb_server_ssl_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_ssl_profile_id: (required)
        :param LbServerSslProfile lb_server_ssl_profile: (required)
        :return: LbServerSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, lb_server_ssl_profile, **kwargs)  # noqa: E501
        else:
            (data) = self.update_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, lb_server_ssl_profile, **kwargs)  # noqa: E501
            return data

    def update_load_balancer_server_ssl_profile_with_http_info(self, server_ssl_profile_id, lb_server_ssl_profile, **kwargs):  # noqa: E501
        """Update a load balancer server-ssl profile  # noqa: E501

        Update a load balancer server-ssl profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_load_balancer_server_ssl_profile_with_http_info(server_ssl_profile_id, lb_server_ssl_profile, async=True)
        >>> result = thread.get()

        :param async bool
        :param str server_ssl_profile_id: (required)
        :param LbServerSslProfile lb_server_ssl_profile: (required)
        :return: LbServerSslProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['server_ssl_profile_id', 'lb_server_ssl_profile']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_load_balancer_server_ssl_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'server_ssl_profile_id' is set
        if ('server_ssl_profile_id' not in params or
                params['server_ssl_profile_id'] is None):
            raise ValueError("Missing the required parameter `server_ssl_profile_id` when calling `update_load_balancer_server_ssl_profile`")  # noqa: E501
        # verify the required parameter 'lb_server_ssl_profile' is set
        if ('lb_server_ssl_profile' not in params or
                params['lb_server_ssl_profile'] is None):
            raise ValueError("Missing the required parameter `lb_server_ssl_profile` when calling `update_load_balancer_server_ssl_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'server_ssl_profile_id' in params:
            path_params['server-ssl-profile-id'] = params['server_ssl_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'lb_server_ssl_profile' in params:
            body_params = params['lb_server_ssl_profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/server-ssl-profiles/{server-ssl-profile-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbServerSslProfile',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_load_balancer_service(self, service_id, lb_service, **kwargs):  # noqa: E501
        """Update a load balancer service  # noqa: E501

        Update a load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_load_balancer_service(service_id, lb_service, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param LbService lb_service: (required)
        :return: LbService
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_load_balancer_service_with_http_info(service_id, lb_service, **kwargs)  # noqa: E501
        else:
            (data) = self.update_load_balancer_service_with_http_info(service_id, lb_service, **kwargs)  # noqa: E501
            return data

    def update_load_balancer_service_with_http_info(self, service_id, lb_service, **kwargs):  # noqa: E501
        """Update a load balancer service  # noqa: E501

        Update a load balancer service.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_load_balancer_service_with_http_info(service_id, lb_service, async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_id: (required)
        :param LbService lb_service: (required)
        :return: LbService
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_id', 'lb_service']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_load_balancer_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_id' is set
        if ('service_id' not in params or
                params['service_id'] is None):
            raise ValueError("Missing the required parameter `service_id` when calling `update_load_balancer_service`")  # noqa: E501
        # verify the required parameter 'lb_service' is set
        if ('lb_service' not in params or
                params['lb_service'] is None):
            raise ValueError("Missing the required parameter `lb_service` when calling `update_load_balancer_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in params:
            path_params['service-id'] = params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'lb_service' in params:
            body_params = params['lb_service']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/services/{service-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbService',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_load_balancer_virtual_server(self, virtual_server_id, lb_virtual_server, **kwargs):  # noqa: E501
        """Update a load balancer virtual server  # noqa: E501

        Update a load balancer virtual server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_load_balancer_virtual_server(virtual_server_id, lb_virtual_server, async=True)
        >>> result = thread.get()

        :param async bool
        :param str virtual_server_id: (required)
        :param LbVirtualServer lb_virtual_server: (required)
        :return: LbVirtualServer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_load_balancer_virtual_server_with_http_info(virtual_server_id, lb_virtual_server, **kwargs)  # noqa: E501
        else:
            (data) = self.update_load_balancer_virtual_server_with_http_info(virtual_server_id, lb_virtual_server, **kwargs)  # noqa: E501
            return data

    def update_load_balancer_virtual_server_with_http_info(self, virtual_server_id, lb_virtual_server, **kwargs):  # noqa: E501
        """Update a load balancer virtual server  # noqa: E501

        Update a load balancer virtual server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_load_balancer_virtual_server_with_http_info(virtual_server_id, lb_virtual_server, async=True)
        >>> result = thread.get()

        :param async bool
        :param str virtual_server_id: (required)
        :param LbVirtualServer lb_virtual_server: (required)
        :return: LbVirtualServer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['virtual_server_id', 'lb_virtual_server']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_load_balancer_virtual_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'virtual_server_id' is set
        if ('virtual_server_id' not in params or
                params['virtual_server_id'] is None):
            raise ValueError("Missing the required parameter `virtual_server_id` when calling `update_load_balancer_virtual_server`")  # noqa: E501
        # verify the required parameter 'lb_virtual_server' is set
        if ('lb_virtual_server' not in params or
                params['lb_virtual_server'] is None):
            raise ValueError("Missing the required parameter `lb_virtual_server` when calling `update_load_balancer_virtual_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'virtual_server_id' in params:
            path_params['virtual-server-id'] = params['virtual_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'lb_virtual_server' in params:
            body_params = params['lb_virtual_server']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/loadbalancer/virtual-servers/{virtual-server-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbVirtualServer',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_metadata_proxy(self, proxy_id, metadata_proxy, **kwargs):  # noqa: E501
        """Update a metadata proxy  # noqa: E501

        Update a metadata proxy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_metadata_proxy(proxy_id, metadata_proxy, async=True)
        >>> result = thread.get()

        :param async bool
        :param str proxy_id: (required)
        :param MetadataProxy metadata_proxy: (required)
        :return: MetadataProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_metadata_proxy_with_http_info(proxy_id, metadata_proxy, **kwargs)  # noqa: E501
        else:
            (data) = self.update_metadata_proxy_with_http_info(proxy_id, metadata_proxy, **kwargs)  # noqa: E501
            return data

    def update_metadata_proxy_with_http_info(self, proxy_id, metadata_proxy, **kwargs):  # noqa: E501
        """Update a metadata proxy  # noqa: E501

        Update a metadata proxy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_metadata_proxy_with_http_info(proxy_id, metadata_proxy, async=True)
        >>> result = thread.get()

        :param async bool
        :param str proxy_id: (required)
        :param MetadataProxy metadata_proxy: (required)
        :return: MetadataProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proxy_id', 'metadata_proxy']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_metadata_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proxy_id' is set
        if ('proxy_id' not in params or
                params['proxy_id'] is None):
            raise ValueError("Missing the required parameter `proxy_id` when calling `update_metadata_proxy`")  # noqa: E501
        # verify the required parameter 'metadata_proxy' is set
        if ('metadata_proxy' not in params or
                params['metadata_proxy'] is None):
            raise ValueError("Missing the required parameter `metadata_proxy` when calling `update_metadata_proxy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proxy_id' in params:
            path_params['proxy-id'] = params['proxy_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'metadata_proxy' in params:
            body_params = params['metadata_proxy']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/md-proxies/{proxy-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MetadataProxy',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_network_encryption_status_update_status(self, context, **kwargs):  # noqa: E501
        """Update the firewall status for a given context  # noqa: E501

        Update the firewall status for a given context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_network_encryption_status_update_status(context, async=True)
        >>> result = thread.get()

        :param async bool
        :param str context: Context for which network encryption status. (required)
        :param str status: status of the given context. It could be one of the following values.
        :return: NetworkEncryptionStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_network_encryption_status_update_status_with_http_info(context, **kwargs)  # noqa: E501
        else:
            (data) = self.update_network_encryption_status_update_status_with_http_info(context, **kwargs)  # noqa: E501
            return data

    def update_network_encryption_status_update_status_with_http_info(self, context, **kwargs):  # noqa: E501
        """Update the firewall status for a given context  # noqa: E501

        Update the firewall status for a given context  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_network_encryption_status_update_status_with_http_info(context, async=True)
        >>> result = thread.get()

        :param async bool
        :param str context: Context for which network encryption status. (required)
        :param str status: status of the given context. It could be one of the following values.
        :return: NetworkEncryptionStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['context', 'status']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_network_encryption_status_update_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'context' is set
        if ('context' not in params or
                params['context'] is None):
            raise ValueError("Missing the required parameter `context` when calling `update_network_encryption_status_update_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'context' in params:
            query_params.append(('context', params['context']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/network-encryption/status?action=update_status', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetworkEncryptionStatus',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_rule(self, section_id, rule_id, firewall_rule, **kwargs):  # noqa: E501
        """Update an Existing Rule  # noqa: E501

        Modifies existing firewall rule in a firewall section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_rule(section_id, rule_id, firewall_rule, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :param FirewallRule firewall_rule: (required)
        :return: FirewallRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_rule_with_http_info(section_id, rule_id, firewall_rule, **kwargs)  # noqa: E501
        else:
            (data) = self.update_rule_with_http_info(section_id, rule_id, firewall_rule, **kwargs)  # noqa: E501
            return data

    def update_rule_with_http_info(self, section_id, rule_id, firewall_rule, **kwargs):  # noqa: E501
        """Update an Existing Rule  # noqa: E501

        Modifies existing firewall rule in a firewall section.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_rule_with_http_info(section_id, rule_id, firewall_rule, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param str rule_id: (required)
        :param FirewallRule firewall_rule: (required)
        :return: FirewallRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'rule_id', 'firewall_rule']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `update_rule`")  # noqa: E501
        # verify the required parameter 'rule_id' is set
        if ('rule_id' not in params or
                params['rule_id'] is None):
            raise ValueError("Missing the required parameter `rule_id` when calling `update_rule`")  # noqa: E501
        # verify the required parameter 'firewall_rule' is set
        if ('firewall_rule' not in params or
                params['firewall_rule'] is None):
            raise ValueError("Missing the required parameter `firewall_rule` when calling `update_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501
        if 'rule_id' in params:
            path_params['rule-id'] = params['rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'firewall_rule' in params:
            body_params = params['firewall_rule']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}/rules/{rule-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallRule',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_section(self, section_id, firewall_section, **kwargs):  # noqa: E501
        """Update an Existing Section  # noqa: E501

        Modifies the specified section, but does not modify the section's associated rules.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_section(section_id, firewall_section, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param FirewallSection firewall_section: (required)
        :return: FirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_section_with_http_info(section_id, firewall_section, **kwargs)  # noqa: E501
        else:
            (data) = self.update_section_with_http_info(section_id, firewall_section, **kwargs)  # noqa: E501
            return data

    def update_section_with_http_info(self, section_id, firewall_section, **kwargs):  # noqa: E501
        """Update an Existing Section  # noqa: E501

        Modifies the specified section, but does not modify the section's associated rules.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_section_with_http_info(section_id, firewall_section, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param FirewallSection firewall_section: (required)
        :return: FirewallSection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'firewall_section']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `update_section`")  # noqa: E501
        # verify the required parameter 'firewall_section' is set
        if ('firewall_section' not in params or
                params['firewall_section'] is None):
            raise ValueError("Missing the required parameter `firewall_section` when calling `update_section`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'firewall_section' in params:
            body_params = params['firewall_section']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSection',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_section_with_rules_update_with_rules(self, section_id, firewall_section_rule_list, **kwargs):  # noqa: E501
        """Update an Existing Section, Including Its Rules  # noqa: E501

        Modifies existing firewall section along with its association with rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to update rule content, use: PUT /api/v1/firewall/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt;   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_section_with_rules_update_with_rules(section_id, firewall_section_rule_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param FirewallSectionRuleList firewall_section_rule_list: (required)
        :return: FirewallSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_section_with_rules_update_with_rules_with_http_info(section_id, firewall_section_rule_list, **kwargs)  # noqa: E501
        else:
            (data) = self.update_section_with_rules_update_with_rules_with_http_info(section_id, firewall_section_rule_list, **kwargs)  # noqa: E501
            return data

    def update_section_with_rules_update_with_rules_with_http_info(self, section_id, firewall_section_rule_list, **kwargs):  # noqa: E501
        """Update an Existing Section, Including Its Rules  # noqa: E501

        Modifies existing firewall section along with its association with rules. When invoked on a large number of rules, this API is supported only at low rates of invocation (not more than 2 times per minute). The typical latency of this API with about 1024 rules is about 15 seconds in a cluster setup. This API should not be invoked with large payloads at automation speeds.  Instead, to update rule content, use: PUT /api/v1/firewall/sections/&lt;section-id&gt;/rules/&lt;rule-id&gt;   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_section_with_rules_update_with_rules_with_http_info(section_id, firewall_section_rule_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param str section_id: (required)
        :param FirewallSectionRuleList firewall_section_rule_list: (required)
        :return: FirewallSectionRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_id', 'firewall_section_rule_list']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_section_with_rules_update_with_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_id' is set
        if ('section_id' not in params or
                params['section_id'] is None):
            raise ValueError("Missing the required parameter `section_id` when calling `update_section_with_rules_update_with_rules`")  # noqa: E501
        # verify the required parameter 'firewall_section_rule_list' is set
        if ('firewall_section_rule_list' not in params or
                params['firewall_section_rule_list'] is None):
            raise ValueError("Missing the required parameter `firewall_section_rule_list` when calling `update_section_with_rules_update_with_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_id' in params:
            path_params['section-id'] = params['section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'firewall_section_rule_list' in params:
            body_params = params['firewall_section_rule_list']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/firewall/sections/{section-id}?action=update_with_rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirewallSectionRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
